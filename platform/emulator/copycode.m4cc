/* -*- C++ -*-
 *  Authors:
 *    Ralf Scheidhauer (Ralf.Scheidhauer@ps.uni-sb.de)
 * 
 *  Contributors:
 * 
 *  Copyright:
 *    Organization or Person (Year(s))
 * 
 *  Last change:
 *    $_Date$ by $_Author$
 *    $_Revision$
 * 
 *  This file is part of Mozart, an implementation 
 *  of Oz 3:
 *     http://www.mozart-oz.org
 * 
 *  See the file "LICENSE" or
 *     http://www.mozart-oz.org/LICENSE.html
 *  for information on usage and redistribution 
 *  of this file, and for a DISCLAIMER OF ALL 
 *  WARRANTIES.
 *
 */


#include "copycode.hh"
#include "indexing.hh"
#include "value.hh"
#include "codearea.hh"

define(readArg,$1)
define(writeArg,$1)
define(instruction,
	`case TOUPPER($1):
	   opAction($2)
	   opAction($3)
	   opAction($4)
	   opAction($5)
	   opAction($6)
	   opAction($7)
	   opAction($8)
	   opAction($9)
	  break;')

define(opAction,
`ifelse($1,Literal, handleLiteral(PC++,ht,code);,
        $1,Feature, handleLiteral(PC++,ht,code);,
        $1,Constant,handleLiteral(PC,ht,code);PC++;,
        $1,Number,handleLiteral(PC,ht,code);PC++;,
        $1,RecordArity, handleRecordArity(PC++,ht);,
        $1,ProcedureRef,handleProcedureRef(PC++,ht,code);,
        $1,PredId,  handlePredId(PC++,ht);,
        $1,HashTableRef, handleHashTable(PC++,ht);,
        $1,CallMethodInfo,handleCallMethodInfo(PC++,ht);,
        $1,Cache,handleCache(PC,code); PC += CacheSize;,
        $1,,,
        PC++;)')




#define CheckHT(Type,Val)			\
  Type aux = (Type)ht->htFind(ToInt32(Val));	\
  if ((uint32)ToInt32(aux) != ToInt32(htEmpty))	\
    return aux;

static
TaggedRef checkTagged(TaggedRef t, HashTable *ht)
{
  CheckHT(TaggedRef,t);
  return t;
}

static
Literal *checkLiteral(Literal *l, HashTable *ht)
{
  return tagged2Literal(oz_deref(checkTagged(makeTaggedLiteral(l),ht)));
}


static
void handleLiteral(ProgramCounter PC, HashTable *ht, CodeArea *code)
{
  TaggedRef newlit = checkTagged(getTaggedArg(PC),ht);
  code->writeTagged(newlit,PC);
}



CallMethodInfo *checkGCI(CallMethodInfo *cmi, HashTable *ht)
{
  TaggedRef newname = checkTagged(cmi->mn,ht);

  // GCIs are deleted after use, so always make a copy
  // if (newname == gci->mn)
  //   return gci;

  CheckHT(CallMethodInfo *,cmi);
  
  aux = new CallMethodInfo(cmi->regIndex,newname,cmi->isTailCall,cmi->arity);
  ht->htAdd(ToInt32(cmi),aux);
  return aux;
}


static
void handleCallMethodInfo(ProgramCounter PC, HashTable *ht)
{
  CallMethodInfo *cmi = (CallMethodInfo*)getAdressArg(PC);
  CodeArea::writeAddress(checkGCI(cmi,ht),PC);
}



static
SRecordArity checkSRA(SRecordArity sra, HashTable *ht)
{
  if (sraIsTuple(sra))
    return sra;

  CheckHT(SRecordArity,sra);

  TaggedRef list = getRecordArity(sra)->getList();
  TaggedRef newlist = oz_nil();

  while(oz_isCons(list)) {
    TaggedRef newt = checkTagged(oz_head(list),ht);
    newlist = oz_cons(newt,newlist);
    list = oz_tail(list);
  }

  newlist = reverseC(newlist);
  Assert(isSorted(newlist));
  aux = mkRecordArity(aritytable.find(newlist));
  ht->htAdd(sra,ToPointer(aux));
  return aux;
}


PrTabEntry *checkPTE(PrTabEntry *pte, HashTable *ht)
{
  CheckHT(PrTabEntry *,pte);
  
  aux = new PrTabEntry(pte->getName(),checkSRA(pte->getMethodArity(),ht),
		       pte->getFile(), pte->getLine(), pte->getColumn(), 
		       pte->getFlagsList(),
		       pte->getMaxX());
  ht->htAdd(ToInt32(pte),aux);
  return aux;
}


static
void handlePredId(ProgramCounter PC, HashTable *ht)
{
  CodeArea::writeAddress(checkPTE(getPredArg(PC),ht),PC);
}


static
void handleCache(ProgramCounter PC, CodeArea *code)
{
  code->writeCache(PC);
}


/* the compiler stores AbstractionEntries as ints */

static
AbstractionEntry *checkAE(AbstractionEntry *ae, HashTable *ht)
{
  CheckHT(AbstractionEntry *,ae);
  return ae;
}


static
void handleProcedureRef(ProgramCounter PC, HashTable *ht, CodeArea *code)
{
  AbstractionEntry *ae = checkAE((AbstractionEntry*) getAdressArg(PC),ht);
  code->writeAbstractionEntry(ae,PC);
}





static
void handleRecordArity(ProgramCounter PC, HashTable *ht)
{
  SRecordArity ff = checkSRA((SRecordArity) getAdressArg(PC), ht);
  CodeArea::writeSRecordArity(ff, PC);
}


static
void handleHashTable(ProgramCounter PC, HashTable * ht) {
  IHashTable * table    = ((IHashTable *) getAdressArg(PC))->clone();
  for (int i = table->getSize(); i--; ) 
    if (table->entries[i].val && oz_isLiteral(table->entries[i].val)) {
      table->entries[i].val = 
	makeTaggedLiteral(checkLiteral(tagged2Literal(table->entries[i].val),ht));
      table->entries[i].sra = checkSRA(table->entries[i].sra,ht);
    }
  CodeArea::writeIHashTable(table, PC);
}





ProgramCounter copyCode(ProgramCounter start, TaggedRef list)
{
  HashTable *ht = new HashTable(HT_INTKEY,100);
  while(OZ_isCons(list)) {
    TaggedRef key = OZ_head(list);
    if (OZ_isForeignPointer(key)) {
      AbstractionEntry *oldentry =
	(AbstractionEntry *) OZ_getForeignPointer(key);
      Assert(oldentry->isCopyable());
      AbstractionEntry *newentry = new AbstractionEntry(NO);
      ht->htAdd(ToInt32(oldentry),newentry);
    } else {
      NamedName *theCopy =
	((NamedName *) tagged2Literal(oz_deref(key)))->generateCopy();
      ht->htAdd(ToInt32(key),ToPointer(makeTaggedLiteral(theCopy)));
    }
    list = OZ_tail(list);
  }
  Assert(OZ_isNil(list));

  int sizeOfDef = sizeOf(DEFINITION);
  start -= sizeOfDef; // copy DEFINITION instructions as well (for debugging)

  XReg reg;
  int nxt,line,colum;
  TaggedRef file,predName;
  CodeArea::getDefinitionArgs(start,reg,nxt,file,line,colum,predName);

  int size = nxt;
  ProgramCounter ret;

  CodeArea *code = new CodeArea(size);  
  ret = code->getStart();
  memcpy(ret,start,size*sizeof(ByteCode));
  
  ProgramCounter PC = ret;

  ProgramCounter ende = ret+size;

  while (PC<ende) {
    ProgramCounter lastPC = PC;
    Opcode op = CodeArea::getOpcode(PC++);

    switch(op) {

    include(EMUDIR/instrDefs.m4)

    default: Assert(0); break;
    }
    if (op == DEBUGENTRY) {
      TaggedRef file = getTaggedArg(lastPC+1);
      int line = tagged2SmallInt(getNumberArg(lastPC+2));
      CodeArea::writeDebugInfo(lastPC,file,line);
    }
  }

  delete ht;
  return ret+sizeOfDef;
}

