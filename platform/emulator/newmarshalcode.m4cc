/* -*- C++ -*-
 *  Authors:
 *    Konstantin Popov (kost@sics.se)
 *    Ralf Scheidhauer (Ralf.Scheidhauer@ps.uni-sb.de)
 *
 *  Contributors:
 *    Per Brand (perbrand@sics.se)
 *    Michael Mehl (mehl@dfki.de)
 *    Denys Duchier (duchier@ps.uni-sb.de)
 *
 *  Copyright:
 *    Organization or Person (Year(s))
 *
 *  Last change:
 *    $Date$ by $Author$
 *    $Revision$
 *
 *  This file is part of Mozart, an implementation
 *  of Oz 3:
 *     http://mozart.ps.uni-sb.de
 *
 *  See the file "LICENSE" or
 *     http://mozart.ps.uni-sb.de/LICENSE.html
 *  for information on usage and redistribution
 *  of this file, and for a DISCLAIMER OF ALL
 *  WARRANTIES.
 *
 */

changequote([[,]])

#include "am.hh"

define(readArg,$1)
define(writeArg,$1)
define(instruction,
        [[ifelse(numOfRegs($2,$3,$4),1,
                    case TOUPPER($1)X:
                    case TOUPPER($1)Y:
                    case TOUPPER($1)G:,
         numOfRegs($2,$3,$4),2,
            case TOUPPER($1)XX:
            case TOUPPER($1)XY:
            case TOUPPER($1)XG:
            case TOUPPER($1)YX:
            case TOUPPER($1)YY:
            case TOUPPER($1)YG:
            case TOUPPER($1)GX:
            case TOUPPER($1)GY:
            case TOUPPER($1)GG:,
         case TOUPPER($1):)
           opAction($2)
           opAction($3)
           opAction($4)
           opAction($5)
           opAction($6)
           opAction($7)
           opAction($8)
           opAction($9)
          break;]])

define(opAction,
[[ifelse($1,Number,m->marshalOzValue(getTaggedArg(PC++));ozValuesCnt--;,
        $1,Literal,m->marshalOzValue(getTaggedArg(PC++));ozValuesCnt--;,
        $1,Feature,m->marshalOzValue(getTaggedArg(PC++));ozValuesCnt--;,
        $1,Constant,m->marshalOzValue(getTaggedArg(PC++));ozValuesCnt--;,
        $1,Builtinname,marshalBuiltin(m,(Builtin*)getAdressArg(PC++));ozValuesCnt--;,
        $1,Register,marshalNumber(regToInt(getRegArg(PC++)),bs);,
        $1,XRegisterIndex,marshalNumber(regToInt(getRegArg(PC++)),bs);,
        $1,YRegisterIndex,marshalNumber(regToInt(getRegArg(PC++)),bs);,
        $1,GRegisterIndex,marshalNumber(regToInt(getRegArg(PC++)),bs);,
        $1,Arity,marshalNumber((unsigned int)getPosIntArg(PC++),bs);,
        $1,Label,marshalLabel(instrstart-start,getLabelArg(PC++),bs);,
        $1,Count,marshalNumber((unsigned int)getPosIntArg(PC++),bs);,
        $1,ArityAndIsTail,marshalNumber((unsigned int)getPosIntArg(PC++),bs);,
        $1,Dummy,marshalNumber((unsigned int)getPosIntArg(PC++),bs);,
        $1,PredicateRef,marshalPredicateRef(m,(AbstractionEntry*)getAdressArg(PC++),bs);,
        $1,PredId,marshalPredId(m,(PrTabEntry*)getAdressArg(PC++),bs);ozValuesCnt--;,
        $1,HashTableRef,marshalHashTableRef(m,instrstart-start,(IHashTable *)getAdressArg(PC++),bs);ozValuesCnt--;,
        $1,RecordArity,marshalRecordArity(m,(SRecordArity) getAdressArg(PC++),bs);ozValuesCnt--;,
        $1,GenCallInfo,marshalGenCallInfo(m,(GenCallInfoClass*)getAdressArg(PC++),bs);ozValuesCnt--;,
        $1,GRegRef,marshalGRegRef((AssRegArray*)getAdressArg(PC++),bs);,
        $1,Location,marshalLocation((OZ_Location*)getAdressArg(PC++),bs);,
        $1,Cache,PC += CacheSize;)]])

//
inline static
void marshalBuiltin(Marshaler *m, Builtin *entry)
{
  m->marshalOzValue(makeTaggedConst(entry));
}

//
inline static
void marshalPredicateRef(Marshaler *m,
                         AbstractionEntry *entry, MsgBuffer *bs)
{
  Bool copyable = entry && entry->copyable;
  marshalNumber(copyable, bs);
  if (copyable) {
    int ind = m->find(entry);
    if (ind >= 0) {
      (void) m->processRepetition(ind);
    } else {
      marshalDIF(bs, DIF_ABSTRENTRY);
      m->rememberNode(entry, bs);
    }
  } else {
    Assert(entry==NULL || entry->getAbstr() != NULL);
  }
}

//
// NOTE: this code cannot be changed without changing
// marshaling/unmarshaling of pred id"s, hash table refs, gen call
// info"s and app meth info"s !!! Sorry, i (kost@) don't know how to
// express an appropriate assertion... may be the be way is just not
// to use this procedure for marshaling structures named above;
inline static
void marshalRecordArity(Marshaler *m, SRecordArity sra, MsgBuffer *bs)
{
  if (sraIsTuple(sra)) {
    marshalRecordArityType(TUPLEWIDTH, bs);
    marshalNumber(getTupleWidth(sra),bs);
  } else {
    marshalRecordArityType(RECORDARITY,bs);
    m->marshalOzValue(getRecordArity(sra)->getList());
  }
}

//
inline static
void marshalPredId(Marshaler *m, PrTabEntry *p, MsgBuffer *bs)
{
  m->marshalOzValue(p->getName());
  marshalRecordArity(m, p->getMethodArity(), bs);
  m->marshalOzValue(p->getFile());
  marshalNumber(p->getLine(), bs);
  marshalNumber(p->getColumn(), bs);
  m->marshalOzValue(p->getFlagsList());
  marshalNumber(p->getMaxX(), bs);
}

//
inline static
void marshalGenCallInfo(Marshaler *m, GenCallInfoClass *gci, MsgBuffer *bs)
{
  int compact =
    (gci->regIndex<<2) | (gci->isMethAppl<<1) | (gci->isTailCall);
  marshalNumber(compact, bs);
  m->marshalOzValue(gci->mn);
  marshalRecordArity(m, gci->arity, bs);
}

//
inline static
void marshalGRegRef(AssRegArray *gregs, MsgBuffer *bs)
{
  int nGRegs = gregs->getSize();
  marshalNumber(nGRegs,bs);

  for (int i = 0; i < nGRegs; i++) {
    int out = ((*gregs)[i].number<<2) | (int)(*gregs)[i].kind;
    marshalNumber(out,bs);
  }
}

//
inline static
void marshalLocation(OZ_Location *loc,MsgBuffer *bs)
{
  int inAr = loc->getInArity();
  int outAr = loc->getOutArity();
  marshalNumber(inAr,bs);
  marshalNumber(outAr,bs);

  for (int i = 0; i < inAr+outAr; i++) {
    int out = loc->get(i);
    marshalNumber(out,bs);
  }
}

//
inline static
ProgramCounter writeAddress(void *ptr, ProgramCounter pc)
{
  return (pc ? CodeArea::writeAddress(ptr, pc) : (ProgramCounter) 0);
}

enum { ATOMTAG, NUMBERTAG, RECORDTAG};

//
// The hash table is considered to be compound: its subtrees are table
// nodes;
static
void marshalHashTableRef(Marshaler *m, int start, IHashTable *table,
                         MsgBuffer *bs)
{
  int sz = table->size;
  marshalNumber(sz, bs);
  marshalLabel(start, table->elseLabel, bs);
  marshalLabel(start, table->listLabel, bs);
  int entries = table->numentries;
  // total number of entries (and, thus, of 'ht_???_entry' tasks);
  marshalNumber(entries, bs);

  //
  if (table->literalTable) {
    for(int i = 0; i < sz; i++) {
      HTEntry *aux = table->literalTable[i];
      while(aux) {
        entries--;
        marshalNumber(ATOMTAG, bs);
        marshalLabel(start, aux->getLabel(), bs);
        m->marshalOzValue(makeTaggedLiteral(aux->getLiteral()));
        aux = aux->getNext();
      }
    }
  }

  //
  if (table->numberTable) {
    for(int i = 0; i < sz; i++) {
      HTEntry *aux = table->numberTable[i];
      while(aux) {
        entries--;
        marshalNumber(NUMBERTAG, bs);
        marshalLabel(start, aux->getLabel(), bs);
        m->marshalOzValue(aux->getNumber());
        aux = aux->getNext();
      }
    }
  }

  //
  if (table->functorTable) {
    for(int i=0; i<sz; i++) {
      HTEntry *aux = table->functorTable[i];
      while(aux) {
        entries--;
        marshalNumber(RECORDTAG,bs);
        marshalLabel(start,aux->getLabel(),bs);
        SRecordArity sra;
        Literal *label = aux->getFunctor(sra);
        m->marshalOzValue(makeTaggedLiteral(label));
        marshalRecordArity(m, sra, bs);
        aux = aux->getNext();
      }
    }
  }
}

//
//
Bool newMarshalCode(GenTraverser *gt, void *arg)
{
  // We know this can be only marshaler because only marshaler
  // can feed this function into the generic traverser;
  Marshaler *m = (Marshaler *) gt;
  MarshalerCodeAreaDescriptor *desc = (MarshalerCodeAreaDescriptor *) arg;
  // ('bs' could be also saved in the argument;)
  MsgBuffer *bs = (MsgBuffer *) m->getOpaque();
  ProgramCounter start = desc->getStart(), end = desc->getEnd();
  ProgramCounter PC = desc->getCurrent();
  // when 'ozValuesCnt' hits zero, then the code area must be broken
  // in two pieces (before a next instructioN):
  int ozValuesCnt = ozValuesBA;

  //
  if (PC == start) newMarshalCodeStart(bs);
  marshalDIF(bs, DIF_CODEAREA);

  //
  while (ozValuesCnt > 0 && PC < end) {
    ProgramCounter instrstart = PC;
    Opcode op = CodeArea::getOpcode(PC++);

    //
    if (op==GENFASTCALL) {
      op = (getNumberArg(PC+1) & 1)==0 ? FASTCALL : FASTTAILCALL;
    }

    //
    // (RS?) fastcalls need special handling
    // kost@ : ... that is, one cannot put internal pointers into the
    // stream; thus, these instructioNs get replaced by some other
    // instructioNs.
    if (op==FASTCALL || op==FASTTAILCALL) {
      AbstractionEntry *entry = (AbstractionEntry *) getAdressArg(PC);
      if (!entry->copyable) {
        marshalOpCode(instrstart-start,MARSHALLEDFASTCALL,bs);
        Abstraction *abstr = entry->getAbstr();

        //
        m->marshalOzValue(makeTaggedConst(abstr));
        ozValuesCnt--;

        //
        Bool istailcall = (op==FASTTAILCALL);
        marshalNumber((entry->getArity()<<1)|istailcall,bs);
        PC++; // skip (AbstractionEntry *)
        PC++; // skip unused second arg
        continue;
      }
    }

    //
    marshalOpCode(instrstart-start,op,bs);
    switch(op) {

      changequote(`,') dnl '
      include(EMUDIR/instrDefs.m4)
      changequote([[,]])

    // don't indent the next line:
    default: Assert(0); break;
    }
  }

  // (don't indent the next line:)
  if (PC >= end) {
    marshalOpCode(PC-start, ENDOFFILE, bs);
    newMarshalCodeEnd(bs);
    //
    delete desc;
    return (TRUE);
  } else {
    desc->setCurrent(PC);
    return (FALSE);
  }
}


//
undefine([[opAction]])
undefine([[marshaling]])

define(opAction,
[[ifelse($1,Number,PC=unmarshalOzValue(b,PC,code);ozValuesCnt--;,
        $1,Literal,PC=unmarshalOzValue(b,PC,code);ozValuesCnt--;,
        $1,Feature,PC=unmarshalOzValue(b,PC,code);ozValuesCnt--;,
        $1,Constant,PC=unmarshalOzValue(b,PC,code);ozValuesCnt--;,
        $1,Builtinname,PC=unmarshalBuiltin(b,PC);ozValuesCnt--;,
        $1,Register,PC=unmarshalReg(PC,bs);,
        $1,XRegisterIndex,PC=unmarshalReg(PC,bs);,
        $1,YRegisterIndex,PC=unmarshalReg(PC,bs);,
        $1,GRegisterIndex,PC=unmarshalReg(PC,bs);,
        $1,Arity,PC=unmarshalNum(PC,bs);,
        $1,Label,PC=unmarshalLabel(PC,bs);,
        $1,Count,PC=unmarshalNum(PC,bs);,
        $1,ArityAndIsTail,PC=unmarshalNum(PC,bs);,
        $1,Dummy,PC=unmarshalNum(PC,bs);,
        $1,PredicateRef,PC=unmarshalPredicateRef(b,PC,bs,code);,
        $1,PredId,PC=unmarshalPredId(b,PC,lastPC,bs);ozValuesCnt--;,
        $1,HashTableRef,PC=unmarshalHashTableRef(b,PC,bs);ozValuesCnt--;,
        $1,RecordArity,PC=unmarshalRecordArity(b,PC,bs);ozValuesCnt--;,
        $1,GenCallInfo,PC=unmarshalGenCallInfo(b,PC,bs);ozValuesCnt--;,
        $1,GRegRef,PC=unmarshalGRegRef(PC,bs);,
        $1,Location,PC=unmarshalLocation(PC,bs);,
        $1,Cache,PC=unmarshalCache(PC,code);)]])

//
// Occasionally Oz terms must be placed in the current binary area
// (which representation will follow in the stream): this is arranged
// with 'putOzValueCA' processor. Note that writing into a code area
// is that code area's business;
class CodeAreaLocation : public NMMemoryManager {
private:
  ProgramCounter ptr;
  CodeArea *code;
public:
  CodeAreaLocation(ProgramCounter ptrIn, CodeArea* codeIn)
    : ptr(ptrIn), code(codeIn) {}
  CodeAreaLocation(ProgramCounter ptrIn)
    : ptr(ptrIn) { DebugCode(code = (CodeArea *) -1;); }
  //
  ProgramCounter getPtr() { return (ptr); }
  CodeArea *getCodeArea() { return (code); }
};
//
static void putOzValueCA(void *arg, OZ_Term value) {
  CodeAreaLocation *loc = (CodeAreaLocation *) arg;
  //
  (void) (loc->getCodeArea())->writeTagged(value, loc->getPtr());
  delete arg;
}

//
inline static
ProgramCounter unmarshalOzValue(Builder *b, ProgramCounter pc, CodeArea *code)
{
  ProgramCounter retPC;
  if (pc) {
    CodeAreaLocation *loc = new CodeAreaLocation(pc, code);
    b->getOzValue(putOzValueCA, loc);
    retPC = CodeArea::allocateWord(pc);
  } else {
    b->discardOzValueCA();
    retPC = 0;
  }
  return (retPC);
}

//
inline static
ProgramCounter unmarshalNum(ProgramCounter pc, MsgBuffer *bs)
{
  int num = unmarshalNumber(bs);
  return (pc ? CodeArea::writeInt(num,pc) : (ProgramCounter) 0);
}

//
inline static
ProgramCounter unmarshalReg(ProgramCounter pc, MsgBuffer *bs)
{
  int idx = unmarshalNumber(bs);
  return (pc ? CodeArea::writeRegIndex(idx, pc) : (ProgramCounter) 0);
}

//
// A builtin in a code area is stored not as an 'OzTerm' but as an
// Builtin* (while in the stream it appears as an 'OzTerm'):
static void putBuiltinCA(void *arg, OZ_Term value) {
  CodeAreaLocation *loc = (CodeAreaLocation *) arg;
  //
  Assert(oz_isBuiltin(value));
  CodeArea::writeAddressAllocated(tagged2Builtin(value), loc->getPtr());
  delete arg;
}
//
inline static
ProgramCounter unmarshalBuiltin(Builder *b, ProgramCounter pc)
{
  if (pc) {
    CodeAreaLocation *loc = new CodeAreaLocation(pc);
    b->getOzValue(putBuiltinCA, loc);
    return (CodeArea::allocateWord(pc));
  } else {
    b->discardOzValueCA();
    return ((ProgramCounter) 0);
  }
}

//
inline static
ProgramCounter unmarshalLabel(ProgramCounter PC, MsgBuffer *bs)
{
  int offset = unmarshalNumber(bs);
  return (PC ? CodeArea::writeLabel(offset,0,PC) : (ProgramCounter) 0);
}

//
inline static
ProgramCounter unmarshalCache(ProgramCounter PC, CodeArea *code)
{
  return PC ? code->writeCache(PC) : 0;
}

//
static
ProgramCounter unmarshalGRegRef(ProgramCounter PC,MsgBuffer *bs)
{
  int nGRegs = unmarshalNumber(bs);
  AssRegArray *gregs = PC ? new AssRegArray(nGRegs) : 0;

  for (int i = 0; i < nGRegs; i++) {
    unsigned int reg = unmarshalNumber(bs);
    if (PC) {
      (*gregs)[i].number = reg>>2;
      (*gregs)[i].kind = (KindOfReg) (reg&3);
    }
  }

  return (writeAddress(gregs, PC));
}

//
static
ProgramCounter unmarshalLocation(ProgramCounter PC,MsgBuffer *bs)
{
  int inAr = unmarshalNumber(bs);
  int outAr = unmarshalNumber(bs);
  OZ_Location *loc = OZ_Location::newLocation(inAr,outAr);

  for (int i = 0; i < inAr+outAr; i++) {
    int n = unmarshalNumber(bs);
    loc->set(i,n);
  }

  return (writeAddress(loc, PC));
}

//
// Gets a *complete* arity list (thus, must be used with 'Builder::
// getCompleteOzValue()') and puts 'SRecordArity';
static void putRealRecordArityCA(void *arg, OZ_Term value) {
  CodeAreaLocation *loc = (CodeAreaLocation *) arg;

  //
  Assert(isSorted(value));
  SRecordArity sra = makeRealRecordArity(value);
  CodeArea::writeWordAllocated(sra, loc->getPtr());
  delete arg;
}

//
// 'unmarshalRecordArity' exists in two flavors: one fills a cell in a
// code area with an 'SRecordArity' value (resp. discards it in "skip"
// mode), while another one just fills up a given cell;
static
ProgramCounter unmarshalRecordArity(Builder *b,
                                    ProgramCounter pc, MsgBuffer *bs)
{
  RecordArityType at = unmarshalRecordArityType(bs);
  if (pc) {
    if (at == RECORDARITY) {
      CodeAreaLocation *loc = new CodeAreaLocation(pc);
      b->getCompleteOzValue(putRealRecordArityCA, loc);
      return (CodeArea::allocateWord(pc));
    } else {
      Assert(at == TUPLEWIDTH);
      int width = unmarshalNumber(bs);
      return (CodeArea::writeInt(mkTupleWidth(width), pc));
    }
  } else {
    if (at == RECORDARITY)
      b->discardOzValueCA();
    else
      skipNumber(bs);
    return ((ProgramCounter) 0);
  }
}

//
// A "CodeAreaLocation" argument ist not sufficient for more
// interesting cases, in which more than one Oz value is used to fill
// up a cell in a code area.
//
// For predicate id"s these are a predicate's name, *optional* record
// arity list, file name and flags list. Given the reversed order they
// appear in stream, the last three must be saved until the
// 'PrTabEntry' be really constructed.
class PredIdLocation : public CodeAreaLocation {
private:
  int line, column, maxX;
  // 'name' will be supplied last and does not need to be stored;
  SRecordArity sra;             // of a tuple
  OZ_Term arityList;            // of a record;
  OZ_Term file;
  OZ_Term flagsList;
public:
  PredIdLocation(ProgramCounter ptrIn)
    : CodeAreaLocation(ptrIn), sra((SRecordArity) 0)
  {
    DebugCode(line = column = maxX = -1;);
    DebugCode(file = flagsList = arityList = (OZ_Term) -1;);
  }

  //
  void setSRA(SRecordArity sraIn) { sra = sraIn; }
  SRecordArity getSRA() { return (sra); }
  void setArityList(OZ_Term ra) { arityList = ra; }
  OZ_Term getArityList() { return (arityList); }
  void setFile(OZ_Term fileIn) { file = fileIn; }
  OZ_Term getFile() { return (file); }
  void setFlagsList(OZ_Term flagsListIn ) { flagsList = flagsListIn; }
  OZ_Term getFlagsList() { return (flagsList); }

  //
  void setLine(int lineIn) { line = lineIn; }
  int getLine() { return (line); }
  void setColumn(int columnIn) { column = columnIn; }
  int getColumn() { return (column); }
  void setMaxX(int maxXIn) { maxX = maxXIn; }
  int getMaxX() { return (maxX); }
};

//
// Thus, there are four processors, out of which three saves values
// and the last one does the job:
static void getPredIdNameCA(void *arg, OZ_Term value) {
  PredIdLocation *loc = (PredIdLocation *) arg;
  SRecordArity sra = loc->getSRA();

  //
  if (!sra) {
    // must be a record:
    sra = makeRealRecordArity(loc->getArityList());
  }

  //
  // 'value' is the name argument;
  PrTabEntry *pred = new
    PrTabEntry(value,
               sra, loc->getFile(),
               loc->getLine(), loc->getColumn(),
               loc->getFlagsList(), loc->getMaxX());
  CodeArea::writeAddressAllocated(pred, loc->getPtr());
  //
  delete arg;
}

//
// Note that these processors do not delete the argument;
// Note also that 'saveSRACA' is used only when the arity is of a real
// record (i.e. not a tuple);
static void saveRecordArityPredIdCA(void *arg, OZ_Term value)
{
  PredIdLocation *loc = (PredIdLocation *) arg;
  // 'value' *will be* an arity list - now we have only head cell;
  loc->setArityList(value);
}
static void saveFileCA(void *arg, OZ_Term value)
{
  PredIdLocation *loc = (PredIdLocation *) arg;
  loc->setFile(value);
}
static void saveFlagsListCA(void *arg, OZ_Term value)
{
  PredIdLocation *loc = (PredIdLocation *) arg;
  loc->setFlagsList(value);
}

//
// (of course, this code must resemble 'marshalPredId()')
static
ProgramCounter unmarshalPredId(Builder *b, ProgramCounter pc,
                               ProgramCounter lastPC, MsgBuffer *bs)
{
  if (pc) {
    PredIdLocation *loc = new PredIdLocation(pc);

    //
    b->getOzValue(getPredIdNameCA, loc);
    //
    RecordArityType at = unmarshalRecordArityType(bs);
    if (at == RECORDARITY) {
      b->getOzValue(saveRecordArityPredIdCA, loc);
    } else {
      Assert(at == TUPLEWIDTH);
      int width = unmarshalNumber(bs);
      // set 'SRecordArity' directly (and there will be no arity
      // list);
      loc->setSRA(mkTupleWidth(width));
    }
    //
    b->getOzValue(saveFileCA, loc);
    //
    loc->setLine(unmarshalNumber(bs));
    loc->setColumn(unmarshalNumber(bs));
    //
    b->getOzValue(saveFlagsListCA, loc);
    //
    loc->setMaxX(unmarshalNumber(bs));

    //
    return (CodeArea::allocateWord(pc));

  } else {
    //
    b->discardOzValueCA();      // name;
    //
    RecordArityType at = unmarshalRecordArityType(bs);
    if (at == RECORDARITY) {
      b->discardOzValueCA();    // arity list;
    } else {
      Assert(at == TUPLEWIDTH);
      skipNumber(bs);
    }
    //
    b->discardOzValueCA();      // file;
    //
    skipNumber(bs);             // line & column;
    skipNumber(bs);
    //
    b->discardOzValueCA();      // flags list;
    //
    skipNumber(bs);             // maxX;

    //
    return ((ProgramCounter) 0);
  }
}

//
//
class GenCallInfoLocation : public CodeAreaLocation {
private:
  int compact;
  SRecordArity sra;             // tuples;
  OZ_Term arityList;            // records;

  //
public:
  GenCallInfoLocation(ProgramCounter ptrIn, int compactIn)
    : CodeAreaLocation(ptrIn), compact(compactIn), sra((SRecordArity) 0)
  {
    DebugCode(arityList = (OZ_Term) -1;);
  }

  //
  int getCompact() { return (compact); }
  SRecordArity getSRA() { return (sra); }
  void setSRA(SRecordArity sraIn) { sra = sraIn; }
  OZ_Term getArityList() { return (arityList); }
  void setArityList(OZ_Term ar) { arityList = ar; }
};

//
static void getGenCallInfoNameCA(void *arg, OZ_Term value) {
  GenCallInfoLocation *loc = (GenCallInfoLocation *) arg;
  int compact = loc->getCompact();
  SRecordArity sra = loc->getSRA();

  //
  if (!sra) {
    // must be a record:
    sra = makeRealRecordArity(loc->getArityList());
  }

  //
  int ri      = compact>>2;
  Bool ism    = (compact>>1)&1;
  Bool ist    = (compact&1);
  GenCallInfoClass *gci = new GenCallInfoClass(ri, ism, value, ist, sra);
  CodeArea::writeAddressAllocated(gci, loc->getPtr());

  //
  delete loc;
}

//
static void saveGenCallInfoRecordArityCA(void *arg, OZ_Term value)
{
  GenCallInfoLocation *loc = (GenCallInfoLocation *) arg;
  loc->setArityList(value);
}

//
static
ProgramCounter unmarshalGenCallInfo(Builder *b,
                                    ProgramCounter pc, MsgBuffer *bs)
{
  int compact = unmarshalNumber(bs);

  //
  if (pc) {
    GenCallInfoLocation *loc = new GenCallInfoLocation(pc, compact);

    //
    b->getOzValue(getGenCallInfoNameCA, loc);
    //
    RecordArityType at = unmarshalRecordArityType(bs);
    if (at == RECORDARITY) {
      b->getOzValue(saveGenCallInfoRecordArityCA, loc);
    } else {
      Assert(at == TUPLEWIDTH);
      int width = unmarshalNumber(bs);
      loc->setSRA(mkTupleWidth(width));
    }

    //
    return (CodeArea::allocateWord(pc));
  } else {
    b->discardOzValueCA();      // name;
    //
    RecordArityType at = unmarshalRecordArityType(bs);
    if (at == RECORDARITY)
      b->discardOzValueCA();
    else
      skipNumber(bs);

    //
    return ((ProgramCounter) 0);
  }
}

//
// Hash table entries are constructed using the table itself, label,
// and either an Oz value or an Oz value and SRecordArity. Thus, a
// descriptor of an entry used for the 'Builder::getOzValue()' task
// keeps table, label and may be a record arity list.
class HashTableEntryDesc : public NMMemoryManager {
private:
  IHashTable *table;
  int label;
  SRecordArity sra;             // for "tuple" record entries only;
  OZ_Term arityList;            // for "proper" record entries only;
public:
  HashTableEntryDesc(IHashTable *tableIn, int labelIn)
    : table(tableIn), label(labelIn), sra((SRecordArity) 0)
  {
    DebugCode(arityList = (OZ_Term) -1;);
  }

  //
  IHashTable* getTable() { return (table); }
  int getLabel() { return (label); }
  SRecordArity getSRA() { return (sra); }
  void setSRA(SRecordArity sraIn) { sra = sraIn; }
  void setArityList(OZ_Term ra) { arityList = ra; }
  OZ_Term getArityList() { return (arityList); }
};

//
// Processors...
static void getHashTableRecordEntryLabelCA(void *arg, OZ_Term value) {
  HashTableEntryDesc *desc = (HashTableEntryDesc *) arg;
  SRecordArity sra = desc->getSRA();

  //
  if (!sra) {
    OZ_Term recordArity = desc->getArityList();
    Assert(isSorted(recordArity));
    sra = makeRealRecordArity(recordArity);
  }
  //
  (desc->getTable())->add(tagged2Literal(value), sra, desc->getLabel());

  //
  delete arg;
}
//
static void saveRecordArityHashTableEntryCA(void *arg, OZ_Term value) {
  HashTableEntryDesc *desc = (HashTableEntryDesc *) arg;
  desc->setArityList(value);
}

//
static void getHashTableAtomEntryLabelCA(void *arg, OZ_Term value) {
  HashTableEntryDesc *desc = (HashTableEntryDesc *) arg;

  //
  (desc->getTable())->add(tagged2Literal(value), desc->getLabel());
  delete arg;
}

//
static void getHashTableNumEntryLabelCA(void *arg, OZ_Term value) {
  HashTableEntryDesc *desc = (HashTableEntryDesc *) arg;

  //
  (desc->getTable())->add(value, desc->getLabel());
  delete arg;
}


//
static
ProgramCounter unmarshalHashTableRef(Builder *b, ProgramCounter pc,
                                     MsgBuffer *bs)
{
  //
  if (pc) {
    int sz = unmarshalNumber(bs);
    int elseLabel = unmarshalNumber(bs); /* the else label */
    int listLabel = unmarshalNumber(bs);
    int nEntries = unmarshalNumber(bs);
    IHashTable *table;

    //
    table = new IHashTable(sz, elseLabel);
    if (listLabel)
      table->addList(listLabel);

    //
    for (int i = 0; i < nEntries; i++) {
      int termTag = unmarshalNumber(bs);
      int label = unmarshalNumber(bs);
      HashTableEntryDesc *desc = new HashTableEntryDesc(table, label);

      //
      switch (termTag) {
      case RECORDTAG:
        {
          b->getOzValue(getHashTableRecordEntryLabelCA, desc);
          //
          RecordArityType at = unmarshalRecordArityType(bs);
          if (at == RECORDARITY) {
            b->getOzValue(saveRecordArityHashTableEntryCA, desc);
          } else {
            Assert(at == TUPLEWIDTH);
            int width = unmarshalNumber(bs);
            desc->setSRA(mkTupleWidth(width));
          }
          break;
        }

      case ATOMTAG:
        b->getOzValue(getHashTableAtomEntryLabelCA, desc);
        break;

      case NUMBERTAG:
        b->getOzValue(getHashTableNumEntryLabelCA, desc);
        break;

      default: Assert(0); break;
      }
    }

    //
    // The hash table is stored already, albeit it is not yet filled
    // up;
    return (CodeArea::writeIHashTable(table, pc));
  } else {
    skipNumber(bs);             // size
    skipNumber(bs);             // elseLabel
    skipNumber(bs);             // listLabel
    int nEntries = unmarshalNumber(bs);

    //
    for (int i = 0; i < nEntries; i++) {
      int termTag = unmarshalNumber(bs);
      skipNumber(bs);           // label

      //
      switch (termTag) {
      case RECORDTAG:
        {
          b->discardOzValueCA();
          //
          RecordArityType at = unmarshalRecordArityType(bs);
          if (at == RECORDARITY)
            b->discardOzValueCA();
          else
            skipNumber(bs);
          break;
        }

      case ATOMTAG:
        b->discardOzValueCA();
        break;

      case NUMBERTAG:
        b->discardOzValueCA();
        break;

      default: Assert(0); break;
      }
    }

    //
    return ((ProgramCounter) 0);
  }
}

//
static
ProgramCounter unmarshalPredicateRef(Builder *b, ProgramCounter pc,
                                     MsgBuffer *bs, CodeArea *code)
{
  AbstractionEntry *entry = 0;
  Bool copyable = unmarshalNumber(bs);
  if (copyable) {
    MarshalTag tag = (MarshalTag) bs->get();
    if (tag == DIF_REF) {
      int i = unmarshalNumber(bs);
      entry = (AbstractionEntry*) ToPointer(b->get(i));
    } else {
      Assert(tag == DIF_ABSTRENTRY);
      int refTag = unmarshalRefTag(bs);
      entry = new AbstractionEntry(OK);
      b->set(ToInt32(entry),refTag);
    }
  }
  return (pc ? code->writeAbstractionEntry(entry,pc) : (ProgramCounter) pc);
}


//
// Returning 'OK' means we are done (with the code area);
// 'pc' can be zero meaning "discard the code". If it is non-zero,
// then it is supposed to be large enough to hold the whole code;
Bool unmarshalCode(MsgBuffer *bs, Builder *b,
                   BuilderCodeAreaDescriptor *desc)
{
  int ozValuesCnt = ozValuesBA;
  ProgramCounter PC = desc->getCurrent();
  ProgramCounter lastPC;
  // 'CodeArea*' is passed in it itself:
  CodeArea *code = desc->getCodeArea();
  Bool done = NO;

  //
  while (ozValuesCnt > 0) {
    lastPC = PC;
    Opcode op = (Opcode) bs->get();
    if (op == ENDOFFILE) {
      done = OK;
      break;
    }

    //
    Assert(op != GENFASTCALL);
    if (PC)
      PC = CodeArea::writeOpcode(op,PC);

    //
    switch(op) {

      changequote(`,') dnl '
      include(EMUDIR/instrDefs.m4)
      changequote([[,]])

    default: Assert(0); break;
    }

    if (op == DEBUGENTRY && PC) {
      TaggedRef file = getTaggedArg(lastPC+1);
      int line = smallIntValue(getNumberArg(lastPC+2));
      CodeArea::writeDebugInfo(lastPC,file,line);
    }
  }

  //
  if (done)
    delete desc;
  else
    desc->setCurrent(PC);
  return (done);
}
