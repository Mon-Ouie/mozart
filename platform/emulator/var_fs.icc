/*
 *  Authors:
 *    Tobias Mueller (tmueller@ps.uni-sb.de)
 *
 *  Contributors:
 *    optional, Contributor's name (Contributor's email address)
 *
 *  Copyright:
 *    Organization or Person (Year(s))
 *
 *  Last change:
 *    $Date$ by $Author$
 *    $Revision$
 *
 *  This file is part of Mozart, an implementation
 *  of Oz 3:
 *     http://www.mozart-oz.org
 *
 *  See the file "LICENSE" or
 *     http://www.mozart-oz.org/LICENSE.html
 *  for information on usage and redistribution
 *  of this file, and for a DISCLAIMER OF ALL
 *  WARRANTIES.
 *
 */

#ifndef __fsgenvar_icc__
#define __fsgenvar_icc__

#if defined(INTERFACE) && !defined(OUTLINE)
#pragma interface
#endif

#include "unify.hh"

//-----------------------------------------------------------------------------

inline
OzFSVariable * tagged2GenFSetVar(OZ_Term term)
{
  GCDEBUG(term);
  return (OzFSVariable *) tagged2CVar(term);
}

inline
Bool isGenFSetVar(TaggedRef term)
{
  GCDEBUG(term);
  return isCVar(term) && (tagged2CVar(term)->getType() == OZ_VAR_FS);
}

inline
Bool isGenFSetVar(TaggedRef term, TypeOfTerm tag)
{
  GCDEBUG(term);
  Assert(tag == tagTypeOf(term));
  return isCVar(tag) && (tagged2CVar(term)->getType() == OZ_VAR_FS);
}

inline
OZ_FSetConstraint * unpatchReifiedFSet(OZ_Term t)
{
  Assert(!isUVar(t) && oz_isVariable(t) && !oz_isRef(t));
  OzFSVariable * fsv = ((OzFSVariable *) tagValueOf(t));;

  fsv->unpatchReified();
  return fsv->getReifiedPatch();
}


inline
void OzFSVariable::becomesFSetValueAndPropagate(TaggedRef * trPtr)
{
  Assert(!oz_isFSetValue(*trPtr));
  if (oz_isFSetValue(*trPtr)) return;

  Assert(this == tagged2SVarPlus(*trPtr));

  OZ_Term set_val = makeTaggedFSetValue(new OZ_FSetValue(_fset));

  propagate(fs_prop_val);
  DoBind(trPtr, set_val);
  dispose();
}

inline
void OzFSVariable::installPropagators(OzFSVariable * glob_var)
{
  installPropagatorsG(glob_var);
  Board * gb = glob_var->getBoardInternal();
  for (int i = 0; i < fs_prop_any; i += 1)
    fsSuspList[i] = oz_installPropagators(fsSuspList[i],
                                          glob_var->fsSuspList[i],
                                          gb);
}

inline
void OzFSVariable::relinkSuspListTo(OzFSVariable * lv, Bool reset_local)
{
  OzVariable::relinkSuspListTo(lv, reset_local); // any

  // Ensure locality invariant!

  if (reset_local) {
    for (int i = 0; i < fs_prop_any; i += 1)
      fsSuspList[i] =
        fsSuspList[i]->appendToAndUnlink(lv->suspList, reset_local);
  } else {
    for (int i = 0; i < fs_prop_any; i += 1)
      fsSuspList[i] =
        fsSuspList[i]->appendToAndUnlink(lv->fsSuspList[i], reset_local);
  }
}

inline
void addSuspFSetVar(OZ_Term v, Suspendable * susp, OZ_FSetPropState list_index)
{

  OzFSVariable * fsv = tagged2GenFSetVar(v);

  Assert(list_index == fs_prop_any ||
         fsv->getBoardInternal()->derefBoard() ==
         susp->getBoardInternal()->derefBoard());

  switch (list_index) {
  case fs_prop_val:
    Assert(susp->isPropagator());
    AddSuspToListLocal(fsv->fsSuspList[fs_prop_val], susp);
    break;
  case fs_prop_bounds:
    Assert(susp->isPropagator());
    AddSuspToListLocal(fsv->fsSuspList[fs_prop_glb], susp);
    AddSuspToListLocal(fsv->fsSuspList[fs_prop_lub], susp);
    break;
  case fs_prop_glb:
    Assert(susp->isPropagator());
    AddSuspToListLocal(fsv->fsSuspList[fs_prop_glb], susp);
    break;
  case fs_prop_lub:
    Assert(susp->isPropagator());
    AddSuspToListLocal(fsv->fsSuspList[fs_prop_lub], susp);
    break;
  case fs_prop_any:
    AddSuspToList(fsv->suspList, susp, fsv->getHome1());
    break;
  default:
    Assert(0);
    break;
  }
}

#endif /* __fsgenvar_icc__ */

// end of file
//-----------------------------------------------------------------------------
