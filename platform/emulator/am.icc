/*
  Hydra Project, DFKI Saarbruecken,
  Stuhlsatzenhausweg 3, D-66123 Saarbruecken, Phone (+49) 681 302-5312
  Author: popow, mehl

  ------------------------------------------------------------------------
*/

#ifndef __AM_ICC
#define __AM_ICC

#if !defined(OUTLINE) && defined(INTERFACE)
#pragma interface
#endif

// optimize: inline ....

inline
void AM::bindToNonvar(TaggedRef *varPtr, TaggedRef var,
                      TaggedRef a, ByteCode *scp)
{
  // most probable case first: local UVar
  // if (isUVar(var) && currentBoard == tagged2VarHome(var)) {
  // more efficient:
  if (currentUVarPrototypeEq(var) && scp==0) {
    doBind(varPtr,a);
  } else {
    genericBind(varPtr,var,NULL,a);
  }
}


/* specially optimized unify: test two most probable cases first:
 *
 *     1. bind a variable
 *     2. test two non-variables
 *     3. but don't forget to check identical variables
 */

inline
Bool AM::fastUnify(TaggedRef A, TaggedRef B, ByteCode *scp)
{
  TaggedRef term1 = A;
  DEREF0(term1,term1Ptr,_1);

  TaggedRef term2 = B;
  DEREF0(term2,term2Ptr,_2);

  if (!isAnyVar(term2)) {
    if (currentUVarPrototypeEq(term1) && scp==0) {
      COUNT(varNonvarUnify);
      doBind(term1Ptr,term2);
      goto exit;
    }
    if (term1==term2) {
      goto exit;
    }
  } else if (!isAnyVar(term1) && currentUVarPrototypeEq(term2) && scp==0) {
    COUNT(varNonvarUnify);
    doBind(term2Ptr,term1);
    goto exit;
  }

  return unify(A,B,scp);

 exit:
  COUNT(totalUnify);
  return OK;
}

inline
void AM::deinstallCurrent()
{
  reduceTrailOnSuspend();
  currentBoard->unsetInstalled();
  setCurrent(currentBoard->getParent());
}

inline
void AM::deinstallPath(Board *top)
{
  Assert(!top->isCommitted() && !top->isFailed());

  while (currentBoard != top) {
    deinstallCurrent();
    Assert(currentBoard != rootBoard || top == rootBoard);
  }
}

#define ShallowCheckLocal(ptr)                                          \
   if (shallowHeapTop) return reallyHeapNever(ptr,shallowHeapTop);

inline
Bool AM::isLocalUVar(TaggedRef var,TaggedRef *varPtr)
{
  // variables are usually bound
  // in the node where they are created
  ShallowCheckLocal(varPtr);
  if (currentUVarPrototypeEq(var)) return OK;
  return isLocalUVarOutline(var,varPtr);
}


inline
Bool AM::isLocalSVar(SVariable *var) {
  ShallowCheckLocal(var);
  return (var->getHome1()==currentBoard) || isLocalSVarOutline(var);
}

inline
Bool AM::isLocalSVar(TaggedRef var)
{
  return isLocalSVar(tagged2SVar(var));
}

inline
Bool AM::isLocalCVar(TaggedRef var) {
  return isLocalSVar(taggedCVar2SVar(var));
}

inline
Bool AM::isLocalVariable(TaggedRef var,TaggedRef *varPtr)
{
  CHECK_ISVAR(var);

  if (isUVar(var)) return isLocalUVar(var,varPtr);
  if (isSVar(var)) return isLocalSVar(var);

  return isLocalCVar(var);
}

inline
void AM::checkSuspensionList(TaggedRef taggedvar, PropCaller calledBy)
{
  SVariable * var = tagged2SuspVar(taggedvar);
  var->setSuspList(checkSuspensionList(var, var->getSuspList(),
                                       calledBy));
}

/* ------------------------------------------------------------------------
 * Threads
 * ------------------------------------------------------------------------ */

// unset the ThreadSwitch flag and reset the counter
inline
void AM::restartThread()
{
  unsetSFlag(ThreadSwitch);
  threadSwitchCounter=osMsToClockTick(TIME_SLICE);
}

inline
void AM::addSuspendVarList(TaggedRef * t)
{
  Assert(isAnyVar(*t));

  if (suspendVarList==makeTaggedNULL()) {
    suspendVarList=makeTaggedRef(t);
  } else {
    suspendVarList=cons(makeTaggedRef(t),suspendVarList);
  }
}

/*
 * Threads
 */

//
//  An allocator for thread's bodies;
inline
RunnableThreadBody* AM::allocateBody()
{
  RunnableThreadBody *body = threadBodyFreeList;
  if (body) {
    threadBodyFreeList = threadBodyFreeList->next;
  } else {
    body = new RunnableThreadBody(ozconf.stackMinSize);
  }

  body->taskStack.init();

  return body;
}


//
//  Make a runnable thread with a task stack;
inline
Thread *AM::mkRunnableThread(int prio, Board *bb)
{
  Thread *th = new Thread(S_RTHREAD | T_runnable,prio,bb);
  th->setBody(allocateBody());

  int inSolve = incSolveThreads(bb);
  if (inSolve) {
    th->setInSolve();
  }
  return th;
}

//
//  Make a runnable thread with a task stack;
inline
Thread *AM::mkRunnableThreadOPT(int prio, Board *bb)
{
  Thread *th = new Thread(S_RTHREAD | T_runnable,prio,bb);
  th->setBody(allocateBody());

  Assert(bb==currentBoard || bb->getParent() == currentBoard);
  if (currentSolveBoard) {
    int inSolve=incSolveThreads(bb);
    Assert(inSolve);
    th->setInSolve();
  } else {
    Assert(!isInSolveDebug(bb));
  }
  return th;
}

//
//  Constructors for 'suspended' cases:
//    deep 'unify' suspension;
//    suspension with continuation;
//    suspension with a 'C' function;
//    suspended sequential thread (with a task stack);
//
inline
Thread *AM::mkWakeupThread(Board *bb)
{
  return new Thread(S_WAKEUP,DEFAULT_PRIORITY,bb);
}

//
inline
Thread *AM::mkPropagator(Board *bb, int prio, OZ_Propagator *pro)
{
  Thread * th = new Thread(S_PR_THR, prio, bb);
  th->setInitialPropagator(pro);

  return th;
}

//
inline
Thread *AM::mkSuspendedThread(Board *bb, int prio)
{
  Thread *th = new Thread(S_RTHREAD,prio,bb);
  th->setBody(allocateBody());

  return th;
}

/* ------------------------------------------------------------------------
 * OO stuff
 * ------------------------------------------------------------------------ */

inline
void AM::changeSelf(Object *o)
{
  Object *oldSelf = cachedSelf;
  if(o != oldSelf) {
    cachedStack->pushSelf(oldSelf);
    cachedSelf = o;
  }
}

inline
void AM::saveSelf()
{
  if (cachedSelf != 0) {
    currentThread->setSelf(cachedSelf);
    cachedSelf = 0;
  }
}

#endif  // __AM_ICC
