/*
  Hydra Project, DFKI Saarbruecken,
  Stuhlsatzenhausweg 3, D-66123 Saarbruecken, Phone (+49) 681 302-5312
  Author: popow, mehl
  Last modified: $Date$ from $Author$
  Version: $Revision$
  State: $State$

  ------------------------------------------------------------------------
*/

#ifndef __AM_ICC
#define __AM_ICC

#if !defined(OUTLINE) && defined(__GNUC__)
#pragma interface
#endif

// optimize: inline ....

inline
Bool AM::isToplevel() { return (currentBoard == rootBoard); }

inline
void AM::rebind(TaggedRef *refPtr, TaggedRef newRef)
/* (re)bind Ref *ref to Term *ptr;                     */
/* We need this procedure for the rational unification */
/* algorithm;                                          */
{
  rebindTrail.pushCouple(refPtr, *refPtr);   /* always;   */
  doBind(refPtr,newRef);
}

/* specially optimized unify: test two most probable cases first:
 *
 *     1. bind a variable
 *     2. test two non-variables
 *     3. but don't forget to check identical variables
 */

inline
Bool AM::fastUnify(TaggedRef A, TaggedRef B, Bool prop)
{
  if (prop == NO) goto bomb;
  
  {
    TaggedRef proto = currentUVarPrototype;
    TaggedRef term1 = A;
    TaggedRef term2 = B;
    
    DEREF(term1,term1Ptr,_1);
    
    if (proto == term1) {
      DEREF(term2,_2,_3);
      if (!isAnyVar(term2)) {
	doBind(term1Ptr,term2);
	goto exit;	
      }
    } 
    DEREF(term2,term2Ptr,_2);
    if (proto == term2 && !isAnyVar(term1)) {
      doBind(term2Ptr,term1);
      goto exit;
    }
  }
 bomb:
  return unify(A,B,prop);

 exit:
  return OK;
}

inline
void AM::bindToNonvar(TaggedRef *varPtr, TaggedRef var, TaggedRef a, Bool prop) 
{
  // most probable case first: local UVar
  // if (isUVar(var) && currentBoard == tagged2VarHome(var)) {
  // more efficient:
  if (var == currentUVarPrototype && prop) {
    doBind(varPtr,a);
  } else {
    genericBind(varPtr,var,NULL,a,prop);
  }
  LOCAL_PROPAGATION(Assert(localPropStore.isEmpty() ||
			   localPropStore.isInLocalPropagation()));

}

inline
void AM::deinstallCurrent()
{
  reduceTrailOnSuspend();
  currentBoard->unsetInstalled();
  setCurrent(currentBoard->getParentFast());
}

inline
void AM::deinstallPath(Board *top)
{
  Assert(!top->isCommitted() && !top->isFailed());
  
  while (currentBoard != top) {
    deinstallCurrent();
    Assert(currentBoard != rootBoard || top == rootBoard);
  }
}

inline
Bool AM::installScript(Script &script)
{
  Bool ret = OK;
  for (int index = 0; index < script.getSize(); index++) {
    if (!unify(script[index].getLeft(),script[index].getRight())) {
      ret = NO;
      if (!isToplevel()) {
	break;
      }
    }
  }
#ifndef DEBUG_CHECK
  script.dealloc();
#else
  if (ret == OK) 
    script.dealloc ();
#endif
  return ret;
}

inline
Bool AM::entailment ()
{
  return (!currentBoard->hasSuspension()
	  // First test: no subtrees;
	  && trail.isEmptyChunk()
	  // second test: is this node stable?
	  );
}

inline
void AM::bind(TaggedRef *varPtr, TaggedRef var, TaggedRef *termPtr, Bool prop)
{
  genericBind(varPtr,var,termPtr, *termPtr, prop);
}

inline
Bool AM::isLocalUVar(TaggedRef var)
{
  return (var == currentUVarPrototype ||
	  // variables are usually bound 
	  // in the node where they are created
	  tagged2VarHome(var)->getBoardFast() == currentBoard );
}

inline
Bool AM::isLocalSVar(TaggedRef var) {
  Board *home = tagged2SVar(var)->getHome1();

  return (home == currentBoard ||
	  home->getBoardFast() == currentBoard );
}

inline
Bool AM::isLocalSVar(SVariable *var) {
  Board *home = var->getHome1();

  return (home == currentBoard ||
	  home->getBoardFast() == currentBoard );
}

inline
Bool AM::isLocalCVar(TaggedRef var) {
  Board *home = taggedCVar2SVar(var)->getHome1();

  return (home == currentBoard ||
          home->getBoardFast() == currentBoard );
}

inline
Bool AM::isLocalVariable(TaggedRef var)
{
  CHECK_ISVAR(var);

  if (isUVar(var))
    return isLocalUVar(var);
  if (isSVar(var))
    return isLocalSVar(var);

  return isLocalCVar(var);
}

inline 
void updateExtSuspension(Board *varHome, Suspension *susp)
{
  if (am.currentSolveBoard) {
    am.setExtSuspension (varHome, susp);
  }
}

inline
void AM::checkSuspensionList(TaggedRef taggedvar, TaggedRef term,
			     PropCaller calledBy)
{
  Assert(isRef(term) || !isAnyVar(term));

  SVariable * var = tagged2SuspVar(taggedvar);
  var->setSuspList(checkSuspensionList(var, taggedvar, var->getSuspList(),
				       term, calledBy));
}

inline
Bool AM::isEmptyTrailChunk ()
{
  return (trail.isEmptyChunk ());
}

inline
void AM::pushCall(Board *b, Chunk *def, int arity, RefsArray args)
{
  currentThread->pushCall(b,def,args,arity);
}

inline
void AM::pushTask(Board *n,ProgramCounter pc,
		  RefsArray y,RefsArray g,RefsArray x,int i)
{
  currentThread->pushCont(n,pc,y,g,x,i,OK);
}

inline
void AM::pushCFun(Board *n, OZ_CFun f, RefsArray x, int i)
{
  currentThread->pushCFunCont(n, f, (Suspension *) NULL, x, i, OK);
}
 
inline
void AM::pushNervous(Board *n)
{
  currentThread->pushNervous(n);
}

/* ------------------------------------------------------------------------
 * Threads
 * ------------------------------------------------------------------------ */

// unset the ThreadSwitch flag and reset the counter
inline
void AM::restartThread()
{
  unsetSFlag(ThreadSwitch);
  threadSwitchCounter=osMsToClockTick(ozconf.timeSlice);
}

inline
Thread *AM::newThread(int p,Board *bb)
{
#ifdef NEWCOUNTER
  bb->incSuspCount();
#endif
  Thread *th = threadsFreeList;
  if (th) {
    threadsFreeList = th->next;
  } else {
    th=new Thread(ozconf.taskStackSize);
  }
  th->init(p,bb);
  return th;
}

// free the memory of the thread (there are no references to it anymore)
inline
void AM::disposeThread(Thread *th)
{
  Verbose((VERB_THREAD,"Thread::dispose = 0x%x\n",this));
  if (th == rootThread) {
    rootThread->init(th->getPriority(),rootBoard);
    checkToplevel();
  } else {
    /* dispose thread: */
    th->next=threadsFreeList;
    threadsFreeList = th;
  }
}

// check if the thread is scheduled
inline
Bool AM::isScheduled(Thread *th)
{
  return th->prev!=NULL || th->next!=NULL || threadsHead==th;
}

inline
void AM::checkThreadsAssertion()
{
#ifdef DEBUG_CHECK
  if (threadsHead==0) {
    Assert(threadsTail==0);
    return;
  }
  Assert(threadsTail!=0);
  Thread *th=threadsHead;
  Assert(th->prev==0);
  while (th->next != 0) {
    Assert(th->next->getPriority() <= th->getPriority());
    Assert(th->next->prev==th);
    th=th->next;
  }
  Assert(th==threadsTail);
#endif
}

// insert 'this' after 'here', if here = 0 then at head
inline
void AM::insertAfter(Thread *th,Thread *here)
{
  th->prev=here;
  if (here) {
    th->next=here->next;
    here->next=th;
    if (th->next) {
      Assert(th->next->prev == here);
      th->next->prev=th;
    } else {
      Assert(threadsTail == here);
      threadsTail=th;
    }
  } else {
    th->next=threadsHead;
    threadsHead=th;
    if (th->next) {
      Assert(th->next->prev == 0);
      th->next->prev=th;
    } else {
      Assert(threadsTail == 0);
      threadsTail=th;
    }
  }
}

// insert into priority queue searching from tail
//  after the last one with the same or a higher priority
inline
void AM::insertFromTail(Thread *th)
{
  checkThreadsAssertion();
  Thread *here;
  for (here = threadsTail; here; here=here->prev) {
    if (here->getPriority() >= th->getPriority()) {
      break;
    }
  }
  insertAfter(th,here);
  checkThreadsAssertion();
}

// insert 'this' before 'here', if here = 0 then at tail
inline
void AM::insertBefore(Thread *th, Thread *here)
{
  th->next=here;
  if (here) {
    th->prev=here->prev;
    here->prev=th;
    if (th->prev) {
      Assert(th->prev->next==here);
      th->prev->next=th;
    } else {
      Assert(threadsHead==here);
      threadsHead=th;
    }
  } else {
    th->prev=threadsTail;
    threadsTail=th;
    if (th->prev) {
      Assert(th->prev->next==0);
      th->prev->next=th;
    } else {
      Assert(threadsHead==0);
      threadsHead=th;
    }
  }
}

// insert into priority queue searching from head
//  before the first one with a lower priority
inline
void AM::insertFromHead(Thread *th)
{
  checkThreadsAssertion();
  Thread *here;
  for (here = threadsHead; here; here=here->prev) {
    if (here->getPriority() < th->getPriority()) {
      break;
    }
  }
  insertBefore(th,here);
  checkThreadsAssertion();
}

// add a thread to the thread queue
inline
void AM::scheduleThread(Thread *th)
{
  Assert(!isScheduled(th));

  if (th != currentThread
      && currentThread
      && th->getPriority() > currentThread->getPriority()) {
    insertFromHead(th);
    setSFlag(ThreadSwitch);
  } else {
    insertFromTail(th); // or insertFromHead();
  }
}

inline
Bool AM::threadQueueIsEmpty()
{
  return threadsHead ? NO : OK;
}

/* only usage in emulate */
inline
Thread *AM::getFirstThread()
{
  checkThreadsAssertion();
  Assert(threadsHead!=0);
  Thread *tt = threadsHead;
  Verbose((VERB_THREAD,"Thread::GetFirst = 0x%x\n",tt));
  threadsHead=tt->next;
  if (threadsHead) {
    Assert(threadsHead->prev == tt);
    threadsHead->prev = 0;
  } else {
    Assert(threadsTail == tt);
    threadsTail = 0;
  }
  tt->prev=tt->next=(Thread *) NULL;

  checkThreadsAssertion();
  return tt;
}

// unlink the thread from the thread queue
inline
Thread *AM::unlinkThread(Thread *th)
{
  checkThreadsAssertion();
  if (th->prev) {
    Assert(th->prev->next == th);
    th->prev->next=th->next;
  } else {
    Assert(threadsHead==th);
    threadsHead=th->next;
  }
  if (th->next) {
    Assert(th->next->prev == th);
    th->next->prev=th->prev;
  } else {
    Assert(threadsTail == th);
    threadsTail=th->prev;
  }
  th->prev=th->next=0;
  checkThreadsAssertion();
  return th;
}

inline
void AM::addSuspendVarList(TaggedRef t)
{
  if (suspendVarList==makeTaggedNULL()) {
    suspendVarList=t;
  } else {
    suspendVarList=cons(t,suspendVarList);
  }
}

/*
 * MISC
 */

inline
Board *Literal::getBoardFast()
{
  return home->getBoardFast();
}

inline
Board *Abstraction::getBoardFast()
{
  return home->getBoardFast();
}

/*
inline
Board *Cell::getBoardFast()
{
  return name->getBoardFast();
}
*/

#endif  // __AM_ICC
