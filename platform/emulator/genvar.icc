/*
 *  Authors:
 *    Tobias Mueller (tmueller@ps.uni-sb.de)
 *
 *  Contributors:
 *    Denys Duchier (duchier@ps.uni-sb.de)
 *
 *  Copyright:
 *    Organization or Person (Year(s))
 *
 *  Last change:
 *    $Date$ by $Author$
 *    $Revision$
 *
 *  This file is part of Mozart, an implementation
 *  of Oz 3:
 *     $MOZARTURL$
 *
 *  See the file "LICENSE" or
 *     $LICENSEURL$
 *  for information on usage and redistribution
 *  of this file, and for a DISCLAIMER OF ALL
 *  WARRANTIES.
 *
 */

#ifndef __genvar_icc__
#define __genvar_icc__

#if defined(INTERFACE) && !defined(OUTLINE)
#pragma interface
#endif


inline
OZ_Return GenCVariable::unify(TaggedRef * tptr1,
                              TaggedRef *tptr2, TaggedRef term2,
                              ByteCode *scp)
{
  TaggedRef term1 = *tptr1;

  switch (getType()){
  case FDVariable:
    {
      if (! ((GenFDVariable *)this)->unifyFD(tptr1, term1, tptr2, term2, scp))
        return FAILED;
    }
  break;
  case FSetVariable:
    {
      if (! ((GenFSetVariable *)this)
          ->unifyFSet(tptr1, term1, tptr2, term2, scp))
        return FAILED;
    }
    break;
  case OFSVariable:
    if (! ((GenOFSVariable *)this)
        ->unifyOFS(tptr1, term1, tptr2, term2, scp)) {
      return FAILED;
    }
    break;
  case MetaVariable:
    {
      if (! ((GenMetaVariable *)this)
          ->unifyMeta(tptr1, term1, tptr2, term2, scp))
        return FAILED;
    }
    break;
  case BoolVariable:
    {
      if (! ((GenBoolVariable *)this)
          ->unifyBool(tptr1, term1, tptr2, term2, scp))
        return FAILED;
    }
    break;
  case PerdioVariable:
    return ((PerdioVar *)this)
      ->unifyPerdioVar(tptr1, tptr2==0?&term2:tptr2, scp);

  case CtVariable:
    if (! ((GenCtVariable*) this)->unifyCt(tptr1, term1, tptr2, term2, scp))
      return FAILED;
    break;

  default:
    return unifyV(tptr1, term1, tptr2, term2, scp);

  }

  return PROCEED;
}

inline
int GenCVariable::getSuspListLength(void)
{
  GenVarCheckType(getType());

  switch (getType()){
  case FDVariable:
    return ((GenFDVariable *)this)->getSuspListLength();
  case BoolVariable:
    return ((GenBoolVariable *)this)->getSuspListLength();
  case OFSVariable:
    return ((GenOFSVariable *)this)->getSuspListLength();
  case FSetVariable:
    return ((GenFSetVariable *)this)->getSuspListLength();
  default:
    return getSuspListLengthV();
  }
}

inline
Bool GenCVariable::valid(TaggedRef *ptr,TaggedRef val)
{
  switch (getType()){
  case FDVariable:   return ((GenFDVariable*)this)->valid(val);
  case OFSVariable:  return ((GenOFSVariable*)this)->valid(val);
  case MetaVariable: return ((GenMetaVariable*)this)->valid(val);
  case BoolVariable: return ((GenBoolVariable*)this)->valid(val);
  case FSetVariable: return ((GenFSetVariable*)this)->valid(val);
  case PerdioVariable: return ((PerdioVar *)this)->valid(ptr,val);
  case CtVariable: return FALSE;
  default: return validV(ptr,val);
  }
}

inline
int GenCVariable::hasFeature(TaggedRef fea,TaggedRef *out)
{
  switch (getType()){
  case FDVariable:   return FAILED;
  case OFSVariable:  return ((GenOFSVariable*)this)->hasFeature(fea,out);

  case MetaVariable:
  case BoolVariable:
  case FSetVariable:
  case PerdioVariable:
  case CtVariable:
    return SUSPEND;

  default:
    return hasFeatureV(fea,out);
  }
}

// this is supposed to be the local variable
inline
void GenCVariable::installPropagators(GenCVariable * glob_var)
{
  Assert(getType() == glob_var->getType() ||
         (getType() == BoolVariable && glob_var->getType() == FDVariable));
  Assert(am.inShallowGuard() || am.isLocalSVar(this) &&
         ! am.isLocalSVar(glob_var));

  Board * glob_home = GETBOARD(glob_var);

  // any suspension list
  suspList = oz_installPropagators(suspList, glob_var->getSuspList(),
                                   glob_home);

  switch (glob_var->getType()) {

  case FDVariable:
    // a global fd variable can stay fd variable or become a boolean variable
    {
      switch (getType()){

      case FDVariable:
        ((GenFDVariable *)this)
          ->installPropagators((GenFDVariable *) glob_var, glob_home);
        break;

      case BoolVariable:
        ((GenBoolVariable *)this)
          ->installPropagators((GenFDVariable *) glob_var, glob_home);
        break;


      default:
        Assert(0);
        break;
      }
    } // case FDVariable
  break;

  case BoolVariable:
    // boolean variable do only have an any suspension list
    {
      Assert (getType() == BoolVariable);
    } // case BoolVariable
  break;

  case FSetVariable:
    {
      Assert (getType() == FSetVariable);

      ((GenFSetVariable *)this)
        ->installPropagators((GenFSetVariable *) glob_var, glob_home);
    } // case FSetVariable
  break;

  case CtVariable:
    {
      Assert (getType() == CtVariable);
      ((GenCtVariable *)this)
        ->installPropagators((GenCtVariable *) glob_var, glob_home);
    } // case CtVariable
  break;

  // the following types of variable do not have extra suspension
  // lists which have to be installed

  case OFSVariable:
    break;

  default:
    Assert(0);
    break;
  }
}

inline
void GenCVariable::dispose(void)
{
  switch (getType()){
  case FDVariable:
    ((GenFDVariable *)this)->dispose();
    break;
  case BoolVariable:
    ((GenBoolVariable *)this)->dispose();
    break;
  case FSetVariable:
    ((GenFSetVariable *)this)->dispose();
    break;
  case PerdioVariable:
    ((PerdioVar *)this)->dispose();
    break;
  default:
    disposeV();
    // mm2: why not handle other cases?
    break;
  }
}


inline
void addSuspCVar(TaggedRef *v, Suspension susp, int unstable=TRUE)
{
  GenCVariable * cv = tagged2CVar(*v);
  switch(cv->getType()) {
  case PerdioVariable:
    ((PerdioVar*) cv)->addSuspPerdioVar(v, susp, unstable);
    break;
  case FDVariable:
  case OFSVariable:
  case MetaVariable:
  case BoolVariable:
  case FSetVariable:
  case CtVariable:
    cv->addSuspSVar(susp, unstable);
    break;
  default:
    cv->addSuspV(susp, v, unstable);
    break;
  }
}

#endif //__genvar_icc__
