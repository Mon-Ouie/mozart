/*
 *  Authors:
 *    Alberto Delgado (adelgado@cic.puj.edu.co)
 *    Alejandro Arbelaez (aarbelaez@cic.puj.edu.co)
 *    Gustavo Gutierrez (ggutierrez@cic.puj.edu.co)
 * 
 *  Contributors:
 * 
 *  Copyright:
 *    Alberto Delgado, 2006-2007
 *    Alejandro Arbelaez, 2006-2007
 *    Gustavo Gutierrez, 2006-2007
 * 
 *  Last change:
 *    $Date: 2007-08-16T11:58:10.543356Z $ by $Author: ggutierrez $
 *    $Revision: 309 $
 * 
 *  This file is part of Mozart, an implementation 
 *  of Oz 3:
 *     http://www.mozart-oz.org
 * 
 *  See the file "LICENSE" or
 *     http://www.mozart-oz.org/LICENSE.html
 *  for information on usage and redistribution 
 *  of this file, and for a DISCLAIMER OF ALL 
 *  WARRANTIES.
 *
 */

template <class VarImp, Gecode::PropCond pc>
inline
OZ_Return GeVar<VarImp, pc>::unifyV(TaggedRef* lPtr, TaggedRef* rPtr)
{
  //printf("unifyV GeVar\n");fflush(stdout);
  
  GeVar<VarImp,pc>* lgevar = this;
  GenericSpace* space = extVar2Var(lgevar)->getBoardInternal()->getGenericSpace();
  
  
  /* the real condition we need to check here is:
     if (oz_isSimpleVar(*rPtr) || oz_isOptVar(*rPtr))
  */
  if (!oz_isGeVar(*rPtr)) {
      /* This is the case when right var is either a simple var or an
	 optimized var and this represents a global var.
      */
    oz_bindGlobalVar2(tagged2Var(*rPtr),rPtr,makeTaggedRef(lPtr));
    goto PROP;
  }
  
  
  {
    GeVar<VarImp,pc>* rgevar = static_cast<GeVar<VarImp,pc>*>(get_GeVar(*rPtr));
    //GeVarBase *rgevar = get_GeVar(*rPtr);
    if(am.inEqEq()) {
      if( IsEmptyInter(lPtr, rPtr) ) return FAILED;
      else {
	ensureDomReflection();
	rgevar->ensureDomReflection();
	trail.pushGeVariable(lPtr);
	trail.pushGeVariable(rPtr);
	return PROCEED;
      }
    }
    
    Assert(space);
    if(oz_isLocalVar(extVar2Var(lgevar))){
      if(!oz_isLocalVar(extVar2Var(rgevar))){
	if(!(rgevar->intersect(makeTaggedRef(lPtr))))
	  return FAILED;
	oz_bindGlobalVar2(extVar2Var(rgevar), rPtr, makeTaggedRef(lPtr));	
	disposeS();
      }else{
	////	printf("unifyV GeIntVar this is local\n");fflush(stdout);
	  // "this" is local.  The binding cannot go upwards, so...    
	  //Assert(oz_isLocalVar(extVar2Var(rgeintvar)));
	  //I don't think this assert is correct,  other can be a global var
	//printf("local, local \n");fflush(stdout);
	if(!(rgevar->intersect(makeTaggedRef(lPtr))))
	  return FAILED;
	
	oz_bindLocalVar(extVar2Var(this), lPtr, makeTaggedRef(rPtr));
	propagator(space,lgevar,rgevar);
	lgevar->incUnifyC();
	rgevar->incUnifyC();
	space->incUnifyProps();
      }
    }else{
      //printf("global, global \n");fflush(stdout);
      OZ_Term lv = newVar();
      
      //TaggedRef glv_tmp = oz_deref(makeTaggedVar(extVar2Var(get_GeIntVar(lv))));
      if(!(lgevar->intersect(lv)))
	return FAILED;
      if(!(rgevar->intersect(lv)))
	return FAILED;	
      Assert(oz_isRef(lv));
      oz_bindGlobalVar2(extVar2Var(lgevar), lPtr, lv);	
      oz_bindGlobalVar2(extVar2Var(rgevar), rPtr, lv);	
    }
    
  }
  /* Unification is entailed by means of an eq propagator. After post this
     propagator the generic space must become unstable. The unstability is
     a result of posting the propagator */
  
 PROP:
  //wakeup space propagators to inmediatly update all related variables
  //printf("GeVar.icc antes de status \n");fflush(stdout);
  if(space->status() == Gecode::SS_FAILED) {
    extVar2Var(this)->getBoardInternal()->setFailed();
    return FAILED;
  }
  else
    return PROCEED;
}

template <class VarImp, Gecode::PropCond pc>
inline
OZ_Return GeVar<VarImp,pc>::bindV(TaggedRef* vPtr, TaggedRef val) {
  if (validV(val)) {
    if(am.inEqEq()) {
      if( !In(val) ) return FAILED;
      else {
	ensureDomReflection();
	trail.pushGeVariable(vPtr);
	return PROCEED;
      }
    }

    if (oz_isLocalVar(extVar2Var(this))) {
      //printf("variable local\n"); fflush(stdout);
      // first bind the variable in Mozart
      oz_bindLocalVar(extVar2Var(this), vPtr, val);
      	
      GenericSpace* s =  extVar2Var(this)->getBoardInternal()->getGenericSpace();
      	
      Gecode::ModEvent me = bind(s,this,val);
      Assert(!Gecode::me_failed(me));
      if(s->status() == Gecode::SS_FAILED) {
	extVar2Var(this)->getBoardInternal()->setFailed();
	return FAILED;
      }
      //local propagators
      if(hasDomReflector()) {
      	s->decForeignProps();
      }
      s->incDetermined();
      s->decUnifyProps(getUnifyC());
      return PROCEED;
  
    } else {
      // global binding...
      oz_bindGlobalVar(extVar2Var(this), vPtr, val);
    }
    return PROCEED;
  }
  return OZ_FAILED;
}

template <class VarImp, Gecode::PropCond pc> 
inline
void GeVar<VarImp,pc>::ensureValReflection(void) {
  GenericSpace *s = oz_currentBoard()->getGenericSpace(true);
  printf("ensureValReflector >> genericSpace s %p \n",s);fflush(stdout);
  VarImp *vip = reinterpret_cast<VarImp*>(s->getVarInfo(index));
  GeView<VarImp> v(vip);
  new (s) ValReflector<VarImp>(s, v, index);
}


template <class VarImp, Gecode::PropCond pc>
inline
void GeVar<VarImp,pc>::ensureDomReflection(void) {
  if (!hasDomRefl) {
    GenericSpace *s = oz_currentBoard()->getGenericSpace(true);
    printf("ensureDomReflector >> genericSpace s %p \n",s);fflush(stdout);
    VarImp *ivp = reinterpret_cast<VarImp*>(s->getVarInfo(index));
    GeView<VarImp> v(ivp);
    new (s) DomReflector<VarImp,pc>(s,v,index);
    s->incForeignProps();
    hasDomRefl = true;
  }
}

#include <sstream>

template <class VarImp, Gecode::PropCond pc>
void GeVar<VarImp,pc>::printStreamV(ostream &out,int depth) {
  //printf("GeVar->printStreamV\n");fflush(stdout);
  ensureDomReflection();
  toStream(out);
}
