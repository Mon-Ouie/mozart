/*
 *  Authors:
 *    Ralf Scheidhauer (Ralf.Scheidhauer@ps.uni-sb.de)
 * 
 *  Contributors:
 *    optional, Contributor's name (Contributor's email address)
 * 
 *  Copyright:
 *    Organization or Person (Year(s))
 * 
 *  Last change:
 *    $Date$ by $Author$
 *    $Revision$
 * 
 *  This file is part of Mozart, an implementation 
 *  of Oz 3:
 *     $MOZARTURL$
 * 
 *  See the file "LICENSE" or
 *     $LICENSEURL$
 *  for information on usage and redistribution 
 *  of this file, and for a DISCLAIMER OF ALL 
 *  WARRANTIES.
 *
 */

#ifndef __mem_icc__
#define __mem_icc__

#if defined(INTERFACE) && !defined(OUTLINE)
#pragma interface
#endif


inline
void * freeListMalloc(size_t chunk_size)
{
  Assert(((chunk_size & 3) == 0) && (chunk_size > 0));

  int mod = chunk_size%WordSize;
  if (mod) {
    chunk_size += WordSize-mod;
  }

  void **freeListCache = FreeList;
  void *aux = chunk_size < freeListMaxSize ? freeListCache[chunk_size] : NULL;

  //  DebugMem(aux = NULL);

  if (aux == NULL) {
    aux = heapMalloc(chunk_size); 
  } else {
    COUNT1(freeListAllocated,chunk_size);
    freeListCache[chunk_size] = *(void **)aux;
  }
  DebugMem(memset((char *)aux,0x5A,chunk_size));

  return aux;
}

inline
void freeListDispose(void * addr, size_t chunk_size)
{
  Assert((chunk_size & 3) == 0);

  int mod = chunk_size%WordSize;
  if (mod) {
    chunk_size += WordSize-mod;
  }

  DebugCode(memset((char *)addr,0x5A,chunk_size));

  Assert(chunk_size > 0);
  if (chunk_size < freeListMaxSize) {
#ifdef DEBUG_MEM
    void * aux = FreeList[chunk_size];
    while (aux) {
      if (aux == addr) 
	warning("Entering chunk twice.");
      aux = * (void **) aux;
    }
#endif
    *(void **)addr =  FreeList[chunk_size];
    FreeList[chunk_size] = addr;
    COUNT1(freeListDisposed,chunk_size);
  }
}

// return used kilo bytes on the heap
inline 
unsigned int getUsedMemory(void)
{
  return heapTotalSize - (heapTop - heapEnd)/KB;
}

inline 
unsigned int getUsedMemoryBytes(void)
{
  return heapTotalSizeBytes - (heapTop - heapEnd);
}

#endif //__mem_icc__

