/* -*-c++-*-
 *  Authors:
 *    Ralf Scheidhauer (Ralf.Scheidhauer@ps.uni-sb.de)
 *
 *  Contributors:
 *    optional, Contributor's name (Contributor's email address)
 *
 *  Copyright:
 *    Organization or Person (Year(s))
 *
 *  Last change:
 *    $Date$ by $Author$
 *    $Revision$
 *
 *  This file is part of Mozart, an implementation
 *  of Oz 3:
 *     http://www.mozart-oz.org
 *
 *  See the file "LICENSE" or
 *     http://www.mozart-oz.org/LICENSE.html
 *  for information on usage and redistribution
 *  of this file, and for a DISCLAIMER OF ALL
 *  WARRANTIES.
 *
 */

#ifndef __mem_icc__
#define __mem_icc__

#if defined(INTERFACE) && !defined(OUTLINE)
#pragma interface
#endif


inline
void * freeListMalloc(size_t size) {
  Assert(((size & 3) == 0) && (size > 0));

  if (size < freeListMaxSize) {
    COUNT1(freeListAllocated,size);
    register FreeListMem ** fl = &(FreeList[size]);
    register FreeListMem * aux = *fl;

    if (aux) {
      *fl = (FreeListMem*) ToPointer(aux->next);
#ifdef DEBUG_MEM
      {
        char *s=(char *)aux;
        s+=sizeof(FreeListMem);
        for (int i=size-sizeof(FreeListMem); i--;) {
          Assert(*s++==0x5a)
        }
      }
#endif
      DebugMem(memset((char *)aux,0x5A,size));
      return aux;
    }
  }

  COUNT1(sizeFreeListObjs,size);
  register void * aux = heapMalloc(size);

  DebugMem(memset((char *)aux,0x5A,size));

  return aux;
}


void freeListChop(void * addr, size_t size);

inline
void freeListDispose(void * addr, size_t size) {
  Assert((size & 3) == 0);
  Assert(size > 0);

  DebugCode(memset((char *)addr,0x5A,size));

  register FreeListMem** fl;

  if (size < freeListMaxSize) {
    COUNT1(freeListDisposed,size);
    fl = &(FreeList[size]);
#ifdef DEBUG_MEM
    {
      FreeListMem *aux = *fl;
      while (aux) {
        Assert(aux != addr);
        aux = (FreeListMem*) ToPointer(aux->next);
      }
    }
#endif
    FreeListMem* aux = (FreeListMem*)addr;
    aux->next = ToInt32(*fl);
    *fl = aux;
  } else {
    freeListChop(addr, size);
  }
}

// return used kilo bytes on the heap
inline
unsigned int getUsedMemory(void)
{
  return heapTotalSize - (heapTop - heapEnd)/KB;
}

inline
unsigned int getUsedMemoryBytes(void)
{
  return heapTotalSizeBytes - (heapTop - heapEnd);
}

#endif //__mem_icc__
