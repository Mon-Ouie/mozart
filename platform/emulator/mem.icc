/*
  Hydra Project, DFKI Saarbruecken,
  Stuhlsatzenhausweg 3, D-66123 Saarbruecken, Phone (+49) 681 302-5312
  Author: tmueller
  Last modified: $Date$ from $Author$
  Version: $Revision$
  State: $State$

  ------------------------------------------------------------------------
*/

#ifndef __mem_icc__
#define __mem_icc__

#if defined(INTERFACE) && !defined(OUTLINE)
#pragma interface
#endif

/* like malloc(3): return pointer aligned to void* */
inline
void *heapMalloc(size_t chunk_size)
{
  return mallocBody(chunk_size,WordSize);
}


inline
void * freeListMalloc(size_t chunk_size)
{
  Assert(((chunk_size & 3) == 0) && (chunk_size > 0));

  int mod = chunk_size%WordSize;
  if (mod) {
    chunk_size += WordSize-mod;
  }

  void **freeListCache = FreeList;
  void *aux = chunk_size < freeListMaxSize ? freeListCache[chunk_size] : NULL;

  if (aux == NULL) {
    aux = heapMalloc(chunk_size); 
  } else {
    freeListCache[chunk_size] = *(void **)aux;
  }
  DebugMem(memset((char *)aux,0x5A,chunk_size));
  return aux;
}

inline
void freeListDispose(void * addr, size_t chunk_size)
{
  Assert((chunk_size & 3) == 0);

  int mod = chunk_size%WordSize;
  if (mod) {
    chunk_size += WordSize-mod;
  }

#ifdef DEBUG_MEM

// clear mem, so every reference leads to strange errors
// and turn off free list memory, do not reuse the memory
  memset((char *)addr,0x5A,chunk_size);
  return;

#else

  if (chunk_size < freeListMaxSize && chunk_size > 0) {
    *(void **)addr =  FreeList[chunk_size];
    FreeList[chunk_size] = addr;
  }
#endif
}

#endif //__mem_icc__

