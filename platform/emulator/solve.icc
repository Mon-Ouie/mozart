/*
 *  Authors:
 *    Kostja Popow (popow@ps.uni-sb.de)
 *    Christian Schulte (schulte@dfki.de)
 *
 *  Copyright:
 *    Organization or Person (Year(s))
 *
 *  Last change:
 *    $Date$ by $Author$
 *    $Revision$
 *
 *  This file is part of Mozart, an implementation
 *  of Oz 3:
 *     $MOZARTURL$
 *
 *  See the file "LICENSE" or
 *     $LICENSEURL$
 *  for information on usage and redistribution
 *  of this file, and for a DISCLAIMER OF ALL
 *  WARRANTIES.
 *
 */

// Solver

#ifndef __SOLVE_ICC_
#define __SOLVE_ICC_

#if !defined(OUTLINE) && defined(INTERFACE)
#pragma interface
#endif

/* ------------------------------------------------------------------------
   class SolveActor
   ------------------------------------------------------------------------ */

inline
void SolveActor::addSuspension(SuspList *l)
{
  l->setNext(suspList);
  suspList = l;
}

inline
void SolveActor::addSuspension (Suspension susp)
{
  suspList = new SuspList (susp, suspList);
}

inline
Bool SolveActor::areNoExtSuspensions()
{
  if (suspList == NULL)
    return (OK);
  else
    return (checkExtSuspList ());
}

inline
void SolveActor::inject(int prio, TaggedRef proc) {
  // thread creation for {proc root}
  RefsArray args = allocateRefsArray(1, NO);
  args[0] = makeTaggedRef(&solveVar);

  Thread *it = oz_mkRunnableThread(prio, solveBoard);
  it->pushCall(proc, args, 1);
  am.threadsPool.scheduleThread(it);
}

inline
TaggedRef SolveActor::merge(Board *bb, Bool isSibling) {
  solveBoard->setCommitted(bb);
  bb->incSuspCount(solveBoard->getSuspCount());

  if (!oz_installScript(solveBoard->getScriptRef())) {
    return makeTaggedNULL();
  }

  Assert(oz_isCurrentBoard(bb));

  // adjoin the list of or-actors to the list in actual solve actor!

  if (bb->isWait()) {
    WaitActor::Cast(bb->getActor())->mergeChoices(cpb);
  } else if (bb->isSolve()) {
    SolveActor *sa = SolveActor::Cast(bb->getActor());

    sa->mergeChoices(cpb);

    if (isSibling)
      sa->incThreads(threads);
  }

  // merge nonmonotonic susp lists
  if (nonMonoSuspList) {
    // Merge in current solve board but not elsewhere
    bb = am.currentSolveBoard();

    if (bb && bb->isSolve()) {
      // merge nonmonotonic susp list to another solve space

      SolveActor * sa = SolveActor::Cast(bb->getActor());

      if (sa->nonMonoSuspList) {
        sa->mergeNonMonoSuspListWith(nonMonoSuspList);
        setNonMonoSuspList(NULL);
      } else {
        sa->setNonMonoSuspList(nonMonoSuspList);
      }

    } else {
      // merge nonmonotinic susp list to a non-solve space

      DebugCode(OZ_warning("Merging solve space with non-solve space."));

      scheduleNonMonoSuspList();
    }
  }

  return solveVar;
}

inline
Board *SolveActor::clone(Board *bb) {
  ozstat.incSolveCloned();
  Bool testGround;
  Board *copy = (Board *) am.copyTree(solveBoard, &testGround);
  SolveActor *ca = SolveActor::Cast(copy->getActor());

  ca->setBoard(bb);

  if (testGround == OK) {
    ca->setGround();
    this->setGround();
  }

#ifdef CS_PROFILE
  ca->orig_start = cs_orig_start;
  ca->copy_start = cs_copy_start;
  ca->copy_size  = cs_copy_size;
#endif

  return copy;
}

inline
WaitActor *SolveActor::select(int left, int right)
{
  ozstat.incSolveAlt();

  if (cpb==0)
    return 0;

  WaitActor * wa = cpb->access();

  if (!wa)
    return 0;

  wa->selectOrFailChildren(left, right);

  return wa;
}


inline
void SolveActor::clearResult(Board* bb) {
  if (OZ_isVariable(result))
    return;

  result = makeTaggedRef(newTaggedUVar(bb));
}

#ifdef DEBUG_THREADCOUNT
extern int existingLTQs;
#endif


#endif  // __SOLVE_ICC_
