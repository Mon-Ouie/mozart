/*
  Hydra Project, DFKI Saarbruecken,
  Stuhlsatzenhausweg 3, D-66123 Saarbruecken, Phone (+49) 681 302-5312
  Author: popow
  Last modified: $Date$ from $Author$
  Version: $Revision$
  State: $State$

  Solver
  ------------------------------------------------------------------------
*/

#ifndef __SOLVE_ICC_
#define __SOLVE_ICC_

#if !defined(OUTLINE) && defined(INTERFACE)
#pragma interface
#endif

/* ------------------------------------------------------------------------
   class SolveActor
   ------------------------------------------------------------------------ */

inline
void SolveActor::addSuspension(SuspList *l)
{
  l->setNext(suspList);
  suspList = l;
}

inline
void SolveActor::addSuspension (Thread *thr)
{
  suspList = new SuspList (thr, suspList);
}

inline
Bool SolveActor::areNoExtSuspensions()
{
  if (suspList == NULL)
    return (OK);
  else
    return (checkExtSuspList ());
}

inline
void SolveActor::inject(int prio, TaggedRef proc) {
  // thread creation for {proc root}
  RefsArray args = allocateRefsArray(1, NO);
  args[0] = makeTaggedRef(&solveVar);

  Thread *it = new Thread(prio, solveBoard, OK);
  it->pushCall(proc, args, 1);
  am.scheduleThread(it);
}

inline
TaggedRef SolveActor::merge(Board *bb) {
  solveBoard->setCommitted(bb);
  bb->incSuspCount(solveBoard->getSuspCount());

  Assert(bb==am.currentBoard);

  // adjoin the list of or-actors to the list in actual solve actor!

  if (bb->isWait()) {
    if (hasChoices()) 
      WaitActor::Cast(bb->getActor())->pushChoices(cps);
  } else if (bb->isSolve()) {
    if (hasChoices()) 
      SolveActor::Cast(bb->getActor())->pushChoices(cps);
    threads += SolveActor::Cast(bb->getActor())->getThreads();
  }

  // merge local thread queue
  if (localThreadQueue) {
    // Merge in current solve board but not elsewhere
    bb = am.currentSolveBoard;
    
    if (bb && bb->isSolve()) {
    // merge local thread queue to another solve space

      SolveActor * sa = SolveActor::Cast(bb->getActor());
      
      if (sa->getLocalThreadQueue()) {
	for ( ; !localThreadQueue->isEmpty(); 
	      sa->getLocalThreadQueue()->enqueue(localThreadQueue->dequeue()));
      } else {
	sa->setLocalThreadQueue(localThreadQueue);
      }
      
    } else {
    // merge ltq (local thread queue) to a non-solve space
      
      DebugCode(OZ_warning("Merging solve space with non-solve space."));
      
      // unpack threads of ltq, i.e. make them runnable in new space
      while (!localThreadQueue->isEmpty()) {
	Thread * thr = localThreadQueue->dequeue();
	DebugCode (thr->unmarkPropagated());
	thr->propagatorToRunnable ();
	am.scheduleThread (thr, thr->getPriority());
      }
    
      // empty taskstack of ltq thread and dispose ltq
      localThreadQueue->getLTQThread()->getTaskStackRef()->makeEmpty();
      delete localThreadQueue;
      localThreadQueue = NULL;
    }
  }
  
  return solveVar;
}

inline
Board *SolveActor::clone(Board *bb) {
  ozstat.incSolveClone();
  Board *copy = (Board *) am.copyTree(solveBoard, (Bool *) NULL);
  
  SolveActor::Cast(copy->getActor())->setBoard(bb);

  return copy;
}

inline
int SolveActor::choose(int left, int right) {
  WaitActor *wa = this->topChoice();
  
  if (!wa)
    return -1;

  int n = wa->selectOrFailChildren(left, right);

  if (n==0) {
    return 0;
  } else if (n==1) {
    this->popChoice();

    if (wa->hasChoices())
      this->pushChoices(wa->getCps());

    Board *waitBoard = wa->getChildRef();

    waitBoard->setCommitted(solveBoard);
    Assert(!solveBoard->isCommitted());
    solveBoard->incSuspCount(waitBoard->getSuspCount()-1);

    if (!am.installScriptOutline(waitBoard->getScriptRef()))
      return 0;

    if (waitBoard->isWaitTop())
      return 1;

    am.currentThread->pushCont(waitBoard->getBodyPtr());
  }

  return 1;
}

inline
void SolveActor::clearResult(Board* bb) {
  if (OZ_isVariable(result))
    return;

  result = makeTaggedRef(newTaggedUVar(bb));
}

inline
void SolveActor::pushToLTQ(Thread * thr, Board * b) {
  if (localThreadQueue) {
    localThreadQueue->enqueue(thr);
  } else {
    Thread * ltq_thr = new Thread(b, PROPAGATOR_PRIORITY, this);
    localThreadQueue = new LocalThreadQueue(ltq_thr, thr);
    am.scheduleThread(ltq_thr, PROPAGATOR_PRIORITY);
  }
}

#endif  // __SOLVE_ICC_
