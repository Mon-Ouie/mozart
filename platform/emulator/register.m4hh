/* This may look like C code, but it is really -*- C++ -*-

  Hydra Project, DFKI Saarbruecken,
  Stuhlsatzenhausweg 3, D-66123 Saarbruecken, Phone (+49) 681 302-5312
  Author: popow,mehl,scheidhr
  Last modified: $Date$ from $Author$
  Version: $Revision$
  State: $State$

  ------------------------------------------------------------------------

  ****** Register Instructions: use m4 to minimize duplication

  */


/*
 * m4 macros to simplfy defining instructions,
 * that use registers
 */

changequote(XXX,XXX)

changequote(``,'')


define(M4INSTRONEREG,``''
       case INSTRUCTION($1X):
       ``define(``Reg1'',Xreg(``$''1))''{$2}

       case INSTRUCTION($1Y):
       ``define(``Reg1'',Yreg(``$''1))''{$2}

       case INSTRUCTION($1G):
       ``define(``Reg1'',Greg(``$''1))''{$2}

       ``undefine(``Reg1'')''
      )


define(M4INSTRTWOREGS,``''
       case INSTRUCTION($1XX):
       ``define(``Reg1'',Xreg(``$''1))'' ``define(``Reg2'',Xreg(``$''1))''{$2}
       case INSTRUCTION($1XY):
       ``define(``Reg1'',Xreg(``$''1))'' ``define(``Reg2'',Yreg(``$''1))''{$2}
       case INSTRUCTION($1XG):
       ``define(``Reg1'',Xreg(``$''1))'' ``define(``Reg2'',Greg(``$''1))''{$2}

       case INSTRUCTION($1YX):
       ``define(``Reg1'',Yreg(``$''1))'' ``define(``Reg2'',Xreg(``$''1))''{$2}
       case INSTRUCTION($1YY):
       ``define(``Reg1'',Yreg(``$''1))'' ``define(``Reg2'',Yreg(``$''1))''{$2}
       case INSTRUCTION($1YG):
       ``define(``Reg1'',Yreg(``$''1))'' ``define(``Reg2'',Greg(``$''1))''{$2}

       case INSTRUCTION($1GX):
       ``define(``Reg1'',Greg(``$''1))'' ``define(``Reg2'',Xreg(``$''1))''{$2}
       case INSTRUCTION($1GY):
       ``define(``Reg1'',Greg(``$''1))'' ``define(``Reg2'',Yreg(``$''1))''{$2}
       case INSTRUCTION($1GG):
       ``define(``Reg1'',Greg(``$''1))'' ``define(``Reg2'',Greg(``$''1))''{$2}

       ``undefine(``Reg1'')''
       ``undefine(``Reg2'')''
      )


// -------------------------------------------------------------------------
// CLASS: TERM: MOVE/UNIFY/CREATEVAR/...
// -------------------------------------------------------------------------

  M4INSTRTWOREGS( MOVE,
                ``
                  Reg2(getRegArg(PC+2)) = Reg1(getRegArg(PC+1));
                  DISPATCH(3);
                ''
                )


// move X[i] --> Y[j], X[k] --> Y[l]
case INSTRUCTION(MOVEMOVEXYXY):
    {
      Yreg(getRegArg(PC+2)) = Xreg(getRegArg(PC+1));
      Yreg(getRegArg(PC+4)) = Xreg(getRegArg(PC+3));
      DISPATCH(5);
    }

  // move Y[i] --> X[j], Y[k] --> X[l]
case INSTRUCTION(MOVEMOVEYXYX):
    {
      Xreg(getRegArg(PC+2)) = Yreg(getRegArg(PC+1));
      Xreg(getRegArg(PC+4)) = Yreg(getRegArg(PC+3));
      DISPATCH(5);
    }

  // move Y[i] --> X[j], X[k] --> Y[l]
case INSTRUCTION(MOVEMOVEYXXY):
    {
      Xreg(getRegArg(PC+2)) = Yreg(getRegArg(PC+1));
      Yreg(getRegArg(PC+4)) = Xreg(getRegArg(PC+3));
      DISPATCH(5);
    }

  // move X[i] --> Y[j], Y[k] --> X[l]
case INSTRUCTION(MOVEMOVEXYYX):
    {
      Yreg(getRegArg(PC+2)) = Xreg(getRegArg(PC+1));
      Xreg(getRegArg(PC+4)) = Yreg(getRegArg(PC+3));
      DISPATCH(5);
    }

  M4INSTRONEREG(CREATENAMEDVARIABLE,
    ``
    {
      int regIndex = getRegArg(PC+1);
      TaggedRef name   = getLiteralArg(PC+2);
      DebugCheck(&Reg1(0)!= &(e->toplevelVars[0]),
                 error("createNamedVar: e->toplevelVars expected"););
      TaggedRef newVar = createNamedVariable(regIndex,name,e);
      Y = e->toplevelVars;
      Reg1(regIndex) = newVar;
    }
    ''
    DISPATCH(3);
    )


#define MakeVar makeTaggedRef(newTaggedUVar(e->currentUVarPrototype))

case INSTRUCTION(CREATEVARIABLEX):
   {
     Xreg(getRegArg(PC+1)) = MakeVar;
     DISPATCH(2);
   }
case INSTRUCTION(CREATEVARIABLEY):
   {
     Yreg(getRegArg(PC+1)) = MakeVar;
     DISPATCH(2);
   }
case INSTRUCTION(CREATEVARIABLEG):
   {
     error("CREATEVARIABLEG: impossible");
     DISPATCH(2);
   }

case INSTRUCTION(CREATEVARIABLEMOVEX):
   {
     Xreg(getRegArg(PC+1)) = Xreg(getRegArg(PC+2)) = MakeVar;
     DISPATCH(3);
   }
case INSTRUCTION(CREATEVARIABLEMOVEY):
   {
     Yreg(getRegArg(PC+1)) = Xreg(getRegArg(PC+2)) = MakeVar;
     DISPATCH(3);
   }
case INSTRUCTION(CREATEVARIABLEMOVEG):
   {
     error("CREATEVARIABLEMOVEG: impossible");
     DISPATCH(3);
   }

#undef MakeVar


  M4INSTRTWOREGS(UNIFY,
               ``{
                 if ( !e->fastUnify(Reg1(getRegArg(PC+1)),
                                    Reg2(getRegArg(PC+2)),
                                    NOFLATGUARD())) {
                   SHALLOWFAIL;
                   HF_UNIFY("%s = %s failed\n",
                            Reg1(getRegArg(PC+1)),
                            Reg2(getRegArg(PC+2)),
                            "In instruction UNIFY\n"
                            );
                 }
               }''
               DISPATCH(3);
                 )


  M4INSTRONEREG( PUTSTRUCTURE,
               ``
                 STuple *stuple =
                   STuple::newSTuple(getLiteralArg(PC+1),getPosIntArg(PC+2));
                 TaggedRef term = makeTaggedSTuple(stuple);

                 Reg1(getRegArg(PC+3)) = term;
                 sPointer = stuple->getRef();

                 DISPATCH(4);''
               )


  case INSTRUCTION(PUTRECORDX): ONREG(PutRecord,X);
  case INSTRUCTION(PUTRECORDY): ONREG(PutRecord,Y);
  case INSTRUCTION(PUTRECORDG): ONREG(PutRecord,G);
         PutRecord:
          {
            TaggedRef label = getLiteralArg(PC+1);
            Arity *ff = (Arity *) getAdressArg(PC+2);
            SRecord *srecord = new SRecord(ff,label,NO,makeTaggedNULL());

            RegAccess(HelpReg,getRegArg(PC+3)) = makeTaggedSRecord(srecord);
            sPointer = srecord->getRef();

            DISPATCH(4);
          }

case INSTRUCTION(PUTCONSTANTX):
  case INSTRUCTION(PUTINTX):
     Xreg(getRegArg(PC+2)) = getTaggedArg(PC+1); DISPATCH(3);

case INSTRUCTION(PUTCONSTANTY):
  case INSTRUCTION(PUTINTY):
     Yreg(getRegArg(PC+2)) = getTaggedArg(PC+1); DISPATCH(3);

case INSTRUCTION(PUTCONSTANTG):
  case INSTRUCTION(PUTINTG):
     Greg(getRegArg(PC+2)) = getTaggedArg(PC+1); DISPATCH(3);

  M4INSTRONEREG( PUTLIST,
               ``{
                 LTuple *term = new LTuple();
                 Reg1(getRegArg(PC+1)) = makeTaggedLTuple(term);
                 sPointer = term->getRef();

               }''
               DISPATCH(2);
               )


  M4INSTRONEREG( SETVARIABLE,
               ``{
                 Reg reg = getRegArg(PC+1);
                 *sPointer = e->currentUVarPrototype;
                 Reg1(reg) = makeTaggedRef(sPointer++);
                 DISPATCH(2);
               }''
               )

  M4INSTRONEREG( SETVALUE,
               ``{
                 *sPointer++ = Reg1(getRegArg(PC+1));
                 DISPATCH(2);
               }''
               )


case INSTRUCTION(SETCONSTANT):
  case INSTRUCTION(SETINT):
    {
      *sPointer++ = getTaggedArg(PC+1);
      DISPATCH(2);
    }


case INSTRUCTION(SETVOID):
    {
      int n = getPosIntArg(PC+1);
      TaggedRef newVar = e->currentUVarPrototype;
      for (int i = 0; i < n; i++ ) {
        *sPointer++ = newVar;
      }
      DISPATCH(2);
    }


  M4INSTRONEREG( GETSTRUCTURE,
               ``{
                 TaggedRef label = getLiteralArg(PC+1);
                 int arity       = getPosIntArg(PC+2);

                 TaggedRef term = Reg1( getRegArg(PC+3) );
                 DEREF(term,termPtr,tag);

                 if (isAnyVar(term)) {
                   STuple *stuple = STuple::newSTuple(label,arity);

                   if (isCVar(term)) {
                     if (tagged2CVar(term)->unifyOutline(termPtr, term, NULL,
                                                         makeTaggedSTuple(stuple),
                                                         NOFLATGUARD())) {
                       DISPATCH(4);
                     }
                   } else {

                     e->bindToNonvar(termPtr,term,makeTaggedSTuple(stuple),
                                     NOFLATGUARD());

                     sPointer = stuple->getRef();
                     SetWriteMode;
                     DISPATCH(4);
                   }
                 }

                 if (isSTuple(tag) &&
                     tagged2STuple(term)->compareSortAndSize(label,arity)) {
                   sPointer = tagged2STuple(term)->getRef();
                   SetReadMode;
                   DISPATCH(4);
                 }

                 SHALLOWFAIL;
                 HF_UNIFY("%s(...) = %s failed\n",
                          getLiteralArg(PC+1),
                          Reg1(getRegArg(PC+3)),
                          "In instruction GETSTRUCTURE\n"
                          );
               }''
               )


  case INSTRUCTION(GETRECORDX): ONREG(GetRecord,X);
  case INSTRUCTION(GETRECORDY): ONREG(GetRecord,Y);
  case INSTRUCTION(GETRECORDG): ONREG(GetRecord,G);
      GetRecord:
         {
           TaggedRef label = getLiteralArg(PC+1);
           Arity *ff = (Arity *) getAdressArg(PC+2);

           TaggedRef term = RegAccess(HelpReg,getRegArg(PC+3));
           DEREF(term,termPtr,tag);

           if (isAnyVar(term)) {
             if(isCVar(term) == OK){
               // fill w/unb. var.
               SRecord *srecord = new SRecord(ff,label,OK,am.currentUVarPrototype);
               TaggedRef srecordRef=makeTaggedSRecord(srecord);
               if(tagged2CVar(term)->unifyOutline(termPtr, term,
                                                  &srecordRef, srecordRef,NOFLATGUARD())) {
                 sPointer = srecord->getRef();
                 SetReadMode;
                 DISPATCH(4);
               }
             } else {
               // do not initialize args
               SRecord *srecord = new SRecord(ff,label,NO,makeTaggedNULL());
               e->bindToNonvar(termPtr, term,makeTaggedSRecord(srecord),NOFLATGUARD());

               sPointer = srecord->getRef();
               SetWriteMode;
               DISPATCH(4);
             }
           }

           if (isSRecord(tag) &&
               tagged2SRecord(term)->compareSortAndArity(label,ff)) {
             sPointer = tagged2SRecord(term)->getRef();
             SetReadMode;
             DISPATCH(4);
           }

           SHALLOWFAIL;
           HF_UNIFY("%s(..:.. ...) = %s failed\n",
                    getLiteralArg(PC+1),
                    RegAccess(HelpReg,getRegArg(PC+3)),
                    "In instruction GETRECORD\n"
                    );
         }


  M4INSTRONEREG(TESTCONST,
    ``{
        TaggedRef term = Reg1(getRegArg(PC+1));
        TaggedRef atm  = getLiteralArg(PC+2);

        DEREF(term,termPtr,tag);

        if (sameLiteral(term,atm)) {
          JUMP( getLabelArg(PC+3) );
        }

        if (isNotCVar(term) ||
            isCVar(term) && tagged2CVar(term)->valid(atm)) {
          suspendOnVar(makeTaggedRef(termPtr),getPosIntArg(PC+5),
                       CBB,PC,X,Y,G,GET_CURRENT_PRIORITY());
          if (e->currentThread->getCompMode() == ALLSEQMODE) {
            e->currentThread=0;
            goto LBLstart;
          }
          goto LBLpopTask;
        }

        JUMP( getLabelArg(PC+4) );
    }''
    )

  M4INSTRONEREG(TESTNUMBER,
    ``{
        TaggedRef term = Reg1(getRegArg(PC+1));
        TaggedRef i = getNumberArg(PC+2);

        DEREF(term,termPtr,tag);

        /* optimized for integer case */
        if (isSmallInt(tag)) {
          JUMP( getLabelArg(sameSmallInt(term,i) ? PC+3 : PC+4) );
        }

        if ( tag == tagTypeOf(i) && numberEq(i,term)) {
          JUMP( getLabelArg(PC+3) );
        }

        if (isNotCVar(term) ||
            isCVar(term) && tagged2CVar(term)->valid(i)) {
          suspendOnVar(makeTaggedRef(termPtr),getPosIntArg(PC+5),
                       CBB,PC,X,Y,G,GET_CURRENT_PRIORITY());
          if (e->currentThread->getCompMode() == ALLSEQMODE) {
            e->currentThread=0;
            goto LBLstart;
          }
          goto LBLpopTask;
        }

        JUMP( getLabelArg(PC+4) );
    }''
    )

  M4INSTRONEREG( GETCONSTANT,
               ``{
                 TaggedRef atm = getLiteralArg(PC+1);

                 TaggedRef term = Reg1( getRegArg(PC+2) );
                 DEREF(term,termPtr,tag);

                 if (isNotCVar(tag)) {
                   e->bindToNonvar(termPtr, term, atm, NOFLATGUARD());
                   DISPATCH(3);
                 }

                 if ( isLiteral(tag) && sameLiteral(term,atm) ) {
                   DISPATCH(3);
                 }

                 if (isCVar(term)) {
                   if (tagged2CVar(term)->unifyOutline(termPtr,term,NULL,
                                                       atm,NOFLATGUARD())) {
                     DISPATCH(3);
                   }
                   term = *termPtr;  // Note: 'term' may be disposed
                 }

                 SHALLOWFAIL;
                 HF_UNIFY("%s = %s failed\n",
                          Reg1(getRegArg(PC+2)),
                          getLiteralArg(PC+1),
                          "In instruction GETCONSTANT\n"
                          );
               }''
               )


  M4INSTRONEREG( GETINT,
               ``{
                 TaggedRef i = getNumberArg(PC+1);
                 TaggedRef term = Reg1(getRegArg(PC+2));
                 DEREF(term,termPtr,tag);

                 if (isNotCVar(tag)) {
                   e->bindToNonvar(termPtr, term, i, NOFLATGUARD());
                   DISPATCH(3);
                 }

                 if ( (tag == tagTypeOf(i)) && numberEq(term,i)) {
                   DISPATCH(3);
                 }

                 if (isCVar(term)) {
                   if (tagged2CVar(term)->unifyOutline(termPtr,term,NULL,
                                                       i,NOFLATGUARD())) {
                     DISPATCH(3);
                   }
                   term = *termPtr;  // Note: 'term' may be disposed
                 }

                 SHALLOWFAIL;
                 HF_UNIFY("%s = %s failed\n",
                          Reg1(getRegArg(PC+2)),
                          getNumberArg(PC+1),
                          "In instruction GETINT\n"
                          );
               }''
               )

/* getListValVar(N,R,M) == getList(X[N]) unifyVal(R), unifyVar(X[M]) */
  M4INSTRONEREG(GETLISTVALVAR,
                ``{
                 Reg reg1 = getRegArg(PC+1);
                 Reg reg2 = getRegArg(PC+2);
                 Reg reg3 = getRegArg(PC+3);


                 TaggedRef term = Xreg(reg1);
                 DEREF(term,termPtr,tag);

                 if(isAnyVar(term)) {
                   LTuple *ltuple = new LTuple(Reg1(reg2),e->currentUVarPrototype);

                   if (isCVar(term) == OK) {
                     if (tagged2CVar(term)->unifyOutline(termPtr, term, NULL,
                                                         makeTaggedLTuple(ltuple),
                                                         NOFLATGUARD())) {
                       DISPATCH(4);
                     }
                   } else {
                     e->bindToNonvar(termPtr, term, makeTaggedLTuple(ltuple),
                                     NOFLATGUARD());
                     Xreg(reg3) = makeTaggedRef(ltuple->getRef()+1);

                     DISPATCH(4);
                   }
                 }

                 if (isLTuple(term)) {
                   TaggedRef *argg = tagged2LTuple(term)->getRef();
                   if (e->fastUnify(Reg1(reg2),makeTaggedRef(argg),
                                    NOFLATGUARD())) {
                     Xreg(reg3) = tagged2NonVariable(argg+1);

                     DISPATCH(4);
                   }
                 }

                 SHALLOWFAIL;
                 HF_UNIFY("%s = %s|_ failed\n",
                          Xreg(getRegArg(PC+1)),
                          Reg1(getRegArg(PC+2)),
                          "In instruction GETLISTVALVAR\n"
                          );
               }''
               )


  M4INSTRONEREG( GETLIST,
               ``{
                 Reg reg = getRegArg(PC+1);

                 register TaggedRef term = Reg1(reg);
                 DEREF(term,termPtr,tag);

                 if(isAnyVar(term)) {
                   LTuple *ltuple = new LTuple();
                   if (isCVar(term) == OK) {
                     if(tagged2CVar(term)->unifyOutline(termPtr, term, NULL,
                                                        makeTaggedLTuple(ltuple),
                                                        NOFLATGUARD())) {
                       DISPATCH(2);
                     }
                     term = *termPtr;  // Note: 'term' may be disposed
                   } else {
                     e->bindToNonvar(termPtr, term, makeTaggedLTuple(ltuple),
                                     NOFLATGUARD());
                     sPointer = ltuple->getRef();
                     SetWriteMode;
                     DISPATCH(2);
                   }
                 }

                 if (isLTuple(term)) {
                   sPointer = tagged2LTuple(term)->getRef();
                   SetReadMode;
                   DISPATCH(2);
                 }


                 SHALLOWFAIL;
                 HF_UNIFY("%s = _|_ failed\n",
                          Reg1(getRegArg(PC+1)),
                          makeTaggedNULL(),
                          "In instruction GETLIST\n"
                          );
               }''
               )


  /* a unifyVariable in read mode */
  M4INSTRONEREG( GETVARIABLE,
               ``{
                 Reg1(getRegArg(PC+1)) = tagged2NonVariable(sPointer);
                 sPointer++;
                 DISPATCH(2);
               }''
               )


  M4INSTRTWOREGS( GETVARVAR,
               ``{
                 Reg1(getRegArg(PC+1)) = tagged2NonVariable(sPointer);
                 Reg2(getRegArg(PC+2)) = tagged2NonVariable(sPointer+1);
                 sPointer += 2;
                 DISPATCH(3);
               }''
               )


  /* a unify void in read case mode */
case INSTRUCTION(GETVOID):
    {
      sPointer += getPosIntArg(PC+1);
      DISPATCH(2);
    }


  M4INSTRONEREG( UNIFYVARIABLE,
               ``{
                 if(InWriteMode) {
                   Reg reg = getRegArg(PC+1);
                   TaggedRef *sp = GetSPointerWrite(sPointer);
                   *sp = e->currentUVarPrototype;
                   Reg1(reg) = makeTaggedRef(sp);
                 } else {
                   Reg1(getRegArg(PC+1)) = tagged2NonVariable(sPointer);
                 }
                 sPointer++;
                 DISPATCH(2);
               }''
               )


  M4INSTRONEREG( UNIFYVALUE,
               ``{
                 Reg reg = getRegArg(PC+1);

                 if(InWriteMode) {
                   TaggedRef *sp = GetSPointerWrite(sPointer);
                   *sp = Reg1(reg);
                   sPointer++;
                   DISPATCH(2);
                 } else {
                   if (e->fastUnify(Reg1(reg), makeTaggedRef(sPointer++),NOFLATGUARD()) ) {
                     DISPATCH(2);
                   }
                   SHALLOWFAIL;
                   HF_UNIFY("%s = %s failed\n",
                            *(sPointer-1),
                            Reg1(reg),
                            "In instruction UNIFYVALUE\n"
                            );
                 }
               }''
               )



  case INSTRUCTION(UNIFYVALVARXX): ONREG2(UnifyValVar,X,X);
  case INSTRUCTION(UNIFYVALVARXY): ONREG2(UnifyValVar,X,Y);
  case INSTRUCTION(UNIFYVALVARXG): ONREG2(UnifyValVar,X,G);
  case INSTRUCTION(UNIFYVALVARYX): ONREG2(UnifyValVar,Y,X);
  case INSTRUCTION(UNIFYVALVARYY): ONREG2(UnifyValVar,Y,Y);
  case INSTRUCTION(UNIFYVALVARYG): ONREG2(UnifyValVar,Y,G);
  case INSTRUCTION(UNIFYVALVARGX): ONREG2(UnifyValVar,G,X);
  case INSTRUCTION(UNIFYVALVARGY): ONREG2(UnifyValVar,G,Y);
  case INSTRUCTION(UNIFYVALVARGG): ONREG2(UnifyValVar,G,G);
   UnifyValVar:
     {
       Reg reg = getRegArg(PC+1);

       if (InWriteMode) {
         TaggedRef *sp = GetSPointerWrite(sPointer);
         *sp = RegAccess(HelpReg,reg);

         *(sp+1) = e->currentUVarPrototype;
         RegAccess(HelpReg2,getRegArg(PC+2)) = makeTaggedRef(sp+1);

         sPointer += 2;
         DISPATCH(3);
       }
       if ( !e->fastUnify(RegAccess(HelpReg,reg), makeTaggedRef(sPointer),
                          NOFLATGUARD()) ) {
         SHALLOWFAIL;
         HF_UNIFY("%s = %s failed\n",
                  *sPointer,
                  RegAccess(HelpReg,reg),
                  "In instruction UNIFYVALVAR\n");
       }

       RegAccess(HelpReg2,getRegArg(PC+2)) = tagged2NonVariable(sPointer+1);

       sPointer += 2;
       DISPATCH(3);
     }


case INSTRUCTION(UNIFYCONSTANT):
     {
       if (InWriteMode) {
         TaggedRef *sp = GetSPointerWrite(sPointer);
         *sp = getTaggedArg(PC+1);
         sPointer++;
         DISPATCH(2);
       }

       TaggedRef atm = getLiteralArg(PC+1);

       /* code adapted from GETCONSTANT */
       TaggedRef *termPtr = sPointer;
       sPointer++;
       DEREFPTR(term,termPtr,tag);

       if (isNotCVar(tag)) {
         e->bindToNonvar(termPtr, term, atm, NOFLATGUARD());
         DISPATCH(2);
       }

       if ( isLiteral(tag) && sameLiteral(term,atm) ) {
         DISPATCH(2);
       }

       if (isCVar(term)) {
         if (tagged2CVar(term)->unifyOutline(termPtr,term,NULL,
                                             atm,NOFLATGUARD())) {
           DISPATCH(2);
         }
         term = *termPtr;  // Note: 'term' may be disposed
       }

       SHALLOWFAIL;
       HF_UNIFY("%s = %s failed\n",
                 getTaggedArg(PC+1),
                 *(sPointer-1),
                 "In instruction UNIFYCONSTANT\n"
                 );
     }

  case INSTRUCTION(UNIFYINT):
    {
      if (InWriteMode) {
        TaggedRef *sp = GetSPointerWrite(sPointer);
        *sp = getTaggedArg(PC+1);
        sPointer++;
        DISPATCH(2);
      }

      TaggedRef i = getNumberArg(PC+1);
      /* code adapted from GETCONSTANT */
      TaggedRef *termPtr = sPointer;
      sPointer++;
      DEREFPTR(term,termPtr,tag);

      if (isNotCVar(tag)) {
        e->bindToNonvar(termPtr, term, i, NOFLATGUARD());
        DISPATCH(2);
      }

      if ( (tag == tagTypeOf(i)) && numberEq(term,i)) {
        DISPATCH(2);
      }

      if (isCVar(term)) {
        if (tagged2CVar(term)->unifyOutline(termPtr,term,NULL,
                                            i,NOFLATGUARD())) {
          DISPATCH(2);
        }
        term = *termPtr;  // Note: 'term' may be disposed
      }

      SHALLOWFAIL;
      HF_UNIFY("%s = %s failed\n",
               getTaggedArg(PC+1),
               *(sPointer-1),
               "In instruction UNIFYINT\n"
               );
    }


case INSTRUCTION(UNIFYVOID):
    {
      int n = getPosIntArg(PC+1);
      if (InWriteMode) {
        TaggedRef newVar = e->currentUVarPrototype;
        TaggedRef *sp = GetSPointerWrite(sPointer);
        for (int i = n-1; i >=0; i-- ) {
          *sp++ = newVar;
        }
      }
      sPointer += n;
      DISPATCH(2);
    }

  M4INSTRONEREG(SWITCHONTERM,
    {
      TaggedRef val     = Reg1(getRegArg(PC+1));
      IHashTable *table = (IHashTable *) getAdressArg(PC+2);

      DoSwitchOnTerm(val,table);
    })

  M4INSTRONEREG( BRANCHONVAR,
               ``
               TaggedRef term = Reg1(getRegArg(PC+1));
               DEREF(term,_1,_2);
               if (isAnyVar(term)) {
                 JUMP( getLabelArg(PC+2) );
               }
               DISPATCH(3);
               ''
               )

  M4INSTRONEREG( BRANCHONNONVAR,
               ``
               TaggedRef term = Reg1(getRegArg(PC+1));
               DEREF(term,_1,_2);
               if (!isAnyVar(term)) {
                 JUMP( getLabelArg(PC+2) );
               }
               DISPATCH(3);
               ''
               )
