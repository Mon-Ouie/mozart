/*
 *  Authors:
 *    Kostja Popow (popow@ps.uni-sb.de)
 *    Christian Schulte <schulte@ps.uni-sb.de>
 *
 *  Contributors:
 *    Michael Mehl (mehl@dfki.de)
 *
 *  Copyright:
 *    Organization or Person (Year(s))
 *
 *  Last change:
 *    $Date$ by $Author$
 *    $Revision$
 *
 *  This file is part of Mozart, an implementation
 *  of Oz 3:
 *     http://www.mozart-oz.org
 *
 *  See the file "LICENSE" or
 *     http://www.mozart-oz.org/LICENSE.html
 *  for information on usage and redistribution
 *  of this file, and for a DISCLAIMER OF ALL
 *  WARRANTIES.
 *
 */

// Solver

#ifndef __BOARD_ICC_
#define __BOARD_ICC_

#if !defined(OUTLINE) && defined(INTERFACE)
#pragma interface
#endif

#include "susplist.hh"
#include "value.hh"

#ifdef OUTLINE
#define inline
#endif

inline
void Board::addSuspension(Suspension susp) {
  suspList = new SuspList(susp, suspList);
}

inline
void Board::mergeNonMono(Board *bb) {
  // merge nonmonotonic susp lists
  if (nonMonoSuspList) {
    // Merge in current solve board but not elsewhere
    if (!bb->isRoot()) {
      // merge nonmonotonic susp list to another solve space

      if (bb->nonMonoSuspList) {
        bb->mergeNonMonoSuspListWith(nonMonoSuspList);
        setNonMonoSuspList(NULL);
      } else {
        bb->setNonMonoSuspList(nonMonoSuspList);
      }
    } else {
      // merge nonmonotinic susp list to a non-solve space
      oz_solve_scheduleNonMonoSuspList(this);
    }
  }
}

inline
int Board::commit(int left, int right) {
  ozstat.incSolveAlt();

  Assert(bag && bag->getDist()->isAlive());

  return bag->getDist()->commit(this,left,right);

}

inline
void Board::patchChoiceResult(int i) {
  SRecord *stuple = SRecord::newSRecord(AtomAlt, 1);
  stuple->setArg(0, makeTaggedSmallInt(i));
  result = makeTaggedSRecord(stuple);
}

inline
void Board::clearResult() {
  if (OZ_isVariable(result))
    return;

  result = oz_newVar(getParent());
}

inline
Distributor * Board::getDistributor(void) {
  bag = bag->clean();

  if (!bag)
    return (Distributor *) 0;

  // Find unary distributor, if any
  for (DistBag * db = bag; db; db=db->getNext()) {
    if (db->getDist()->getAlternatives() == 1)
      return db->getDist();
  }

  return bag->getDist();
}

#ifdef DEBUG_THREADCOUNT
extern int existingLTQs;
#endif


#ifdef OUTLINE
#undef inline
#endif

#endif
