//
// Author:
//   Leif Kornstaedt <kornstae@ps.uni-sb.de>
//
// Copyright:
//   Leif Kornstaedt, 1996-1998
//
// Last change:
//   $Date$ by $Author$
//   $Revision$
//
// This file is part of Mozart, an implementation of Oz 3:
//   $MOZARTURL$
//
// See the file "LICENSE" or
//   $LICENSEURL$
// for information on usage and redistribution
// of this file, and for a DISCLAIMER OF ALL
// WARRANTIES.
//

// For use with C++ scanner classes generated by GNU Flex Version 2.5.3

#include <FlexLexer.h>

#include "oz.h"

#define YY_BUF_SIZE 16384
#define YY_END_OF_BUFFER_CHAR 0

typedef unsigned int yy_size_t;

struct yy_buffer_state {
  FILE *yy_input_file;
  char *yy_ch_buf;
  char *yy_buf_pos;
  yy_size_t yy_buf_size;
  int yy_n_chars;
  int yy_is_our_buffer;
  int yy_is_interactive;
  int yy_at_bol;
  int yy_fill_buffer;

  int yy_buffer_status;
#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
#define YY_BUFFER_EOF_PENDING 2
};

#define OZ_declareBufferArg(ARG,VAR)                    \
 OZ_declareForeignPointerArg(ARG,_Tmp);                 \
 yy_buffer_state *VAR = (yy_buffer_state *) _Tmp;

static void init_buffer(yy_buffer_state *p) {
  p->yy_buf_pos = &p->yy_ch_buf[0];
  p->yy_is_our_buffer = 1;
  p->yy_is_interactive = 0;
  p->yy_at_bol = 1;
  p->yy_buffer_status = YY_BUFFER_NEW;
}

OZ_C_proc_begin(gump_createFromFile, 2)
{
  OZ_declareVirtualStringArg(0, file);
  OZ_declareArg(1, res);
  FILE *f = fopen(file, "rb");
  if (f == NULL)
    return OZ_unify(OZ_getCArg(1), OZ_int(0));

  yy_buffer_state *p = new yy_buffer_state;
  p->yy_input_file = f;
  p->yy_ch_buf = new char[YY_BUF_SIZE + 2];
  p->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
  p->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
  p->yy_buf_size = YY_BUF_SIZE;
  p->yy_n_chars = 0;
  p->yy_fill_buffer = 1;
  init_buffer(p);

  return OZ_unify(res, OZ_makeForeignPointer(p));
}
OZ_C_proc_end

OZ_C_proc_begin(gump_createFromVirtualString, 2)
{
  OZ_declareVirtualStringArg(0, s);
  OZ_declareArg(1, res);
  yy_size_t size = strlen(s);

  yy_buffer_state *p = new yy_buffer_state;
  p->yy_input_file = 0;
  p->yy_ch_buf = new char[size + 2];
  strcpy(p->yy_ch_buf, s);
  p->yy_ch_buf[size] = YY_END_OF_BUFFER_CHAR;
  p->yy_ch_buf[size + 1] = YY_END_OF_BUFFER_CHAR;
  p->yy_buf_size = size;
  p->yy_n_chars = size;
  p->yy_fill_buffer = 0;
  init_buffer(p);

  return OZ_unify(res, OZ_makeForeignPointer(p));
}
OZ_C_proc_end

OZ_C_proc_begin(gump_setInteractive, 2)
{
  OZ_declareBufferArg(0, p);
  OZ_declareIntArg(1, b);
  p->yy_is_interactive = b;
  return PROCEED;
}
OZ_C_proc_end

OZ_C_proc_begin(gump_getInteractive, 2)
{
  OZ_declareBufferArg(0, p);
  return OZ_unify(OZ_getCArg(1), OZ_int(p->yy_is_interactive));
}
OZ_C_proc_end

OZ_C_proc_begin(gump_setBOL, 2)
{
  OZ_declareBufferArg(0, p);
  OZ_declareIntArg(1, b);
  p->yy_at_bol = b;
  return PROCEED;
}
OZ_C_proc_end

OZ_C_proc_begin(gump_getBOL, 2)
{
  OZ_declareBufferArg(0, p);
  return OZ_unify(OZ_getCArg(1), OZ_int(p->yy_at_bol));
}
OZ_C_proc_end

OZ_C_proc_begin(gump_close, 1)
{
  // Must never be invoked twice on the same foreign pointer!
  OZ_declareBufferArg(0, p);

  if (p->yy_input_file)
    fclose(p->yy_input_file);
  if (p->yy_is_our_buffer)
    delete[] p->yy_ch_buf;
  delete p;

  return PROCEED;
}
OZ_C_proc_end
