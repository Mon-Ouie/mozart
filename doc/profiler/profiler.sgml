<!doctype book system "ozdoc.dtd" [
<!-- $Id$ -->

<!-- Extension to the DTD -->
<!entity % proglang.values.local "|sh">
<!ENTITY % p.mix.local "|Em">
<!ELEMENT Em - - (#PCDATA)>
<!ENTITY emdash PI "emdash">
<!ENTITY endash PI "endash">
<!entity ie PI "ie">
<!entity eg PI "eg">
<!-- Abbreviations -->
<!-- Processing Instructions -->

]>

<book proglang=oz>
  <front>
    <meta name=ozversion value="3.0">
    <meta name=status value=draft>
    <meta name="proglang.mode" arg1="sh" arg2="shell-script-mode">
    <title/The Mozart Profiler/
    <author.extern to="author.db" key="Denys.Duchier">
    <author.extern to="author.db" key="Benjamin.Lorenz">
    <author.extern to="author.db" key="Ralf.Scheidhauer">
    <abstract>
      This manual describes the profiler for the Mozart programming
      system. With its help you can optimize your Oz applications.  It
      mainly counts procedure applications and measures their memory
      consumption, presenting its calculations using nice,
      clickable bar charts.
    </abstract>
  <body>
    <chapter>
      <title/What Is Profiling/
      <p>Once your application works, you may wish to optimize it for
speed and memory consumption.  For this, you need to identify the
parts of your application that may significantly benefit from such
optimizations; it would be pointless to optimize a procedure that is
called only once.  Profiling automatically instruments your program to
gather statistical data on procedure invocations and memory
allocation.</p>
      <p>The profiler collects information in a per procedure basis.
This information consists of the following quantities:
<list>
          <entry class=bold/head/
          <item/heap memory allocated by the procedure/
          <entry/calls/
          <item/how many times the procedure was called/
          <entry/closures/
          <item/how many times the corresponding closure was created/
          <entry/samples/
          <item/statistical estimation of the time spent in the
procedure. This works as follows: every 10ms a signal is delivered and
the emulator increases the <q/samples/ counter of the procedure
currently executing./
        </list></p>
    </chapter>

    <chapter>
      <title/How To Compile For Profiling/
      <p>In order to gather the profiling information, your code has
to be instrumented with additional profiling code.  This code is
automatically inserted by the compiler when it is invoked with the
<code proglang=sh/--profiler/ option.  This option can also be
abbreviated <code proglang=sh/-p/.  There is however an unfortunate
limitation when compiling code for profiling: tail-call optimization
is turned off (except for self applications).</p>
      <p>As an example, let's consider the following rather pointless
application below.  I call it <q/The 3 Little Piggies/, and it does
nothing but waste time and memory:
<code.extern display to="piggies.oz">
The application can be compiled for profiling as follows:
<code display proglang=sh/ozc -px piggies.oz/
</p>
    </chapter>

    <chapter>
      <title/How To Invoke The Profiler/
      <p>The profiler interface is integrated in the Oz debugger
tool <code proglang=sh/ozd/ and can be invoked using the <code/-p/
option.  We can profile <q/The 3 Little Piggies/ as follows:
<code display proglang=sh/ozd -p piggies -- --size 1000 --times 100/
Note how the double dash separates <code proglang=sh/ozd/'s arguments
from the application's arguments.  Shortly thereafter, the window
shown below pops up:
<picture.choice display>
          <picture.extern to="prof1.gif" type="gif">
        </picture.choice>
Now click <em/Update/ and a summary of procedure calls is displayed.
We learn that the <code/SecondPiggy/ is called 100 times and the
<code/ThirdPiggy/ 10000 times (&ie; 100*100).
<picture.choice display>
          <picture.extern to="prof2.gif" type="gif">
        </picture.choice>
The <code/FirstPiggy/ is not shown by default because it is called
only once.  Let's now select a different <em/Sort By/ (the menu button
on the right): we choose <em/heap/ to display the memory allocation
profile.  From this we verify &eg; that <code/ThirdPiggy/ allocates
about 100 times more memory as <code/SecondPiggy/, which is as it
should be since it is called 100 times more and allocates the same
large list.
<picture.choice display>
          <picture.extern to="prof3.gif" type="gif">
        </picture.choice>
    </chapter>

    <chapter>
      <title/How To Interpret The Results/
    </chapter>

    <chapter>
      <title/Command Line Options/
      <p>If you have created an Oz application which you normally start
from the shell as follows:
<code display/Foo ?{Args} ... /
Then you can run it under control of the Oz profiler by using the
following command instead:
<code display/ozd -p Foo -- ?{Args} .../
Any Oz application can be run in the profiler, but you only get the
full benefit of the profiling interface when the code being executed
was compiled with the <code/-p/ option to include profiling
instrumentation code.  The profiler and the debugger share the same
interface.</p>
      <p>The double dash <code/--/ separates the arguments intended for
<code/ozd/ from those intended for the application being run under the
profiler.
<list>
          <entry/<code/--help/, <code/-h/, <code/-?//
          <item/Display information on legal options, then exit/

          <entry/<code/-p/, <code/--profiler/, <code/--mode=profiler//
          <item/You must supply this option in order to start the profiler;
otherwise the debugger is started instead (see
<ptr.extern to="ozdoc:tools" key="chapter.debugger">)./

          <entry/<code/-g/, <code/--debugger/, <code/--mode=debugger//
          <item/This is the default option: it starts the debugger
(see <ptr.extern to="ozdoc:tools" key="chapter.debugger"
>). As mentioned above, in order to
actually start the profiler, you must supply the <code/-p/ option./

          <entry/<code/-E/, <code/--(no)useemacs//
          <item/Starts a subordinate Emacs process.  This will be used to
display the source code corresponding to the profile data being
examined./

          <entry/<code/--emacs=?{FILE}//
          <item/Specifies the Emacs binary to run for option <code/-E/.
The default is <var env/$OZEMACS/ if set, else <file/emacs/./
        </list></p>
    </chapter>

    <chapter>
      <title/How To Profile In The OPI/
    </chapter>
</book>

<!--
Local Variables:
mode: sgml
mode: auto-fill
sgml-default-dtd-file: "book.ced"
sgml-auto-activate-dtd: t
adaptive-fill-mode: nil
End:
-->
