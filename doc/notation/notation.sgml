<!DOCTYPE Book SYSTEM "ozdoc.dtd" [

<!-- Extension to the DTD -->
<!ENTITY % input.local.2 SYSTEM "notation.extra">
<!ENTITY % p.mix.local "|Rewrite">
<!ENTITY % proglang.values.local "|fundamental">
<!ENTITY % author.class "author|author.extern|comic">
<!ENTITY % picture.element "picture|picture.extern|picture.choice">
<!ELEMENT comic - O (%picture.element;)>

<!-- Abbreviations -->
<!ENTITY amp "&">
<!ENTITY lt "<">
<!ENTITY gt ">">

<!-- Processing Instructions -->
<!ENTITY ellipsis PI "ellipsis">
<!ENTITY nbsp PI "nbsp">
<!ENTITY eg PI "eg">
<!ENTITY ie PI "ie">
<!ENTITY emdash PI "emdash">

]>

<Book proglang=oz>
  <Front>
    <Meta name="html.split" value="chapter.intro">
    <Meta name="html.split" value="chapter.lexical">
    <Meta name="html.split" value="chapter.context-free">
    <Meta name="html.split" value="chapter.core">
    <Meta name="html.split" value="chapter.translation">
    <Meta name="html.split.bib" value="">

    <Meta name="proglang.mode" arg1="fundamental" arg2="fundamental-mode">

    <Meta name=ozversion value="3.0">
    <Meta name=status value=draft>
    <Title/The Oz Notation/
    <Author.Extern to="author.db" key="Martin.Henz">
    <Author.Extern to="author.db" key="Leif.Kornstaedt">
    <Comic>
      <Picture.Choice>
	<Picture.Extern to="notation.gif" type=gif>
      </Picture.Choice>
    <Abstract>
      Oz is a concurrent language providing for functional, object-oriented,
      and constraint programming.  This document defines how Oz program text
      is transformed into an Oz Core program.  Oz Core is a sublanguage of Oz
      designed to minimize syntactic complexity.  Oz Core serves as the base
      for the definition of the semantics of Oz.
    <P>
      Technically, Oz Core allows to use several programming paradigms,
      including functional, constraint and object-oriented programming.
      Being a purely relational language, however, Oz Core does not
      provide easy notational access to programming methods from these
      paradigms, making it hard to fully exploit the capacities of the
      language.
    <P>
      It is such ergonomic considerations that lead to the development
      of the Oz Notation, where syntactic extensions provide convenient
      constructs for functional and object-oriented programming.
      The semantics of these extensions is defined in this document
      by their stepwise translation to Oz Core.
    </Abstract>
  <Body>
    <Chapter id="chapter.intro">
      <Title/Introduction/
      <P>
	This report defines how Oz program text, which is a sequence
	of characters, is transformed into an Oz Core program.  This
	transformation is performed in three steps.
	<List enum>
	  <Entry/Lexical Syntax/
	  <Item>
	    First, a given program text is transformed into a sequence of
	    words.  Each word represents a sequence of tokens.  We call this
	    process <Def/tokenizing/.
	  <Entry/Context-free Syntax/
	  <Item>
	    The resulting sequence of tokens is transformed into a parse tree.
	    We call this process <Def/parsing/, and the resulting parse tree
	    <Def/program/.
	  <Entry/Core Programs/
	  <Item>
	    The program is translated to a Core program, eliminating a number
	    of abbreviations and nesting.
	</List>
      <P>
	At each step, errors may occur.  A text represents an Oz program if
	it can be tokenized and parsed into a program which can be translated
	without error into a Core program.
      <Para class=apropos><Title/Meta Notation/
	In a document like this one, it is helpful to make use of notational
	conventions in order to provide for concise and precise descriptions.
      <Section>
	<Title/Fonts/
	<P>
	  We make use of fonts to distinguish the different kinds of symbols
	  occurring in this document:
	  <Table>
	    <TR>
	      <TH/Meaning/
	      <TH/Examples/
	    <TR>
	      <TD/terminal or nonterminal symbol/
	      <TD/?={variable}, ?={statement}/
	    <TR>
	      <TD/keyword/
	      <TD/<<local>>, <<skip>>/
	  </Table>
      <Section>
	<Title/Regular Expressions and Context-Free Grammars/
	<P>
	  Regular expressions and context free grammars describe
	  sets of words.  We use the following notation to describe
	  one such set in terms of others (in increasing order of
	  precedence):
	  <Table>
	    <TR>
	      <TH/Notation/
	      <TH/Meaning/
	    <TR>
	      <TD/<Math/\epsilon//
	      <TD/singleton containing the empty word/
	    <TR>
	      <TD/(<Math/w/)/
	      <TD/grouping of regular expressions/
	    <TR>
	      <TD/[&nbsp;<Math/w/&nbsp;]/
	      <TD/union of <Math/\epsilon/ with the set of words&nbsp;<Math/w//
	    <TR>
	      <TD/{&nbsp;<Math/w/&nbsp;}/
	      <TD/set of words containing all concatenations of zero or
		more elements of&nbsp;<Math/w//
	    <TR>
	      <TD/{&nbsp;<Math/w/&nbsp;}+/
	      <TD/set of words containing all concatenations of one or
		more elements of&nbsp;<Math/w//
	    <TR>
	      <TD/<Math/w_1/&nbsp;<Math/w_2//
	      <TD/set of words containing all concatentations of an element
		of&nbsp;<Math/w_1/ with an element of&nbsp;<Math/w_2//
	    <TR>
	      <TD/<Math/w_1/&nbsp;|&nbsp;<Math/w_2//
	      <TD/union of <Math/w_1/ and&nbsp;<Math/w_2//
	    <TR>
	      <TD/<Math/w_1/&nbsp;-&nbsp;<Math/w_2//
	      <TD/difference of <Math/w_1/ and&nbsp;<Math/w_2//
	  </Table>
    <Chapter id="chapter.lexical" proglang=fundamental>
      <Title/Lexical Syntax/
      <P>
	A <Def/program text/ is a sequence of <Def/characters/ represented by
	integers following ISO&nbsp;8859-1&nbsp;<Ptr to="ISO_8859_1">, also
	called <Q/Latin&nbsp;1/.  In this section, we describe how such a
	sequence is split into a sequence of <Def/words/.  Each word
	represents zero or more <Def/tokens/ such that the result is a
	sequence of tokens.  We call this process <Def/tokenization/.
	In this section, we give regular expressions for the different kinds
	of words and describe the resulting tokens.
      <Para class=apropos><Title/Resolving Ambiguities/
	The splitting of a sequence of characters using these regular
	expressions is not unique.  We use the usual left to right longest
	match tokenization obtaining either error or a unique sequence of
	tokens from a given sequence of characters.  Longest match means
	that if two or more prefixes of the remaining character string are
	matched by (possibly different) regular expressions, we select the
	match that accepts the longest prefix.  Note that the regular
	expressions are designed such that left to right longest match
	tokenization is unique.
      <Para class=apropos><Title/Lexical Errors/
	When no regular expression matches a prefix of the remaining
	character string, we speak of a <Def/lexical error/.  Such an
	input sequence does not represent a valid Oz program.
      <Section>
	<Title/Character Class Definitions/
	<P>
	  This section defines character classes used in the regular
	  expressions given in the remainder of the chapter.  Note that
	  these regular expressions do not&emdash;on their own&emdash;define
	  any splitting of the input into words.
	<P>
	  We use NUL to denote the ISO character with code&nbsp;0 and
	  ?={any character} to denote the set of all ISO characters.
	  <Grammar.Rule/?={upper-case letter}
	    <Grammar.Alt/<<A>> | &ellipsis; | <<Z>> |
	      <<À>> | &ellipsis; | <<Ö>> | <<Ø>> | &ellipsis; | <<Þ>>//
	  <Grammar.Rule/?={lower-case letter}
	    <Grammar.Alt/<<a>> | &ellipsis; | <<z>> |
	      <<ß>> | &ellipsis; | <<ö>> | <<ø>> | &ellipsis; | <<ÿ>>//
	  <Grammar.Rule/?={digit}
	    <Grammar.Alt/<<0>> | &ellipsis; | <<9>>//
	  <Grammar.Rule/?={non-zero digit}
	    <Grammar.Alt/<<1>> | &ellipsis; | <<9>>//
	  <Grammar.Rule/?={alphanumerical}
	    <Grammar.Alt/?={upper-case letter} | ?={lower-case letter} |
	      ?={digit} | <<_>>//
	  <Grammar.Rule/?={atom char}
	    <Grammar.Alt/?={any character} - ( <<'>> | <<\>> | NUL )//
	  <Grammar.Rule/?={string char}
	    <Grammar.Alt/?={any character} - ( <<">> | <<\>> | NUL )//
	  <Grammar.Rule/?={variable char}
	    <Grammar.Alt/?={any character} - ( <<`>> | <<\>> | NUL )//
	  <Grammar.Rule/?={escape character}
	    <Grammar.Alt/<<a>> | <<b>> | <<f>> | <<n>> | <<r>> | <<t>> | <<v>>
	      | <<\>> | <<'>> | <<">> | <<`>> | <<&>>//
	  <Grammar.Rule/?={octal digit}
	    <Grammar.Alt/<<0>> | &ellipsis; | <<7>>//
	  <Grammar.Rule/?={hex digit}
	    <Grammar.Alt/<<0>> | &ellipsis; | <<9>> |
	      <<A>> | &ellipsis; | <<F>> | <<a>> | &ellipsis; | <<f>>//
	  <Grammar.Rule/?={binary digit}
	    <Grammar.Alt/<<0>> | <<1>>//
	<Para class=apropos><Title/Pseudo-Characters/
	  In the classes of words ?={variable}, ?={atom}, ?={string}, and
	  ?={character} we use pseudo-characters, which represent single
	  characters in different notations.
	  <Grammar.Rule/?={pseudo char}
	    <Grammar.Alt/<<\>> ?={octal digit} ?={octal digit} ?={octal digit}/
	    <Grammar.Alt/<<\>> ( <<x>> | <<X>> ) ?={hex digit} ?={hex digit}/
	    <Grammar.Alt/<<\>> ?={escape character}//
	  Pseudo-characters allow to enter any ISO&nbsp;8859-1 character
	  using octal or hexadecimal notation.  Octal notation is restricted
	  to numbers less than 256.  The NUL character (ISO code&nbsp;0) is
	  forbidden.  The pseudo-characters <<\a>>&nbsp;(=&nbsp;<<\007>>),
	  <<\b>>&nbsp;(=&nbsp;<<\010>>), <<\f>>&nbsp;(=&nbsp;<<\014>>),
	  <<\n>>&nbsp;(=&nbsp;<<\012>>), <<\r>>&nbsp;(=&nbsp;<<\015>>),
	  <<\t>>&nbsp;(=&nbsp;<<\011>>), <<\v>>&nbsp;(=&nbsp;<<\013>>)
	  denote special purpose characters, and
	  <<\\>>&nbsp;(=&nbsp;<<\134>>), <<\'>>&nbsp;(=&nbsp;<<\047>>),
	  <<\">>&nbsp;(=&nbsp;<<\042>>), <<\`>>&nbsp;(=&nbsp;<<\140>>),
	  <<\&>>&nbsp;(=&nbsp;<<\046>>) denote their second component
	  character.
      <Section>
	<Title/Spaces and Comments/
	<P>
	  Spaces are tab (code&nbsp;9), newline (code&nbsp;10), vertical
	  tab (code&nbsp;11), form feed (code&nbsp;12), carriage return
	  (code&nbsp;13), and blank (code&nbsp;32).
	<P>
	  A comment is:
	  <List>
	    <Item>
	      a sequence of characters from&nbsp;<<%>> until the end of
	      the line or file,
	    <Item>
	      a sequence of characters within and including the comment
	      brackets <</*>> and&nbsp;<<*/>>, in which <</*>> and&nbsp;<<*/>>
	      are properly nested, and
	    <Item>
	      the character&nbsp<<?>>.
	  </List>
	<P>
	  Spaces and comments produce no tokens.  This means that they are
	  ignored, except that they separate words form each other.
      <Section>
	<Title/Keywords/
	<P>
	  <Grammar.Rule proglang=oz>?={keyword}
	    <Grammar.Alt><<andthen>> | <<at>> | <<attr>> | <<case>> |
	      <<catch>> | <<choice>></Grammar.Alt>
	    <Grammar.Alt><<class>> | <<cond>> | <<condis>> | <<declare>> |
	      <<define>> | <<dis>></Grammar.Alt>
	    <Grammar.Alt><<div>> | <<else>> | <<elsecase>> | <<elseif>> |
	      <<end>></Grammar.Alt>
	    <Grammar.Alt><<export>> | <<fail>> | <<false>> | <<feat>> |
	      <<finally>> | <<from>></Grammar.Alt>
	    <Grammar.Alt><<fun>> | <<functor>> | <<if>> | <<import>> |
	      <<in>> | <<local>></Grammar.Alt>
	    <Grammar.Alt><<lock>> | <<meth>> | <<mod>> | <<not>> |
	      <<of>> | <<or>> | <<orelse>></Grammar.Alt>
	    <Grammar.Alt><<prepare>> | <<proc>> | <<prop>> |
	      <<raise>> | <<require>></Grammar.Alt>
	    <Grammar.Alt><<self>> | <<skip>> | <<then>> | <<thread>> |
	      <<true>> | <<try>></Grammar.Alt>
	    <Grammar.Alt><<unit>> | <<with>> | <<(>> | <<)>> | <<[>> |
	      <<]>> | <<{>> | <<}>></Grammar.Alt>
	    <Grammar.Alt><<|>> | <<#>> | <<:>> | <<...>> | <<=>> |
	      <<.>> | <<^>> | <<[]>> | <<$>></Grammar.Alt>
	    <Grammar.Alt><<!>> | <<_>> | <<~>> | <<+>> | <<->> | <<*>> |
	      <</>> | <<@>> | <<&lt;->></Grammar.Alt>
	    <Grammar.Alt><<,>> | <<!!>> | <<&lt;=>> | <<==>> | <<\=>> |
	      <<&lt;>> | <<=&lt;>> | <<&gt;>></Grammar.Alt>
	    <Grammar.Alt><<&gt;=>> | <<=:>> | <<\=:>> | <<&lt;:>> |
	      <<=&lt;:>> | <<&gt;:>> | <<&gt;=:>> | <<::>> |
	      <<:::>></Grammar.Alt>
	  Each keyword represents itself as token. 
      <Section>
	<Title/Variables/
	<P>
	  <Grammar.Rule/?={variable}
	    <Grammar.Alt/?={upper-case letter} { ?={alphanumerical} }/
	    <Grammar.Alt/<<`>> { ?={variable char} | ?={pseudo char} } <<`>>//
	  A word of the form ?={variable} represents a variable token
	  of the form <Math/\lfloor/<<variable>>, ?{n}+<Math/\rfloor/,
	  where ?{n}+ is the sequence of characters that make up the
	  word, including the possibly surrounding <<`>>&nbsp;characters.
	<P>
	  For example, the word <Code proglang=oz/Xs/ represents the token
	  <Math/\lfloor/<<variable>>, 88 115<Math/\rfloor/
	  and the word <Code proglang=oz/`\n`/ represents the token
	  <Math/\lfloor/<<variable>>, 96 10 96<Math/\rfloor/.
	  Variable tokens are denoted by the terminal symbol ?={variable}
	  in the following context-free grammars.
      <Section>
	<Title/Atoms/
	<P>
	  <Grammar.Rule/?={atom}
	    <Grammar.Alt/?={lower-case letter} { ?={alphanumerical} } -
	      ?={keyword}/
	    <Grammar.Alt/<<'>> { ?={atom char} | ?={pseudo char} } <<'>>//
	  A word of the form ?={atom} represents an atom token of the form
	  <Math/\lfloor/<<atom>>, ?{n}*<Math/\rfloor/, where ?{n}* is the
	  sequence of characters that make up the word, excluding the possibly
	  surrounding <<'>>&nbsp;characters. 
	<P>
	  For example, the word <Code proglang=oz/atom/ represents the token
	  <Math/\lfloor/<<atom>>, 97 116 111 109<Math/\rfloor/
	  and the word <Code proglang=oz/'\n'/ represents the token
	  <Math/\lfloor/<<atom>>, 10<Math/\rfloor/.
	  Atom tokens are denoted by the terminal symbol ?={atom}
	  in the following context-free grammars.
      <Section>
	<Title/Labels/
	<P>
	  <Grammar.Rule/?={label}
	    <Grammar.Alt/( ?={variable} | ?={atom} | <<true>> | <<false>> |
	      <<unit>> ) <<(>>//
	  A word of the form ?={label} represents a sequence of two tokens.
	  The first is a label token of the form
	  <Math/\lfloor/<<variablelabel>>, ?{n}+<Math/\rfloor/, 
	  <Math/\lfloor/<<atomlabel>>, ?{n}*<Math/\rfloor/
	  (similar to the corresponding tokens for words of the form
	  ?={variable} and ?={atom}), <<truelabel>>, <<falselabel>>, or
	  <<unitlabel>>.  The second token is the keyword&nbsp;<<(>>.
	  For example, the word <Code proglang=oz/Xs(/ represents the tokens
	  <Math/\lfloor/<<variablelabel>>, 88 115<Math/\rfloor/ and&nbsp;<<(>>,
	  and the word <Code proglang=oz/true(/ represents the tokens
	  <<truelabel>> and&nbsp;<<(>>.  The label tokens are denoted
	  by the terminal symbols ?={variable label}, ?={atom label},
	  ?={unit label}, ?={true label}, and ?={false label} in the
	  following context-free grammars.
      <Section>
	<Title/Integers/
	<P>
	  <Grammar.Rule/?={int}
	    <Grammar.Alt/[ <<~>> ] ( <<0>> | ?={non-zero digit} { ?={digit} } )
	      <Grammar.Note/decimal representation//
	    <Grammar.Alt/[ <<~>> ] <<0>> { ?={octal digit} }+
	      <Grammar.Note/octal representation//
	    <Grammar.Alt/[ <<~>> ] <<0>> ( <<x>> | <<X>> ) { ?={hex digit} }+
	      <Grammar.Note/hexadecimal representation//
	    <Grammar.Alt/[ <<~>> ] <<0>> ( <<b>> | <<B>> )
	      { ?={binary digit} }+
	      <Grammar.Note/binary representation///
	  A word of the form ?={int} represents an integer token of the form
	  <Math/\lfloor/<<int>>, ?{n}<Math/\rfloor/, where ?{n} represents the
	  integer for which ?={int} is the representation.
	<P>
	  For example, the word <Code proglang=oz/~159/ represents the token
	  <Math/\lfloor/<<int>>, -159<Math/\rfloor/,
	  the word <Code proglang=oz/077/ the token
	  <Math/\lfloor/<<int>>, 63<Math/\rfloor/,
	  the word <Code proglang=oz/0xFF/ the token
	  <Math/\lfloor/<<int>>, 255<Math/\rfloor/,
	  and the word <Code proglang=oz/~0b11111/ the token
	  <Math/\lfloor/<<int>>, -31<Math/\rfloor/.
	  Integer tokens are denoted by the terminal symbol ?={int}
	  in the following context-free grammars.
      <Section>
	<Title/Floats/
	<P>
	  <Grammar.Rule/?={float}
	    <Grammar.Alt/[ <<~>> ] { ?={digit} }+ <<.>> { ?={digit} }
	      [ ( <<e>> | <<E>> ) [ <<~>> ] { ?={digit} }+ ]//
	  A word of the form ?={float} represents a float token of the form
	  <Math/\lfloor/<<float>>, ?{f}<Math/\rfloor/,
	  where ?{f} represents the floating point number for which the word
	  is the decimal representation.  The letters <<e>> and <<E>> both
	  indicate the exponent to&nbsp;10.
	<P>
	  For example, the word <Code proglang=oz/~1.5e2/ represents the token
	  <Math/\lfloor/<<float>>, -150.0<Math/\rfloor/.
	  Float tokens are denoted by the terminal symbol ?={float}
	  in the following context-free grammars.
	<P>
	  The syntax of floats is implementation-dependent in that
	  syntactically correct floats may be approximated by the
	  compiler if they cannot be represented by the implementation.
      <Section>
	<Title/Strings/
	<P>
	  <Grammar.Rule/?={string}
	    <Grammar.Alt/<<">> { ?={string char} | ?={pseudo char} } <<">>//
	  The word <Code proglang=oz/""/ represents the token
	  <Math/\lfloor/<<atom>>, 110 105 108<Math/\rfloor/, which denotes
	  the empty list <Code proglang=oz/nil/.  A word of the form
	  <<">><Math/c_1/ &ellipsis; <Math/c_m/<<">>, where <Math/m \geq 1/,
	  represents a sequence of <Math/m + 2/ tokens of the form
	  <<[>>&nbsp;<Math/n_1/ &ellipsis; <Math/n_m/&nbsp;<<]>>,
	  where the <Math/n_i/ represent integer tokens according to
	  the ISO&nbsp;8859-1 code of&nbsp;<Math/c_i/.
	<P>
	  For example, the word <Code proglang=oz/"ab"/ represents the
	  sequence of tokens <<[>>&nbsp;<Math/\lfloor/<<int>>, 97<Math/\rfloor/
	  <Math/\lfloor/<<int>>, 98<Math/\rfloor/&nbsp;<<]>>.
      <Section>
	<Title/Characters/
	<P>
	  <Grammar.Rule/?={character}
	    <Grammar.Alt/<<&amp;>> ( ?={any character} - ( <<\>> | NUL ) |
	      ?={pseudo char} )//
	  A word of the form ?={character} represents the integer token
	  according to the code of the character denoted by the word without
	  the <<&amp;>>&nbsp;prefix.
	<P>
	  For example, the word <Code proglang=oz/&amp;a/ represents the token
	  <Math/\lfloor/<<int>>, 97<Math/\rfloor/.
    <Chapter id="chapter.context-free">
      <Title/Context-Free Syntax/
      <P>
	In this section, we give a context-free grammar for a superset of
	Oz programs.  Any sequence of tokens that is not member of the
	language described by this grammar, starting from the ?={statement}
	nonterminal, is considered erroneous.
      <P>
	Implementations may accept a larger language, &eg;, something more
	than only a statement at top-level, or treat lexical syntax that
	has no assigned meaning in the report as compiler directives.
      <Section>
	<Title/The Base Language/
	<Para class=apropos><Title/Statements/
	  <Grammar.Rule/?={statement}
	    <Grammar.Alt/?={statement} ?={statement}/
	    <Grammar.Alt/<<local>> ?={in statement} <<end>>/
	    <Grammar.Alt/<Q class=terminal/<<(>>/ ?={in statement}
	      <Q class=terminal/<<)>>//
	    <Grammar.Alt/<<proc>> { ?={atom} } <Q class=terminal/<<{>>/
	      ?={expression} { ?={pattern} } <Q class=terminal/<<}>>//
	    <Grammar.Alt type=space/?={in phrase}/
	    <Grammar.Alt type=space/<<end>>/
	    <Grammar.Alt/<<fun>> { ?={atom} } <Q class=terminal/<<{>>/
	      ?={expression} { ?={pattern} } <Q class=terminal/<<}>>//
	    <Grammar.Alt type=space/?={in expression}/
	    <Grammar.Alt type=space/<<end>>/
	    <Grammar.Alt/<Q class=terminal/<<{>>/ ?={expression}
	      { ?={expression} } <Q class=terminal/<<}>>//
	    <Grammar.Alt/<<if>> ?={expression} <<then>> ?={in statement}/
	    <Grammar.Alt type=space/[ ?={else statement} ]/
	    <Grammar.Alt type=space/<<end>>/
	    <Grammar.Alt/<<case>> ?={expression}
	      <<of>> ?={case statement clause}/
	    <Grammar.Alt type=space/{ <<[]>> ?={case statement clause} }/
	    <Grammar.Alt type=space/[ ?={else statement} ]/
	    <Grammar.Alt type=space/<<end>>/
	    <Grammar.Alt/<<lock>> ?={expression} <<then>> ?={in statement}
	      <<end>>/
	    <Grammar.Alt/<<thread>> ?={in statement} <<end>>/
	    <Grammar.Alt/<<try>> ?={in statement}/
	    <Grammar.Alt type=space/[ <<catch>> ?={case statement clause}
	      { <Q class=terminal/<<[]>>/ ?={case statement clause} } ]/
	    <Grammar.Alt type=space/[ <<finally>> ?={in statement} ]/
	    <Grammar.Alt type=space/<<end>>/
	    <Grammar.Alt/<<raise>> ?={in expression} <<end>>/
	    <Grammar.Alt/<<raise>> ?={in expression}
	      <<with>> ?={in expression} <<end>>/
	    <Grammar.Alt/?={expression} <Q class=terminal/<<=>>/
	      ?={expression}/
	    <Grammar.Alt/<<skip>>//
	<Para class=apropos><Title/Expressions/
	  <!--** explain the nesting marker -->
	  <Grammar.Rule/?={expression}
	    <Grammar.Alt/<<local>> ?={in expression} <<end>>/
	    <Grammar.Alt/<Q class=terminal/<<(>>/ ?={in expression}
	      <Q class=terminal/<<)>>//
	    <Grammar.Alt/<<proc>> { ?={atom} } <Q class=terminal/<<{>>/
	      <Q class=terminal/<<$>>/ { ?={pattern} }
	      <Q class=terminal/<<}>>//
	    <Grammar.Alt type=space/?={in phrase}/
	    <Grammar.Alt type=space/<<end>>/
	    <Grammar.Alt/<<fun>> { ?={atom} } <Q class=terminal/<<{>>/
	      <Q class=terminal/<<$>>/ { ?={pattern} }
	      <Q class=terminal/<<}>>//
	    <Grammar.Alt type=space/?={in expression}/
	    <Grammar.Alt type=space/<<end>>/
	    <Grammar.Alt/<Q class=terminal/<<{>>/ ?={expression}
	      { ?={expression} } <Q class=terminal/<<}>>//
	    <Grammar.Alt/<<if>> ?={expression} <<then>> ?={in expression}/
	    <Grammar.Alt type=space/?={else expression}/
	    <Grammar.Alt type=space/<<end>>/
	    <Grammar.Alt/<<case>> ?={expression}
	      <<of>> ?={case expression clause}/
	    <Grammar.Alt type=space/{ <<[]>> ?={case expression clause} }/
	    <Grammar.Alt type=space/[ ?={else expression} ]/
	    <Grammar.Alt type=space/<<end>>/
	    <Grammar.Alt/<<lock>> ?={expression} <<then>> ?={in expression}
	      <<end>>/
	    <Grammar.Alt/<<thread>> ?={in expression} <<end>>/
	    <Grammar.Alt/<<try>> ?={in expression}/
	    <Grammar.Alt type=space/[ <<catch>> ?={case expression clause}
	      { <Q class=terminal/<<[]>>/ ?={case expression clause} } ]/
	    <Grammar.Alt type=space/[ <<finally>> ?={in statement} ]/
	    <Grammar.Alt type=space/<<end>>/
	    <Grammar.Alt/<<raise>> ?={in expression} <<end>>/
	    <Grammar.Alt/<<raise>> ?={in expression}
	      <<with>> ?={in expression} <<end>>/
	    <Grammar.Alt/?={expression} <Q class=terminal/<<=>>/
	      ?={expression}/
	    <Grammar.Alt/?={expression} <<orelse>> ?={expression}/
	    <Grammar.Alt/?={expression} <<andthen>> ?={expression}/
	    <Grammar.Alt/?={monop} ?={expression}/
	    <Grammar.Alt/?={expression} ?={binop} ?={expression}/
	    <Grammar.Alt/?={possibly escaped variable}/
	    <Grammar.Alt/<Q class=terminal/<<_>>//
	    <Grammar.Alt/?={atom} | ?={int} | ?={float}/
	    <Grammar.Alt/<<unit>> | <<true>> | <<false>>/
	    <!--** describe what omitted features mean -->
	    <Grammar.Alt/?={label} <Q class=terminal/<<(>>/
	      { [ ?={feature} <Q class=terminal/<<:>>/ ] ?={expression} }
	      [ <Q class=terminal/<<...>>/ ]
	      <Q class=terminal/<<)>>//
	    <Grammar.Alt/<Q class=terminal/<<[>>/ { ?={expression} }+
	      <Q class=terminal/<<]>>//
	    <Grammar.Alt/?={expression}
	      <Q class=terminal/<<|>>/ ?={expression}/
	    <Grammar.Alt/?={expression}
	      { <Q class=terminal/<<#>>/ ?={expression} }+/
	    <Grammar.Alt/<Q class=terminal/<<$>>///
	  <Grammar.Rule/?={label}
	    <Grammar.Alt/?={variable label} | ?={atom label}/
	    <Grammar.Alt/?={unit label} | ?={true label} | ?={false label}//
	  <Grammar.Rule/?={feature}
	    <Grammar.Alt/?={variable} | ?={atom} | ?={int}/
	    <Grammar.Alt/<<unit>> | <<true>> | <<false>>//
	<Para class=apropos><Title/Operators/
	  Note that expressions with operators need additional disambiguating
	  rules introduced in&nbsp;<Ptr to="section.context-free.operators">.
	  <Grammar.Rule/?={monop}
	    <Grammar.Alt/<Q class=terminal/<<~>>/ |
	      <Q class=terminal/<<!!>>//
	  <Grammar.Rule>?={binop}
	    <Grammar.Alt/<Q class=terminal/<<.>>/ |
	      <Q class=terminal/<<^>>//
	    <Grammar.Alt/<Q class=terminal/<<==>>/ |
	      <Q class=terminal/<<\=>>/ | <Q class=terminal/<<&lt;>>/ |
	      <Q class=terminal/<<&lt;=>>/ | <Q class=terminal/<<&gt;>>/ |
	      <Q class=terminal/<<&gt;=>>//
	    <Grammar.Alt><Q class=terminal/<<+>>/ |
	      <Q class=terminal/<<->>/ | <Q class=terminal/<<*>>/ |
	      <Q class=terminal><</>></Q> | <<div>> | <<mod>></Grammar.Alt>
	<Para class=apropos><Title/Declarations/
	  A ?={declaration part} is a sequence of variables and statements.
	  Singleton variables serve only for explicit declaration and are
	  otherwise ignored.  Variables within statements are implicitly
	  declared if they occur at a <Def/pattern position/.  A prefixed
	  escape&nbsp;(<<!>>) prevents implicit declaration.
	  <Grammar.Rule/?={declaration part}
	    <Grammar.Alt/?={variable}/
	    <Grammar.Alt/?={statement}/
	    <Grammar.Alt/?={declaration part} ?={declaration part}//
	  <Grammar.Rule/?={in statement}
	    <Grammar.Alt/[ ?={declaration part} <<in>> ] ?={statement}//
	  <Grammar.Rule/?={in expression}
	    <Grammar.Alt/[ ?={declaration part} <<in>> [ ?={statement} ] ]
	      ?={expression}//
	  <Grammar.Rule/?={possibly escaped variable}
	    <Grammar.Alt/[ <Q class=terminal/<<!>>/ ] ?={variable}//
	<P>
	  As procedure body either a statement or an expression may be
	  possible, depending on whether the procedure's formal parameter
	  patterns contain a nesting marker&nbsp;(<<$>>) or not.
	  <Grammar.Rule/?={in phrase}
	    <Grammar.Alt/?={in statement}/
	    <Grammar.Alt/?={in expression}//
	<Para class=apropos><Title/Patterns/
	  Pattern matching is performed as a top-down left-to-right
	  sequence of tests.  Record patterns test a value's constructor;
	  constant patterns and escaped variable patterns test for equality
	  with the given value; nonlinearities (variables occurring multiply
	  in one pattern) test for equality of the corresponding subtrees.
	  Equation patterns and non-escaped variables introduce variable
	  bindings.
	  <Grammar.Rule/?={pattern}
	    <Grammar.Alt/?={label} <Q class=terminal/<<(>>/
	      { [ ?={feature} <Q class=terminal/<<:>>/ ] ?={pattern} }
	      [ <Q class=terminal/<<...>>/ ]
	      <Q class=terminal/<<)>>//
	    <Grammar.Alt/<Q class=terminal/<<[>>/ { ?={pattern} }+
	      <Q class=terminal/<<]>>//
	    <Grammar.Alt/?={pattern} <Q class=terminal/<<|>>/ ?={pattern}/
	    <Grammar.Alt/?={pattern} { <Q class=terminal/<<#>>/ ?={pattern} }+/
	    <Grammar.Alt/?={atom} | ?={int} | ?={float}/
	    <Grammar.Alt/<<unit>> | <<true>> | <<false>>/
	    <Grammar.Alt/?={possibly escaped variable}/
	    <Grammar.Alt/<Q class=terminal/<<_>>//
	    <Grammar.Alt/?={pattern} <Q class=terminal/<<=>>/ ?={pattern}/
	    <Grammar.Alt/<Q class=terminal/<<(>>/ ?={pattern}
	      <Q class=terminal/<<)>>///
	<P>
	  Following the pattern an additional side condition can be given.
	  It is only evaluated if the pattern matched, in the environment
	  extended by the bindings introduced by the pattern.  The variables
	  introduced in the optional ?={declaration part} are also visible
	  in the clause's body.
	  <Grammar.Rule/?={case statement clause}
	    <Grammar.Alt/?={pattern}
	      [ <<andthen>> [ ?={declaration part} <<in>> ] ?={expression} ]/
	    <Grammar.Alt type=space/<<then>> ?={in statement}//
	  <Grammar.Rule/?={case expression clause}
	    <Grammar.Alt/?={pattern}
	      [ <<andthen>> [ ?={declaration part} <<in>> ] ?={expression} ]/
	    <Grammar.Alt type=space/<<then>> ?={in expression}//
	<Para class=apropos><Title/Else Clauses/
	  If the <<else>> part to an <<if>> statement is omitted, it is taken
	  to be <<else skip>>.  The <<else>> part to an <<if>> expression is
	  mandatory.
	<P>
	  If the <<else>> part to a <<case>> statement or expression is
	  omitted and no pattern matches, an error exception is raised.
	  <Grammar.Rule/?={else statement}
	    <Grammar.Alt/<<elseif>> ?={expression} <<then>> ?={in statement}/
	    <Grammar.Alt type=space/[ ?={else statement} ]/
	    <Grammar.Alt/<<elsecase>> ?={expression} <<of>>
	      ?={case statement clause}/
	    <Grammar.Alt type=space/{ <Q class=terminal/<<[]>>/
	      ?={case statement clause} }/
	    <Grammar.Alt type=space/[ ?={else statement} ]/
	    <Grammar.Alt/<<else>> ?={in statement}//
	  <Grammar.Rule/?={else expression}
	    <Grammar.Alt/<<elseif>> ?={expression} <<then>> ?={in expression}/
	    <Grammar.Alt type=space/?={else expression}/
	    <Grammar.Alt/<<elsecase>> ?={expression} <<of>>
	      ?={case expression clause}/
	    <Grammar.Alt type=space/{ <Q class=terminal/<<[]>>/
	      ?={case expression clause} }/
	    <Grammar.Alt type=space/[ ?={else expression} ]/
	    <Grammar.Alt/<<else>> ?={in expression}//
      <Section>
	<Title/Constraint Extensions and Combinators/
	<Para class=apropos><Title/Statements/
	  <Grammar.Rule/?={statement}
	    <Grammar.Alt type=add/?={fd compare}/
	    <Grammar.Alt/?={fd in}/
	    <Grammar.Alt/<<fail>>/
	    <Grammar.Alt/<<not>> ?={in statement} <<end>>/
	    <Grammar.Alt/<<cond>> ?={cond statement clause}/
	    <Grammar.Alt type=space/{ <Q class=terminal/<<[]>>/
	      ?={cond statement clause} }/
	    <Grammar.Alt type=space/[ <<else>> ?={in statement} ]/
	    <Grammar.Alt type=space/<<end>>/
	    <Grammar.Alt/<<or>> ?={dis statement clause}
	      { <Q class=terminal/<<[]>>/
	      ?={dis statement clause} }+ <<end>>/
	    <Grammar.Alt/<<dis>> ?={dis statement clause}
	      { <Q class=terminal/<<[]>>/
	      ?={dis statement clause} }+ <<end>>/
	    <Grammar.Alt/<<choice>> ?={choice statement clause}
	      { <Q class=terminal/<<[]>>/
	      ?={choice statement clause} } <<end>>/
	    <Grammar.Alt/<<condis>> ?={condis clause}
	      { <Q class=terminal/<<[]>>/ ?={condis clause} }+ <<end>>//
	  <Grammar.Rule/?={cond statement clause}
	    <Grammar.Alt/[ ?={declaration part} <<in>> ] ?={statement}
	      <<then>> ?={in statement}//
	  <Grammar.Rule/?={dis statement clause}
	    <Grammar.Alt/[ ?={declaration part} <<in>> ] ?={statement}
	      [ <<then>> ?={in statement} ]//
	  <Grammar.Rule/?={choice statement clause}
	    <Grammar.Alt/[ [ ?={declaration part} <<in>> ]
	      ?={statement} <<then>> ]
	    <Grammar.Alt type=space/?={in statement}//
	  <Grammar.Rule/?={condis clause}
	    <Grammar.Alt/?={fd compare}/
	    <Grammar.Alt/?={fd in}//
	<Para class=apropos><Title/Expressions/
	  <Grammar.Rule/?={expression}
	    <Grammar.Alt type=add/?={fd compare}/
	    <Grammar.Alt/?={fd in}/
	    <Grammar.Alt/<<fail>>/
	    <Grammar.Alt/<<cond>> ?={cond expression clause}/
	    <Grammar.Alt type=space/{ <Q class=terminal/<<[]>>/
	      ?={cond expression clause} }/
	    <Grammar.Alt type=space/[ <<else>> ?={in expression} ]/
	    <Grammar.Alt type=space/<<end>>/
	    <Grammar.Alt/<<or>> ?={cond expression clause}
	      { <Q class=terminal/<<[]>>/
	      ?={cond expression clause} }+ <<end>>/
	    <Grammar.Alt/<<dis>> ?={cond expression clause}
	      { <Q class=terminal/<<[]>>/
	      ?={cond expression clause} }+ <<end>>/
	    <Grammar.Alt/<<choice>> ?={choice expression clause}
	      { <Q class=terminal/<<[]>>/
	      ?={choice expression clause} } <<end>>/
	    <Grammar.Alt/<<condis>> ?={condis clause}
	      { <Q class=terminal/<<[]>>/ ?={condis clause} }+ <<end>>//
	  <Grammar.Rule/?={cond expression clause}
	    <Grammar.Alt/[ ?={declaration part} <<in>> ] ?={statement}
	      <<then>> ?={in expression}//
	  <Grammar.Rule/?={choice expression clause}
	    <Grammar.Alt/[ [ ?={declaration part} <<in>> ]
	      ?={statement} <<then>> ]/
	    <Grammar.Alt type=space/?={in expression}//
	  <Grammar.Rule/?={fd compare}
	    <Grammar.Alt/?={expression} (
	      <Q class=terminal/<<=:>>/ |
	      <Q class=terminal/<<\=:>>/ |
	      <Q class=terminal/<<&lt;:>>/ |
	      <Q class=terminal/<<=&lt;:>>/ |
	      <Q class=terminal/<<&gt;:>>/ |
	      <Q class=terminal/<<&gt;=:>>/ ) ?={expression}//
	  <Grammar.Rule/?={fd in}
	    <Grammar.Alt/?={expression} (
	      <Q class=terminal/<<::>>/ |
	      <Q class=terminal/<<:::>>/ ) ?={expression}//
      <Section>
	<Title/Class Extensions/
	<Para class=apropos><Title/Class Definitions/
	  <Grammar.Rule/?={statement}
	    <Grammar.Alt type=add/<<class>> ?={expression}/
	    <Grammar.Alt type=space/{ ?={class descriptor} }/
	    <Grammar.Alt type=space/{ ?={method} }/
	    <Grammar.Alt type=space/<<end>>//
	  <Grammar.Rule/?={expression}
	    <Grammar.Alt type=add/<<class>> [ <Q class=terminal/<<$>>/ ]/
	    <Grammar.Alt type=space/{ ?={class descriptor} }/
	    <Grammar.Alt type=space/{ ?={method} }/
	    <Grammar.Alt type=space/<<end>>/
	  <Grammar.Rule/?={class descriptor}
	    <Grammar.Alt/<<from>> { ?={expression} }+/
	    <Grammar.Alt/<<prop>> { ?={expression} }+/
	    <Grammar.Alt/<<attr>> { ?={attr or feat} }+/
	    <Grammar.Alt/<<feat>> { ?={attr or feat} }+//
	<P>
	  Non-escaped variables are implicitly introduced with class scope,
	  bound to new names.  This allows to model private components.
	  <Grammar.Rule/?={attr or feat}
	    <Grammar.Alt/[ <Q class=terminal/<<!>>/ ] ?={variable} |
	      ?={atom} | ?={int}/
	    <Grammar.Alt/<<unit>> | <<true>> | <<false>>//
	<Para class=apropos><Title/Methods/
	  The first-class message used to invoke a method can be referenced
	  by appending <<=>>&nbsp;?={variable} to the method head.  This
	  message does not contain defaulted arguments (see below) if they
	  have not been explicitly given.
	  <Grammar.Rule/?={method}
	    <Grammar.Alt/<<meth>> ?={method head}
	      [ <Q class=terminal/<<=>>/ ?={variable} ]/
	    <Grammar.Alt type=space/?={in phrase}/
	    <Grammar.Alt type=space/<<end>>//
	<P>
	  If dots are given, any additional features are allowed in the
	  first-class message; else, extraneous features cause an error
	  exception to be raised.
	  <Grammar.Rule/?={method head}
	    <Grammar.Alt/[ <Q class=terminal/<<!>>/ ] ?={variable} | ?={atom}/
	    <Grammar.Alt/<<unit>> | <<true>> | <<false>>/
	    <Grammar.Alt/?={method head label} <Q class=terminal/<<(>>/
	      { ?={method formal} } [ <Q class=terminal/<<...>>/ ]
	      <Q class=terminal/<<)>>//
	  <Grammar.Rule/?={method head label}
	    <Grammar.Alt/[ <Q class=terminal/<<!>>/ ] ?={variable label} |
	      ?={atom label}/
	    <Grammar.Alt/?={unit label} | ?={true label} | ?={false label}//
	<P>
	  A default <<&lt;=>> after a formal argument allows for the
	  corresponding actual argument to be omitted from a first-class
	  method.  In this case, the default expression will be evaluated
	  (inside the method) and the formal argument variable bound to the
	  result.
	  <Grammar.Rule/?={method formal}
	    <Grammar.Alt/[ ?={feature} <Q class=terminal/<<:>>/ ]
	      ( ?={variable} | <Q class=terminal/<<_>>/ |
	      <Q class=terminal/<<$>>/ )/
	    <Grammar.Alt type=space/[ <Q class=terminal/<<&lt;=>>/
	      ?={expression} ]//
	<Para class=apropos><Title/Operations/
	  To the following operators, <<self>> is an implicit operand.
	  Their use is syntactically restricted to the body of method
	  definitions.
	  <Grammar.Rule/?={statement}
	    <Grammar.Alt type=add/<<lock>> ?={in statement} <<end>>/
	    <Grammar.Alt/?={expression} <Q class=terminal/<<&lt;->>/
	      ?={expression}/
	    <Grammar.Alt/?={expression} <Q class=terminal/<<,>>/
	      ?={expression}//
	  The assignment operator, when used in expression position,
	  performs an atomic exchange, the result of the operation
	  being the previous value of the attribute assigned to.
	  <Grammar.Rule/?={expression}
	    <Grammar.Alt type=add/<<lock>> ?={in expression} <<end>>/
	    <Grammar.Alt/<Q class=terminal/<<@>>/ ?={expression}/
	    <Grammar.Alt/?={expression} <Q class=terminal/<<&lt;->>/
	      ?={expression}/
	    <Grammar.Alt/?={expression} <Q class=terminal/<<,>>/
	      ?={expression}/
	    <Grammar.Alt/<<self>>//
      <Section>
	<Title/Functor Extensions/
	<P>
	  A functor definition creates a chunk with (at least) features
	  <<'import'>> and <<'export'>> describing its interface and a
	  feature <<apply>> containing a procedure mapping an import record
	  to an export module.
	  <Grammar.Rule/?={statement}
	    <Grammar.Alt type=add/<<functor>> ?={expression}
	      { ?={functor descriptor} } <<end>>//
	  <Grammar.Rule/?={expression}
	    <Grammar.Alt type=add/<<functor>> [ <Q class=terminal/<<$>>/ ]
	      { ?={functor descriptor} } <<end>>//
	<Para class=apropos><Title/Import Declarations/
	  The import clause names values (usually modules) to be made
	  available to the body.  They represent formal arguments to the
	  body abstraction.  The aditional <<at>> clause allows to specify
	  where the actual argument is to come from.  This must be an atom
	  (interpreted as a relative URL) so that a functor creating the
	  referenced module may be located at compile time.
	  <Grammar.Rule/?={functor descriptor}
	    <Grammar.Alt/<<import>> { ?={import declaration} }+//
	  <Grammar.Rule/?={import declaration}
	    <Grammar.Alt/?={variable} [ <<at>> ?={atom} ]/
	    <Grammar.Alt/?={variable label} ?={import features}
	      [ <<at>> ?={atom} ]//
	  If the expected structure of an imported value is partially
	  specified, occurrences of the module name are restricted
	  to a single syntactic context:  the first operand in
	  applications of the dot operator, where the second operand
	  is one of the features mentioned in the import specification.
	  <Grammar.Rule/?={import features}
	    <Grammar.Alt/<Q class=terminal/<<(>>/
	      { ?={module feature} ?={import alias} }+
	      <Q class=terminal/<<)>>///
	  <Grammar.Rule/?={module feature}
	    <Grammar.Alt/?={atom} | ?={int}//
	  An <Def/import alias/ introduces a variable bound to one of the
	  imported module's subtrees.
	  <Grammar.Rule/?={import alias}
	    <Grammar.Alt/[ <Q class=terminal/<<:>>/ ?={variable} ]//
	<Para class=apropos><Title/Functor Bodies/
	  The body of the functor is a statement (usually a sequence of
	  definitions that compute the exported values).  This statement
	  is a pattern position.  Note the difference between this
	  abbreviated declaration and the ?={in statement} rule:
	  The ?={statement} following the <<in>> keyword is optional,
	  not the ?={declaration part} preceding it.
	  <Grammar.Rule/?={functor descriptor}
	    <Grammar.Alt type=add/<<define>> ?={declaration part}
	      [ <<in>> ?={statement} ]//
	<Para class=apropos><Title/Export Declarations/
	  The export descriptor specifies the structure the modules
	  created by applications of this functor will have.
	  <Grammar.Rule/?={functor descriptor}
	    <Grammar.Alt type=add/<<export>>
	      { [ ?={module feature} <Q class=terminal/<<:>>/ ]
	      ?={variable} }+//
	  The value of the variables mentioned in the export declaration
	  are made available under the given features.  If a feature is
	  omitted, then it is computed from the corresponding variable's
	  print name by changing its initial capital letter into a
	  lower-case letter (unless it's a backquote variable, in which
	  case the print name is taken as-is).
	<P>
	  All variables introduced in the import and the body are visible
	  in the export declaration.
	<Para class=apropos><Title/Computed Functors/
	  A functor that contains one of the following additional functor
	  descriptors is called a <Def/computed functor/.  The <<require>>
	  and <<prepare>> clauses correspond to the <<import>> and <<define>>
	  clauses respectively, only they are executed upon functor definition
	  instead of functor application.  The variables introduced by these
	  clauses are visible in the <<define>> and <<export>> clauses.
	  <Grammar.Rule/?={functor descriptor}
	    <Grammar.Alt type=add/<<require>> { ?={import declaration} }/
	    <Grammar.Alt/<<prepare>> ?={declaration part}
	      [ <<in>> ?={statement} ]//
      <Section id="section.context-free.operators">
	<Title/Operator Associativity and Precedence/
	<P>
	  The grammar given above is ambiguous.  Some ambiguities do not
	  affect the semantics (such as associativity of ?={statement}s and
	  ?={declaration part}s).  Those that do are resolved according to
	  the following table stating the associativity of operators in
	  increasing order of precedence:
	  <Table>
	    <TR>
	      <TH/Operators/
	      <TH/Associativity/
	    <TR>
	      <TD/<<=>>/
	      <TD/right/
	    <TR>
	      <TD/<<&lt;->>/
	      <TD/right/
	    <TR>
	      <TD/<<orelse>>/
	      <TD/right/
	    <TR>
	      <TD/<<andthen>>/
	      <TD/right/
	    <TR>
	      <TD/<<==>> <<\=>> <<&lt;>> <<=&lt;>> <<&gt;>> <<&gt;=>>
		<<=:>> <<\=:>> <<&lt;:>>  <<=&lt;:>>  <<&gt;:>>  <<&gt;=:>>/
	      <TD/none/
	    <TR>
	      <TD/<<::>> <<:::>>/
	      <TD/none/
	    <TR>
	      <TD/<<|>>/
	      <TD/right/
	    <TR>
	      <TD/<<#>>/
	      <TD/mixfix/
	    <TR>
	      <TD/<<+>> <<->>/
	      <TD/left/
	    <TR>
	      <TD><<*>> <</>> <<div>> <<mod>></TD>
	      <TD/left/
	    <TR>
	      <TD/<<,>>/
	      <TD/right/
	    <TR>
	      <TD/<<~>>/
	      <TD/left/
	    <TR>
	      <TD/<<.>> <<^>>/
	      <TD/left/
	    <TR>
	      <TD/<<@>> <<!!>>/
	      <TD/left/
	  </Table>
	  <Q/Having higher precedence/ means <Q/binding tighter/; &eg;,
	  the expression <<c#X.g = Y>> is parsed as <<(c#(X.g)) = Y>>.
	<P>
	  Attempts to exploit associativity of non-associative operators
	  (without using parentheses to make the intention clear),
	  as in <<X &lt; Y &lt; Z>>, are considered erroneous.
    <Chapter id="chapter.core">
      <Title/Core Programs/
      <P>
	In this section, we give a context-free grammar for Core Oz programs.
      <Section>
	<Title/The Base Language/
	<Para class=apropos><Title/Statements/
	  <Grammar.Rule/?={statement}
	    <Grammar.Alt/?={statement} ?={statement}/
	    <Grammar.Alt/<<local>> { ?={variable} }+
	      <<in>> ?={statement} <<end>>/
	    <Grammar.Alt/<<proc>> { ?={atom} } <Q class=terminal/<<{>>/
	      ?={variable} { ?={variable} } <Q class=terminal/<<}>>//
	    <Grammar.Alt type=space/?={statement}/
	    <Grammar.Alt type=space/<<end>>/
	    <Grammar.Alt/<Q class=terminal/<<{>>/ ?={variable}
	      { ?={variable} } <Q class=terminal/<<}>>//
	    <Grammar.Alt/<<lock>> ?={variable} <<then>> ?={statement}
	      <<end>>/
	    <Grammar.Alt/<<thread>> ?={statement} <<end>>/
	    <Grammar.Alt/<<try>> ?={statement}/
	    <Grammar.Alt type=space/<<catch>> ?={variable} <<then>>
	      ?={statement}/
	    <Grammar.Alt type=space/<<end>>/
	    <Grammar.Alt/?={variable} <Q class=terminal/<<=>>/
	      ?={expression}/
	    <Grammar.Alt/<<skip>>//
	<Para class=apropos><Title/Expressions/
	  <Grammar.Rule/?={expression}
	    <Grammar.Alt/?={variable}/
	    <Grammar.Alt/?={atom} | ?={int} | ?={float}/
	    <Grammar.Alt/?={label} <Q class=terminal/<<(>>/
	      { ?={feature} <Q class=terminal/<<:>>/ ?={expression} }
	      [ <Q class=terminal/<<...>>/ ]
	      <Q class=terminal/<<)>>///
	  <Grammar.Rule/?={label}
	    <Grammar.Alt/?={variable label} | ?={atom label}//
	  <Grammar.Rule/?={feature}
	    <Grammar.Alt/?={variable} | ?={atom} | ?={int}//
      <Section>
	<Title/Combinators/
	<P>
	  <Grammar.Rule/?={statement}
	    <Grammar.Alt type=add/<<cond>> ?={clause}
	      { <Q class=terminal/<<[]>>/ ?={clause} }
	      <<else>> ?={statement} <<end>>/
	    <Grammar.Alt/<<or>> ?={clause}
	      { <Q class=terminal/<<[]>>/ ?={clause} }+ <<end>>/
	    <Grammar.Alt/<<dis>> ?={clause}
	      { <Q class=terminal/<<[]>>/ ?={clause} }+ <<end>>/
	    <Grammar.Alt/<<choice>> ?={clause}
	      { <Q class=terminal/<<[]>>/ ?={clause} } <<end>>//
	  <Grammar.Rule/?={clause}
	    <Grammar.Alt/[ { ?={variable} }+ <<in>> ] ?={statement}
	      <<then>> ?={statement}//
      <Section>
	<Title/Class Extensions/
	<P>
	  <Grammar.Rule/?={statement}
	    <Grammar.Alt type=add/<<class>> ?={variable}/
	    <Grammar.Alt type=space/[ <<from>> { ?={variable} }+ ]/
	    <Grammar.Alt type=space/[ <<prop>> { ?={variable} }+ ]/
	    <Grammar.Alt type=space/[ <<attr>> { <Q class=terminal/<<!>>/
	      ?={variable} [ <Q class=terminal/<<:>>/ ?={variable} ] }+ ]/
	    <Grammar.Alt type=space/[ <<feat>> { <Q class=terminal/<<!>>/
	      ?={variable} [ <Q class=terminal/<<:>>/ ?={variable} ] }+ ]/
	    <Grammar.Alt type=space/{ ?={method} }/
	    <Grammar.Alt type=space/<<end>>/
	    <Grammar.Alt/?={variable} <Q class=terminal/<<=>>/ <<self>>//
	<Para class=apropos><Title/Methods/
	  <Grammar.Rule/?={method}
	    <Grammar.Alt/<<meth>> <Q class=terminal/<<!>>/ ?={variable}
	      <Q class=terminal/<<(>>/ <Q class=terminal/<<...>>/
	      <Q class=terminal/<<)>>/ <Q class=terminal/<<=>>/ ?={variable}/
	    <Grammar.Alt type=space/?={statement}/
	    <Grammar.Alt type=space/<<end>>//
    <Chapter id="chapter.translation">
      <Title/Translation of Oz Programs to Oz Core Programs/
      <P>
	Oz programs are translated to Oz core programs by repeatedly
	applying the rules given in this chapter to subtrees of the
	parse tree, replacing the subtree with the result of the rule.
	A rule consists of the following:
	<List>
	  <Entry/A set of nonterminals./
	  <Item>
	    The rule is only applicable to subtrees generated by a
	    rule of one of these nonterminals.
	  <Entry/A left-hand side./
	  <Item>
	    The rule is only applicable if the subtree's structure matches
	    the left-hand side pattern.  Additionally, variables are
	    introduced.  Some parts may be left out (replaced by an
	    ellipsis) if they reappear unmodified in the output.
	  <Entry/A right-hand side./
	  <Item>
	    When the rule is applied to a subtree, the latter is replaced
	    by the subtree specified by the right-hand side.  This may
	    contain variables written as <<X>>, <<Y>>, or&nbsp;<<Z>> not
	    appearing in the left-hand side:  These variables are supposed
	    to be fresh such that no capturing can occur.
	  <Entry/Optionally, a side condition./
	  <Item>
	    The rule is only applicable if the side-condition is satisfied.
	</List>
      <Para class=apropos><Title/Meta Variables/
	Inside rewrite rules, we use meta variables for terminals and phrases
	generated by nonterminals as shown in the following table:
	<Table>
	  <TR>
	    <TH/Meta Variables/
	    <TH/Corresponding Terminals and Nonterminals/
	  <TR>
	    <TD/?{x}/
	    <TD/?={variable}/
	  <TR>
	    <TD/?{D}/
	    <TD/?={declaration part}/
	  <TR>
	    <TD/?{S}/
	    <TD/?={statement}/
	  <TR>
	    <TD/?{E}, ?{E1}, &ellipsis;, ?{Ek}, ?{En}/
	    <TD/?={expression}/
	  <TR>
	    <TD/?{SE}/
	    <TD/?={statement} or ?={expression}/
	  <TR>
	    <TD/?{P}, ?{P1}, &ellipsis;, ?{Pk}, ?{Pn}/
	    <TD/?={pattern}/
	  <TR>
	    <TD/?{EP}, ?{EP1}, &ellipsis;, ?{EPn}/
	    <TD/?={expression} or ?={pattern}/
	  <TR>
	    <TD/?{C}, ?{C1}, &ellipsis;, ?{Cn}/
	    <TD/?={case statement clause} or ?={case expression clause}/
	  <TR>
	    <TD/?{L}, ?{L1}, &ellipsis;, ?{Ln}/
	    <TD/?={cond statement clause} or ?={cond expression clause}/
	  <TR>
	    <TD/?{l}/
	    <TD/?={label}/
	  <TR>
	    <TD/?{f1}, &ellipsis; ?{fn}/
	    <TD/?={feature}/
	</Table>
      <Para class=apropos><Title/Core Variables/
	The result of the transformation may have references to so-called
	<Def/Core variables/.  We indicate this by writing them in backquotes;
	they are not bound lexically, but are looked up in static environment.
	Examples are <<`.`>> and <<`List.toRecord`>>.  If the print name of a
	Core variable contains a dot, then it is supposed to be looked up
	(without the backquotes) in the Base Environment (see <Ptr.Extern
	to="ozdoc:base">).
	<!--** what if it does not contain a dot -->
      <Para class=apropos><Title/Errors/
	When no rule is applicable and the program is not an Oz Core program,
	we speak of a <Def/syntax error/.  Such a program is not a valid
	Oz program.
      <Section>
	<Title/The Base Language/
	<SubSection class=unnumbered>
	  <Title/Declarations/
	  <P>
	    <!--** motivate the definition of pattern variables -->
	    <!--** define pattern positions -->
	    <Table>
	      <TR>
		<TH/?{D}/
		<TH/?{PV}(?{D})/
	      <TR>
		<TD/<<(?{S})>>/
		<TD/?{PV}(?{S})/
	      <TR>
		<TD/<<(?{D} in ?{S})>>/
		<TD/?{PV}(?{S}) - ?{PV}(?{D})/
	      <TR>
		<TD/<<?{D1} ?{D2}>>/
		<TD/?{PV}(?{D1}) <Math/\cup/ ?{PV}(?{D2})/
	      <TR>
		<TD/<<?{x}>>/
		<TD/{?{x}}/
	      <TR>
		<TD/<<local ?{D} in ?{S} end>>/
		<TD/?{PV}(?{S}) - ?{PV}(?{D})/
	      <TR>
		<TD/<<proc &ellipsis; {?{E} &ellipsis;} &ellipsis; end>>/
		<TD/?{PV}(?{E})/
	      <TR>
		<TD/<<fun &ellipsis; {?{E} &ellipsis;} &ellipsis; end>>/
		<TD/?{PV}(?{E})/
	      <TR>
		<TD/<<class ?{E} &ellipsis; end>>/
		<TD/?{PV}(?{E})/
	      <TR>
		<TD/<<functor ?{E} &ellipsis; end>>/
		<TD/?{PV}(?{E})/
	      <TR>
		<TD/<<?{E} = &ellipsis;>>/
		<TD/?{PV}(?{E})/
	      <TR>
		<TD/otherwise/
		<TD/<Math/\emptyset//
	    </Table>
	    <Table>
	      <TR>
		<TH/?{E}/
		<TH/?{PV}(?{E})/
	      <TR>
		<TD/<<(?{E})>>/
		<TD/?{PV}(?{E})/
	      <TR>
		<TD/<<(?{D} in >>[ ?{S} ]<< ?{E})>>/
		<TD/(?{PV}(?{S}) <Math/\cup/ ?{PV}(?{E})) - ?{PV}(?{D})/
	      <TR>
		<TD/<<?{x}>>/
		<TD/{?{x}}/
	      <TR>
		<TD/<<local ?{D} in >>[ ?{S} ]<< ?{E} end>>/
		<TD/(?{PV}(?{S}) <Math/\cup/ ?{PV}(?{E})) - ?{PV}(?{D})/
	      <TR>
		<TD/<<?{E1} = ?{E2}>>/
		<TD/?{PV}(?{E1}) <Math/\cup/ ?{PV}(?{E2})/
	      <TR>
		<TD/<<[?{E1} &ellipsis; ?{En}]>>/
		<TD/?{PV}(?{E1}) <Math/\cup/ &ellipsis;
		  <Math/\cup/ ?{PV}(?{En})/
	      <TR>
		<TD/<<?{E1}|?{E2}]>>/
		<TD/?{PV}(?{E2}) <Math/\cup/ ?{PV}(?{E2})/
	      <TR>
		<TD/<<?{E1}#&ellipsis;#?{En}>>/
		<TD/?{PV}(?{E1}) <Math/\cup/ &ellipsis;
		  <Math/\cup/ ?{PV}(?{En})/
	      <TR>
		<TD/<<?{l}(>>[ ?{f1}<<:>> ]<< ?{E1} &ellipsis; >>[ ?{fn}<<:>>
		  ]<< ?{En} >>[ <<...>> ]<<)>>/
		<TD/?{PV}(?{E1}) <Math/\cup/ &ellipsis;
		  <Math/\cup/ ?{PV}(?{En})/
	      <TR>
		<TD/otherwise/
		<TD/<Math/\emptyset//
	    </Table>
	    <Rewrite>?={in statement}
	      <Rewrite.From/<<?{D} in ?{S}>>/
	      <Rewrite.To/<<local ?{D} in ?{S} end>>/
	    </Rewrite>
	    <Rewrite>?={in expression}
	      <Rewrite.From/<<?{D} in >>[ ?{S} ]<< ?{E}>>/
	      <Rewrite.To/<<local ?{D} in >>[ ?{S} ]<< ?{E} end>>/
	    </Rewrite>
	    <Rewrite>?={declaration part}
	      <Rewrite.From/?{D}/
	      <Rewrite.To/?{x1} &ellipsis; ?{xn}/
	      <Rewrite.Condition/if ?{D} is not a sequence of distinct
		variables and where {?{x1}, &ellipsis;, ?{xn}} = ?{PV}(?{D})./
	    </Rewrite>
	<SubSection class=unnumbered>
	  <Title/Grouping/
	  <P>
	    <Rewrite>?={statement}
	      <Rewrite.From/<<(?{S})>>/
	      <Rewrite.To/?{S}/
	    </Rewrite>
	    <Rewrite>?={expression}
	      <Rewrite.From/<<(?{E})>>/
	      <Rewrite.To/?{E}/
	    </Rewrite>
	<SubSection class=unnumbered>
	  <Title/Procedure Definitions/
	  <P>
	    <Rewrite>?={statement}
	      <Rewrite.From
/<<proc &ellipsis; {?{E} ?{P1} &ellipsis; ?{Pn}}
   ?{SE}
end>>/
	      <Rewrite.To
/<<local X in
   X = ?{E}
   proc &ellipsis; {X ?{P1} &ellipsis; ?{Pn}}
      ?{SE}
   end
end>>/
	      <Rewrite.Condition/if ?{E} is no variable./
	    </Rewrite>
	    <Rewrite>?={statement} ?={expression}
	      <Rewrite.From
/<<fun &ellipsis; {?{E1} ?{P1} &ellipsis; ?{Pn}}
   ?{E2}
end>>/
	      <Rewrite.To
/<<proc &ellipsis; {?{E1} ?{P1} &ellipsis; ?{Pn} $}
   ?{E2}
end>>/
	      <Rewrite.Condition/if no&nbsp;<<$>> occurs in
		?{P1} &ellipsis; ?{Pn}./
	    </Rewrite>
	    <Rewrite>?={statement} ?={expression}
	      <Rewrite.From
/<<proc &ellipsis; lazy &ellipsis; {?{E1} ?{P1} &ellipsis; ?{Pn}}
   ?{E2}
end>>/
	      <Rewrite.To
/<<proc &ellipsis; {?{E1} ?{P1} &ellipsis; ?{Pn}}
   {`Value.byNeed` fun {$} ?{E2} end}
end>>/
	      <Rewrite.Condition/where all occurrences of <<lazy>> have
		been removed from the procedure flags./
	    </Rewrite>
	    <Rewrite>?={statement} ?={expression}
	      <Rewrite.From
/<<proc &ellipsis; {?{E1} ?{P1} &ellipsis; ?{Pk} &ellipsis; ?{Pn}}
   ?{E2}
end>>/
	      <Rewrite.To
/<<proc &ellipsis; {?{E1} ?{P1} &ellipsis; ?{Pk'} &ellipsis; ?{Pn}}
   X = ?{E2}
end>>/
	      <Rewrite.Condition/if <<$>> occurs in&nbsp;?{Pk} and no
		other&nbsp;<<$>> occurs in ?{P1} &ellipsis; ?{Pn}.
		?{Pk'}&nbsp;is the result of replacing the&nbsp;<<$>>
		in&nbsp;?{Pk} by&nbsp;<<X>>./
	    </Rewrite>
	    <Rewrite>?={statement} ?={expression}
	      <Rewrite.From
/<<proc &ellipsis; {?{E} ?{P1} &ellipsis; ?{Pn}}
   ?{SE}
end>>/
	      <Rewrite.To
/<<proc &ellipsis; {?{E} X1 &ellipsis; X?{n}}
   case X1#&ellipsis;#X?{n} of ?{P1}#&ellipsis;#?{Pn} then SE
   end
end>>/
	      <Rewrite.Condition/if ?{P1} &ellipsis; ?{Pn} are
		not distinct variables and no <<$>> occurs in
		?{P1} &ellipsis; ?{Pn}./
	    </Rewrite>
	<SubSection class=unnumbered>
	  <Title/Applications/
	  <P>
	    <Rewrite>?={statement}
	      <Rewrite.From/<<{?{E1} &ellipsis; ?{Ek} &ellipsis; ?{En}}>>/
	      <Rewrite.To
/<<local X in
   X = ?{Ek}
   {?{E1} &ellipsis; X &ellipsis; ?{En}}
end>>/
	      <Rewrite.Condition/if ?{Ek} is no variable./
	    </Rewrite>
	<SubSection class=unnumbered>
	  <Title/Boolean and Pattern-Matching Conditionals/
	  <P>
	    <Rewrite>?={else statement} ?={else expression}
	      <Rewrite.From/<<elseif &ellipsis;>>/
	      <Rewrite.To/<<else if &ellipsis; end>>/
	    </Rewrite>
	    <Rewrite>?={else statement} ?={else expression}
	      <Rewrite.From/<<elsecase &ellipsis;>>/
	      <Rewrite.To/<<else case &ellipsis; end>>/
	    </Rewrite>
	    <Rewrite>?={statement}
	      <Rewrite.From
/<<if ?{E} then ?{S}
end>>/
	      <Rewrite.To
/<<if ?{E} then ?{S}
else skip
end>>/
	    </Rewrite>
	    <Rewrite>?={statement} ?={expression}
	      <Rewrite.From
/<<if ?{E} then ?{SE1}
else ?{SE2}
end>>/
	      <Rewrite.To
/<<case ?{E} of true then ?{SE1}
[] false then ?{SE2}
else
   raise error(kernel(boolCaseType &ellipsis;) &ellipsis;) end
end>>/
	      <Rewrite.Condition/where the omitted parts of the exception
		are implementation-dependent./
	    </Rewrite>
	    <Rewrite>?={statement} ?={expression}
	      <Rewrite.From/<<case ?{E} of &ellipsis; end>>/
	      <Rewrite.To
/<<local X in
   X = E
   case X of &ellipsis; end
end>>/
	      <Rewrite.Condition/if ?{E} is no variable./
	    </Rewrite>
	    <Rewrite>?={statement} ?={expression}
	      <Rewrite.From
/<<case ?{E} of ?{C1} [] &ellipsis; [] ?{Cn}
end>>/
	      <Rewrite.To
/<<case ?{E} of ?{C1} [] &ellipsis; [] ?{Cn}
else
   raise error(kernel(noElse &ellipsis;) &ellipsis;) end
end>>/
	      <Rewrite.Condition/where the omitted parts of the exception
		are implementation-dependent./
	    </Rewrite>
	    <!--** missing: expansion of case statement/expression to cond -->
	<SubSection class=unnumbered>
	  <Title/Locks/
	  <P>
	    <Rewrite>?={statement} ?={expression}
	      <Rewrite.From/<<lock ?{E} then ?{SE} end>>/
	      <Rewrite.To
/<<local X in
   X = ?{E}
   lock X then ?{SE} end
end>>/
	      <Rewrite.Condition/if ?{E} is no variable./
	    </Rewrite>
	    <Rewrite>?={expression}
	      <Rewrite.From/<<lock ?{E1} then ?{E2} end>>/
	      <Rewrite.To
/<<local X in
   lock ?{E1} then X = ?{E2} end
   X
end>>/
	    </Rewrite>
	<SubSection class=unnumbered>
	  <Title/Threads/
	  <P>
	    <Rewrite>?={expression}
	      <Rewrite.From/<<thread ?{E} end>>/
	      <Rewrite.To
/<<local X in
   thread X = ?{E} end
   X
end>>/
	    </Rewrite>
	<SubSection class=unnumbered>
	  <Title/Exception Handling/
	  <P>
	    <Rewrite>?={statement} ?={expression}
	      <!--** fix this: -->
	      <Rewrite.From
/<<try ?{SE}
catch ?{C1} [] &ellipsis; [] ?{Cn}
<Span/[ /finally ?{S1}<Span/ ]/
end>>/
	      <!--** fix this: -->
	      <Rewrite.To
/<<try ?{SE}
catch X then
   case X of ?{C1} [] &ellipsis; [] ?{Cn}
   else
      raise X end
   end
<Span/[ /finally ?{S1}<Span/ ]/
end>>/
	      <Rewrite.Condition/if <<?{C1} [] &ellipsis; [] ?{Cn}>>
		does not have the form <<?{x} then ?{S2}>>./
	    </Rewrite>
	    <Rewrite>?={expression}
	      <!--** fix this: -->
	      <Rewrite.From
/<<try ?{E}
<Span/[ /catch ?{x} then ?{E}<Span/ ]/
<Span/[ /finally ?{S}<Span/ ]/
end>>/
	      <!--** fix this: -->
	      <Rewrite.To
/<<local X in
   try Y in
      Y = ?{E}
      X = Y
   <Span/[ /catch ?{x} then X = ?{E}<Span/ ]/
   <Span/[ /finally ?{S}<Span/ ]/
   end
   X
end>>/
	    </Rewrite>
	    <Rewrite>?={statement}
	      <Rewrite.From
/<<try &ellipsis;
finally ?{S}
end>>/
	      <Rewrite.To
/<<local X in
   X = try
	  try &ellipsis; end
	  unit
       catch Y then ex(Y)
       end
   ?{S}
   case X of ex(Z) then
      raise Z end
   else skip
   end
end>>/
	    </Rewrite>
	    <Rewrite>?={statement}
	      <Rewrite.From/<<try ?{SE} end>>/
	      <Rewrite.To/?{SE}/
	    </Rewrite>
	<SubSection class=unnumbered>
	  <Title/Exception Raising/
	  <P>
	    <Rewrite>?={statement}
	      <Rewrite.From/<<raise ?{E} end>>/
	      <Rewrite.To/<<{`Exception.raise` ?{E}}>>/
	    </Rewrite>
	    <Rewrite>?={expression}
	      <Rewrite.From/<<raise ?{E} end>>/
	      <Rewrite.To
/<<{`Exception.raise` ?{E}}
unit>>/
	    </Rewrite>
	    <Rewrite>?={statement} ?={expression}
	      <Rewrite.From/<<raise ?{E1} with ?{E2} end>>/
	      <Rewrite.To
/<<local X in
   X = ?{E1}
   if {`RaiseDebugCheck` X} then
      raise {`RaiseDebugExtend` X ?{E2}} end
   else
      raise X end
   end
end>>/
	    </Rewrite>
	    <!--** missing: definitions of `RaiseDebug{Check,Extend}` -->
	<SubSection class=unnumbered>
	  <Title/Equations/
	  <P>
	    <Rewrite>?={statement}
	      <Rewrite.From/?{E1} = ?{E2}/
	      <Rewrite.To
/<<local X in
   X = ?{E1}
   X = ?{E2}
end>>/
	      <Rewrite.Condition/if ?{E1} is no variable./
	    </Rewrite>
	    <Rewrite>?={statement}
	      <Rewrite.From/<<?{x} = local ?{D} in >>[ ?{S} ]<< ?{E} end>>/
	      <Rewrite.To
/<<local X in
   X = ?{x}
   local ?{D} in >>[ ?{S} ]<< X = ?{E} end
end>>/
	    </Rewrite>
	    <Rewrite>?={statement}
	      <Rewrite.From
/<<?{x} = proc &ellipsis; {$ &ellipsis;} ?{SE} end>>/
	      <Rewrite.To/<<proc &ellipsis; {?{x} &ellipsis;} ?{SE} end>>/
	    </Rewrite>
	    <Rewrite>?={statement}
	      <Rewrite.From/<<?{x} = {?{E} ?{E1} &ellipsis; ?{En}}>>/
	      <Rewrite.To/<<{?{E} ?{E1} &ellipsis; ?{En} X}>>/
	      <Rewrite.Condition/if no <<$>> occurs in ?{E1} &ellipsis; ?{En}
		in pattern position./
	    </Rewrite>
	    <Rewrite>?={statement}
	      <Rewrite.From
/<<?{x} = {?{E} ?{E1} &ellipsis; ?{Ek} &ellipsis; ?{En}}>>/
	      <Rewrite.To/<<{?{E} ?{E1} &ellipsis; ?{Ek'} &ellipsis; ?{En}}>>/
	      <Rewrite.Condition/if <<$>> occurs in&nbsp;?{Ek} in
		pattern position and no other&nbsp;<<$>> occurs in
		?{E1} &ellipsis; ?{En} in pattern position.
		?{Ek'} is the result of replacing the&nbsp;<<$>>
		in pattern position in&nbsp;?{Ek} by&nbsp;?{x}./
	    </Rewrite>
	<SubSection class=unnumbered>
	  <Title/Operators/
	  <P>
	    <!--** missing: table mapping operator names to Core variables -->
	    <Rewrite>?={expression}
	      <Rewrite.From/<<?{o} ?{E}>>/
	      <Rewrite.To/<<{`?{o}` ?{E}}>>/
	      <Rewrite.Condition/where ?{o} <Math/\in/ {<<!!>>, <<~>>}/
	    </Rewrite>
	    <Rewrite>?={expression}
	      <Rewrite.From/<<?{E1} ?{o} ?{E2}>>/
	      <Rewrite.To/<<{`?{o}` ?{E1} ?{E2}}>>/
	      <Rewrite.Condition>where ?{o} <Math/\in/ {<<.>>, <<^>>,
		<<*>>, <</>>, <<div>>, <<mod>>, <<+>>, <<->>, <<==>>,
		<<\=>>, <<&lt;>>, <<=&lt;>>, <<&gt;>>, <<&gt;=>>}
	      </Rewrite.Condition>
	    </Rewrite>
	    <Rewrite>?={expression}
	      <Rewrite.From/<<?{E1} andthen ?{E2}>>/
	      <Rewrite.To
/<<if ?{E1} then ?{E2}
else false
end
>>/
	    </Rewrite>
	    <Rewrite>?={expression}
	      <Rewrite.From/<<?{E1} orelse ?{E2}>>/
	      <Rewrite.To
/<<if ?{E1} then true
else ?{E2}
end
>>/
	    </Rewrite>
	<SubSection class=unnumbered>
	  <Title/Records/
	  <P>
	    <Rewrite>?={expression} ?={pattern}
	      <Rewrite.From/<<[?{EP1} &ellipsis; ?{EPn}]>>/
	      <Rewrite.To/<<?{EP1}|&ellipsis;|?{EPn}|nil>>/
	    </Rewrite>
	    <Rewrite>?={expression} ?={pattern}
	      <Rewrite.From/<<?{EP1}|?{EP2}>>/
	      <Rewrite.To/<<'|'(?{EP1} ?{EP2})>>/
	    </Rewrite>
	    <Rewrite>?={expression} ?={pattern}
	      <Rewrite.From/<<?{EP1}#&ellipsis;#?{EPn}>>/
	      <Rewrite.To/<<'#'(?{EP1} &ellipsis; ?{EPn})>>/
	    </Rewrite>
	    <!--** missing: dots, omitted features -->
	<SubSection class=unnumbered>
	  <Title/Wildcard/
	  <P>
	    <Rewrite>?={expression}
	      <Rewrite.From/<<_>>/
	      <Rewrite.To/<<local X in X end>>/
	    </Rewrite>
	    <Rewrite>?={pattern}
	      <Rewrite.From/<<_>>/
	      <Rewrite.To/<<X>>/
	    </Rewrite>
	<SubSection class=unnumbered>
	  <Title/Named Constants/
	  <P>
	    <Rewrite>?={expression} ?={label} ?={feature}
	      <Rewrite.From/<<unit>>/
	      <Rewrite.To/<<`Unit.'unit'`>>/
	    </Rewrite>
	    <Rewrite>?={pattern}
	      <Rewrite.From/<<unit>>/
	      <Rewrite.To/<<!`Unit.'unit'`>>/
	    </Rewrite>
	    <Rewrite>?={expression} ?={label} ?={feature}
	      <Rewrite.From/<<true>>/
	      <Rewrite.To/<<`Bool.'true'`>>/
	    </Rewrite>
	    <Rewrite>?={pattern}
	      <Rewrite.From/<<true>>/
	      <Rewrite.To/<<!`Bool.'true'`>>/
	    </Rewrite>
	    <Rewrite>?={expression} ?={label} ?={feature}
	      <Rewrite.From/<<false>>/
	      <Rewrite.To/<<`Bool.'false'`>>/
	    </Rewrite>
	    <Rewrite>?={pattern}
	      <Rewrite.From/<<false>>/
	      <Rewrite.To/<<!`Bool.'false'`>>/
	    </Rewrite>
      <Section>
	<Title/Constraint Extensions and Combinators/
	<SubSection class=unnumbered>
	  <Title/Operators/
	  <P>
	    <!--** missing: fd compare -->
	    <Rewrite>?={statement}
	      <Rewrite.From/<<?{E1} ?{o} ?{E2}>>/
	      <Rewrite.To/<<{`?{o}` ?{E2} ?{E1}}>>/
	      <Rewrite.Condition/where ?{o} <Math/\in/ {<<::>>, <<:::>>}./
	    </Rewrite>
	    <Rewrite>?={expression}
	      <Rewrite.From/<<?{E1} ?{o} ?{E2}>>/
	      <Rewrite.To/<<{`?{o}R` ?{E2} ?{E1}}>>/
	      <Rewrite.Condition/where ?{o} <Math/\in/ {<<::>>, <<:::>>}./
	    </Rewrite>
	<SubSection class=unnumbered>
	  <Title/Failure/
	  <P>
	    <Rewrite>?={statement} ?={expression}
	      <Rewrite.From/<<fail>>/
	      <Rewrite.To/<<raise failure(&ellipsis;) end>>/
	      <Rewrite.Condition/where the omitted parts of the exception
		are implementation-dependent./
	    </Rewrite>
	<SubSection class=unnumbered>
	  <Title/Negation/
	  <P>
	    <Rewrite>?={statement} ?={expression}
	      <Rewrite.From/<<not ?{S} end>>/
	      <Rewrite.To
/<<thread
   cond ?{S} then fail
   else skip
   end
end>>/
	    </Rewrite>
	<SubSection class=unnumbered>
	  <Title/Combinators/
	  <P>
	    <Rewrite>?={statement} ?={expression}
	      <Rewrite.From
/<<cond ?{L1} [] &ellipsis; [] ?{Ln}
end>>/
	      <Rewrite.To
/<<cond ?{L1} [] &ellipsis; [] ?{Ln}
else
   raise error(kernel(noElse &ellipsis;) &ellipsis;) end
end>>/
	      <Rewrite.Condition/where the omitted parts of the exception
		are implementation-dependent./
	    </Rewrite>
	    <Rewrite>?={dis statement clause}
	      <Rewrite.From/[ <<?{D} in >> ] ?{S}/
	      <Rewrite.To/[ <<?{D} in >> ] <<?{S} then skip>>/
	    </Rewrite>
	    <Rewrite>?={choice statement clause} ?={choice expression clause}
	      <Rewrite.From/?{SE}/
	      <Rewrite.To/<<skip then ?{SE}>>/
	    </Rewrite>
	<SubSection class=unnumbered>
	  <Title/Constructive Disjunction/
	  <P>
	    <!--** missing: constructive disjunction -->
	    Constructive disjunction is currently not specified.
	    See <Ptr.Extern to="ozdoc:system" key="section.fd.condis">
	    for some information about constructive disjunction.
      <Section>
	<Title/Class Extensions/
	<SubSection class=unnumbered>
	  <Title/Method Names/
	  <P>
	    <Rewrite>?={method head} ?={method head label}
	      <Rewrite.From/<<unit>>/
	      <Rewrite.To/<<!`Unit.'unit'`>>/
	    </Rewrite>
	    <Rewrite>?={method head} ?={method head label}
	      <Rewrite.From/<<true>>/
	      <Rewrite.To/<<!`Bool.'true'`>>/
	    </Rewrite>
	    <Rewrite>?={method head} ?={method head label}
	      <Rewrite.From/<<false>>/
	      <Rewrite.To/<<!`Bool.'false'`>>/
	    </Rewrite>
	<SubSection class=unnumbered>
	  <Title/Locks/
	  <P>
	    <Rewrite>?={expression}
	      <Rewrite.From/<<lock ?{E} end>>/
	      <Rewrite.To
/<<local X in
   lock X = ?{E} end
   X
end>>/
	    </Rewrite>
	<SubSection class=unnumbered>
	  <Title/Equations/
	  <P>
	    <Rewrite>?={statement}
	      <Rewrite.From/<<?{x} = class >>[<< $ >>]<< &ellipsis; end>>/
	      <Rewrite.To/class ?{x} &ellipsis; end>>/
	    </Rewrite>
	<SubSection class=unnumbered>
	  <Title/Operators/
	  <P>
	    <Rewrite>?={expression}
	      <Rewrite.From/<<@?{E}>>/
	      <Rewrite.To/<<{`Object.'@'` ?{E}}>>/
	    </Rewrite>
	    <Rewrite>?={statement}
	      <Rewrite.From/<<?{E1} <- ?{E2}>>/
	      <Rewrite.To/<<{`Object.'<-'` ?{E1} ?{E2}}>>/
	    </Rewrite>
	    <Rewrite>?={expression}
	      <Rewrite.From/<<?{E1} <- ?{E2}>>/
	      <Rewrite.To/<<{`Object.exchange` ?{E1} ?{E2}}>>/
	    </Rewrite>
	    <Rewrite>?={expression}
	      <Rewrite.From/<<?{x} = ?{E1}, ?{E2}>>/
	      <Rewrite.To/<<?{E1}, ?{E2'}>>/
	      <Rewrite.Condition/if exactly one <<$>> occurs in&nbsp;?{E2}
		in pattern position.  ?{E2'} is the result of replacing
		this&nbsp;<<$>> in&nbsp;?{E2} by&nbsp;?{x}./
	    </Rewrite>
	    <Rewrite>?={statement}
	      <Rewrite.From/<<?{E1}, ?{E2}>>/
	      <Rewrite.To/<<{`Object.','` ?{E1} ?{E2}}>>/
	    </Rewrite>
      <Section>
	<Title/Functor Extensions/
  <Back>
    <Bib.Extern id="ISO_8859_1" to="notation.bib" key="ISO_8859_1">
</Book>
