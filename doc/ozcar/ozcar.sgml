<!doctype book system "ozdoc.dtd" [
<!-- $Id$ -->

<!-- Extension to the DTD -->
<!ENTITY % p.mix.local "|Em">
<!ELEMENT Em - - (#PCDATA)>
<!ENTITY emdash PI "emdash">
<!ENTITY endash PI "endash">
<!-- Abbreviations -->
<!-- Processing Instructions -->

]>

<book proglang=oz>
  <front>
    <meta name=ozversion value="3.0">
    <meta name=status value=draft>
    <title/The Mozart Debugger/
    <author.extern to="author.db" key="Benjamin.Lorenz">
    <abstract>
      This manual describes Ozcar, a symbolic debugger which provides
      well known features like single stepping, breakpoints, and
      environment inspectation.  Moreover, it supports debugging of
      multiple threads; their concurrent behaviour can be observed and
      manipulated.
      <p>
      Ozcar has been smoothly integrated into the Oz Programming
      Interface. It can be started and stopped from within Emacs,
      which itself serves both as a source view manager, showing the
      current position in a debugged program by highlightening the
      corresponding source line, and as a breakpoint manager, allowing
      to set breakpoints at arbitrary source lines.
      <p>
      Finally, the application ozd is provided to debug standalone
      programs.
    </abstract>
  <body>
    <chapter>
      <title/Getting Started/
      <p>
      There are two ways in which Ozcar can be invoked. First, from
      the OPI, second, from the Shell.
      <section>
        <title/Invocation from the OPI/
        <p>
        To start Ozcar from the OPI, you have to apply the elisp
        function <span proglang=elisp><<oz-debugger>></span> (<Key/C-c
        C-d/). Executed with prefix argument (<Key/C-u C-c C-d/), the
        Ozcar window gets closed again. Note, however, that this just
        suspends the debugger; after re-opening the window, you can
        continue debugging exactly where you stopped before,
        presupposing that all debugged threads are stopped (see
        single-stepping).
      <section>
        <title/Invocation from the Shell/
        <p>
        Another way of using Ozcar is to debug Oz applications.
        For this purpose, the program ozd is provided (which is an
        oz application itself, btw.). If you want to debug the
        application foo, you just type from the shell ozd foo. This
        starts an Oz engine, which in turn starts Ozcar and Emacs.
    <chapter>
      <title/Ozcar's Main Components/
        <p>
        <ptr to=ozcar.initial> shows the main window after Ozcar has
        been invoked for the first time.
        <figure class="picture" id=ozcar.initial>
          <caption/The main window/
          <p><picture.extern gif to="ozcar-initial.gif">
        </figure>
      <section>
        <title/Thread View/
        <p>
        On the left, there is a window labeled <def>Thread
        Forest</def>. Here you can see all the threads which are
        currently attached. The hierarchical dependencies
        are illustrated by printing all threads as nodes of a tree:
        Children are always inserted below their parent, indented to
        the right.
        <p>
        <Para class=apropos><Title/Thread States/
        Different node chapes correspond to different thread states:
        The state of a thread can be seen as a pair of two values.
        The first one determines if the thread is currently stopped by
        the debugger. Nodes of stopped threads are printed with a
        normal font, running threads are printed in bold face. The
        second component of the pair can have one of the following
        four states:
        <list>
          <entry>runnable
          <item>
          The thread is runnable. This means it can be scheduled by the
          virtual machine. Such a thread is printed in green.
          <entry>blocked
          <item>
          The thread waits for a synchronization condition. It cannot be
          scheduled by the virtual machine. Such a thread is printed in
          yellow.
          <entry>crashed
          <item>
          The thread got an unhandled exception. Such a thread is
          printed in red.
          <entry>dead
          <item>
          The thread is dead. Such a thread is printed in grey.
        </list>
        One thread (if there is any one attached) is the <def>selected
        thread</def>; its node is marked with an asterix. Some actions,
        like single stepping or selecting stack frames, are always
        relative to this thread. You can select a thread by clicking
        on it with the left mouse button or by using the left and
        right cursor keys.
      <section>
        <title/Stack View/
        <p>
        Right beside the thread window, there is another window
        labeled <def>Stack</def>. It prints the stack of the currently
        selected thread. Beware: the topmost frame is displayed at the
        bottom. The procedure arguments are printed in bold face and
        can be further investigated (using the Browser tool) by
        clicking on them.
        <p>
        One frame is the <def>selected frame</def>. It is displayed
        white on blue. Initially, the top frame is selected
        implicitely, without being marked in any way.  You can
        navigate through the stack by clicking on a frame (search for
        a position within the line where no arguments are displayed!)
        or by using the up and down cursor keys.
      <section>
        <title/Variable View/
        <p>
        Below the stack window, there are two windows, labeled
        <def>Local Variables</def> and <def>Global Variables</def>, to
        display information about local and global variables of the
        currently selected stack frame. The local environment is
        sorted by introduction order of the variables in the source
        code, the global environment is sorted alphabetically. As with
        the arguments in the stack window, you can click on the (bold
        faced) values of the variables to browse them.
      <section>
        <title/Status Line/
        <p>
        At the bottom of the main window, there is a <def>Status
        Line</def> which is used to display miscellaneous useful
        information.
      <section>
        <title/Source view/
        <p>
        This view is the only one which is not located inside Ozcar's
        main window. Instead, Emacs serves for this purpose by
        highlightening source code lines appropriately while single stepping.
      <Chapter>
        <title/A First Interaction
        <p>
        So, how can Ozcar actually be used? Consider the following
        small program:
<<<local
   S = 'hello'
in
   {Show S # ' world!'}
end>>>
        <Para class=apropos><Title/Attaching the thread/
        Let's check how this code is executed by the virtual machine
        of mozart&emdash;step by step. The default behaviour of Ozcar
        is to <q>catch</q> all threads which are created by Emacs
        queries, so all you have to do in order to debug the code
        is to feed it in the normal way, for example using the
        Emacs function <span proglang=elisp><<oz-feed-paragraph>></span>
        (<Key/C-c C-p/). You will see Ozcar printing the following:
        <figure class="picture" id=ozcar.hello>
          <caption/The main window after feeding the program/
          <p><picture.extern gif to="ozcar-hello.gif">
        </figure>
        First, you are informed by the status line that there
        has been attached a new thread with thread number 96, and this
        thread was selected automatically. In the thread forest
        window, you see a single, bold faced node, labeled with the
        thread number. The thread has been stopped directly
        after its creation, so the stack window displays a single
        stack frame, containing the first application of the program,
        <<S = 'hello'>>, which is, translated into core syntax,
        <<{Value.'='_ hello}>>. The variable name seems to be lost,
        and in fact, it is, at least in the stack window. But, there
        is no need to despair, we have our variable windows, and
        indeed, the variable <<S>> can be found in the local
        environment, still unbound (visualized by the underscore
        char). The right arrow at the beginning of the line in
        the stack window means: You are about to apply the
        function, but you haven't yet! The number beside the arrow
        means: This is stack frame number one.
        <p>
        In Emacs, the source line which contains
        <<{Value.'='_ hello}>> is highlighted, like this:
        <figure class="picture">
        <caption/Emacs shows the exact position of the stopped thread/
          <p><picture.extern gif to="ozcar-hello3.gif">
        </figure>
        <Para class=apropos><Title/Single Stepping/ Now, how can we
        apply the function <<Value.'='>>? One way is to use the mouse,
        clicking on the <picture.extern inline gif to="step.gif">
        button in the top left corner of the main window. This activates
        the function <Q/step into/, which would enter the body of the
        current application. But since <Q/Value.'='/ is a primitive
        procedure with an implementation in C++, there is no visible body
        and thus, execution stops again directly after leaving the
        application, detectable by the left arrow at the beginning of
        the stack frame line.
        <p>
        You can click another two times on the <picture.extern inline
        gif to="step.gif"> button to apply also the <Q/Show/ application.
        Finally, the stack is empty, and the thread terminates.
        You see the thread's node in the thread view changing it's color
        to grey. To detach the thread, simply click on the
        <picture.extern inline gif to="detach.gif"> button.

      <Chapter>
        <title/Execution Control
        <p>
        This chapter describes the various possibilities to execute
        only well defined parts of your program.  First, the positions
        must be defined where the execution of a thread can be
        stopped.
        <section>
        <title/Step Points/
        <p>
        These positions are called <def>step points</def>.
        What follows is a list of all currently defined step points.
        Note that all such points are dual: Both entry and exit point
        of the corresponding syntactic construct actually constitute
        a step point. Emacs always highlights the whole line where
        the thread is currently stopped, together with a second mark
        which shows the column within this line where the syntactic
        construct starts or ends (see below).
        <list>
          <entry>Definition
          <item>
          A thread can be stopped just before and just after the definition
          of a procedure, function or class. Emacs highlights the
          <<proc>>, <<fun>>, <<class>> or <<end>> keyword, respectively. The
          stack view displays a stack frame containing the single word
          definition.
          <entry>Application
          <item>
          You can stop a thread right before and after a procedure,
          function or method application. Emacs highlights the opening
          and closing brace, respectively. The stack view displays
          a stack frame which contains the procedure, function or
          method name (if there exists any, $ otherwise), together
          which the argument list. All arguments can be browsed by
          clicking on them with the left mouse button.
          <entry>Conditional
          <item>
          You can stop a thread before entering and after leaving a
          conditional. This makes it possible to investigate the
          arbiter. Emacs highlights the <<case>> and <<end>> keyword,
          respectively. The stack view displays a stack frame containing
          the word conditional, followed by the clickable value of
          the arbiter.
          <entry>Thread Creation
          <item>
          A thread can be stopped whenever a new thread is created
          explicitely. Emacs highlights the <<thread>> and <<end>> keyword,
          respectively. The stack view displays a stack frame containing
          the single word thread.
          <entry>Installation of Exception Handlers
          <item>
          A thread can be stopped when an exception handler gets installed.
          Emacs highlights the <<try>> and <<end>> keyword,
          respectively. The stack view displays a stack frame containing
          the single word try.
          <entry>Entering Locks
          <item>
          Finally, you can stop a thread when a locked block is entered
          or leaved. Emacs highlights the <<lock>> and <<end>> keyword,
          respectively. The stack view displays a stack frame containing
          the single word lock, followed by the value of the lock.
        </list>
        <section>
        <title/Action Step Into/
        <p>
        The simplest way how to control the execution of a thread is
        to single step from step point to step point. This is exactly
        what step into (Button <picture.extern inline
        gif to="step.gif">) is doing. You get a very detailed view of how your
        program is executing. Often, it will be too detailed;
        this is where step over and unleash enter the scene.
        <section>
        <title/Action Step Over/
        <p>
        Whenever execution has stopped on a step point, you can decide if you
        want to enter the corresponding inner block (i.e. the procedure
        body, the case clause, etc). If yes, you do a step into (see above).
        If not, you do a step over (Button <picture.extern inline
        gif to="next.gif">). This continues execution until the corresponding
        block has been left again. Typically, Emacs will show you standing
        on an <<end>> keyword or a closing brace then.
        <section>
        <title/Action Unleash/
        <p>
        Actually, step over is a special case of a more generic action,
        which is called unleash (Button <picture.extern inline
        gif to="unleash.gif">). It continues the execution of the thread
        until the currently marked stack frame is just to be removed from
        the stack, or until the thread has finished executing the whole
        stack if no stack frame is marked. Remember you can mark a stack frame
        by clicking on it or by walking to it using the up and down cursor
        keys.
        <section>
        <title/Example
        <p>
        To illustrate the functionality, consider the following program
        which calculates the faculty:
<<<
declare
fun {Fac N}
   case N < 2 then 1 else
      N * {Fac N-1}
   end
end
>>>
        <figure class="picture">
        <caption/Before the action unleash 5/
          <p><picture.extern gif to="fac1.gif">
        </figure>
        <figure class="picture">
        <caption/After the action unleash 5/
          <p><picture.extern gif to="fac2.gif">
        </figure>

        <section>
        <title/Breakpoints/
        <p>
        <subsection>
        <title/Static Breakpoints/
        <p>
        <subsection>
        <title/Dynamic Breakpoints/
        <p>
      <Chapter>
        <title/Environment Inspectation/
        <p>
        <section>
        <title/Evaluation of Expressions/
        <p>
        <section>
        <title/Execution of Statements/
        <p>
      <Chapter>
      <title/Reference Section/
        <p>
        This chapter gives a complete description of the
        debugger's functionality.
        <section>
        <title/The Main Menu/
          <subsection>
          <title/Ozcar/
          <subsection>
          <title/Action/
          <subsection>
          <title/Thread/
          <subsection>
          <title/Stack/
          <subsection>
          <title/Options/
          <subsection>
          <title/Help/
        <section>
        <title/The SubThreads Menu/
          <subsection>
          <title/Ignore/
          <subsection>
          <title/Attach/
          <subsection>
          <title/Unleash 0/
          <subsection>
          <title/Unleash 1/
        <section>
        <title/The Queries Menu/
          <subsection>
          <title/Ignore/
          <subsection>
          <title/Attach/
</book>
