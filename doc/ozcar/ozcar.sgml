<!doctype book system "ozdoc.dtd" [
<!-- $Id$ -->

<!-- Extension to the DTD -->
<!ENTITY % input.local.2 SYSTEM "ozcar.extra">
<!ENTITY % p.mix.local "|note.gui|menu">
<!-- Abbreviations -->
<!-- Processing Instructions -->
<!ENTITY emdash   PI "emdash">
<!ENTITY endash   PI "endash">
<!ENTITY ellipsis PI "ellipsis">

]>

<book proglang=oz>
  <front>
    <!-- Splitting the document into different HTML nodes -->
    <meta name="html.split" value="chapter.start">
    <meta name="html.split" value="chapter.gui">
    <meta name="html.split" value="chapter.example">
    <meta name="html.split" value="chapter.exec">
    <meta name="html.split" value="chapter.env">
    <meta name="html.split" value="chapter.exception">
    <meta name="html.split" value="chapter.reference">
    <meta name="html.split.bib" value="">
    <meta name="html.split.index" value="">

    <meta name=ozversion value="3.0">
    <meta name=status value=draft>

    <title/The Mozart Debugger/
    <author.extern to="author.db" key="Benjamin.Lorenz">
    <abstract>
      This manual describes Ozcar, a symbolic debugger which provides
      well known features like single stepping, breakpoints, and
      environment inspectation.  Moreover, it supports debugging of
      multiple threads; their concurrent behaviour can be observed and
      manipulated.
      <p>
      Ozcar has been smoothly integrated into the Oz Programming
      Interface. It can be started and stopped from within Emacs,
      which itself serves both as a source view manager, showing the
      current position in a debugged program by highlightening the
      corresponding source line, and as a breakpoint manager, allowing
      to set breakpoints at arbitrary source lines.
      <p>
      Finally, the application ozd is provided to debug standalone
      programs.
    </abstract>
  <body>
    <chapter id="chapter.start">
      <title/Getting Started/
      <p>
      There are two ways in which Ozcar can be invoked. First, from
      the OPI, second, from the Shell.
      <section>
        <title/Invocation from the OPI/
        <p>
        To start Ozcar from the OPI, you have to apply the elisp
        function <span proglang=elisp><<oz-debugger>></span> (<Key/C-c
        C-d/). Executed with prefix argument (<Key/C-u C-c C-d/), the
        Ozcar window gets closed again. Note, however, that this just
        suspends the debugger; after re-opening the window, you can
        continue debugging exactly where you stopped before,
        presupposing that all debugged threads are stopped (see
        single-stepping).
      <section>
        <title/Invocation from the Shell/
        <p>
        Another way of using Ozcar is to debug Oz applications.
        For this purpose, the program ozd is provided (which is an
        oz application itself, btw.). If you want to debug the
        application foo, you just type from the shell ozd foo. This
        starts an Oz engine, which in turn starts Ozcar and Emacs.
    <chapter id="chapter.gui">
      <title/Ozcar's Main Components/
        <p>
        <ptr to=ozcar.initial> shows the main window after Ozcar has
        been invoked for the first time.
        <figure class="picture" id=ozcar.initial>
          <caption/The main window/
          <p><picture.extern gif to="ozcar-initial.gif">
        </figure>
      <section>
        <title/Thread View/
        <p>
        On the left, there is a window labeled <def>Thread
        Forest</def>. Here you can see all the threads which are
        currently attached. The hierarchical dependencies
        are illustrated by printing all threads as nodes of a tree:
        Children are always inserted below their parent, indented to
        the right.
        <p>
        <Para class=apropos><Title/Thread States/
        Different node chapes correspond to different thread states:
        The state of a thread can be seen as a pair of two values.
        The first one determines if the thread is currently stopped by
        the debugger. Nodes of stopped threads are printed with a
        normal font, running threads are printed in bold face. The
        second component of the pair can have one of the following
        four states:
        <list>
          <entry>runnable
          <item>
          The thread is runnable. This means it can be scheduled by the
          virtual machine. Such a thread is printed in green.
          <entry>blocked
          <item>
          The thread waits for a synchronization condition. It cannot be
          scheduled by the virtual machine. Such a thread is printed in
          yellow.
          <entry>crashed
          <item>
          The thread got an unhandled exception. Such a thread is
          printed in red.
          <entry>dead
          <item>
          The thread is dead. Such a thread is printed in grey.
        </list>
        One thread (if there is any one attached) is the <def>selected
        thread</def>; its node is marked with an asterix. Some actions,
        like single stepping or selecting stack frames, are always
        relative to this thread. You can select a thread by clicking
        on it with the left mouse button or by using the left and
        right cursor keys.
      <section>
        <title/Stack View/
        <p>
        Right beside the thread window, there is another window
        labeled <def>Stack</def>. It prints the stack of the currently
        selected thread. Beware: the topmost frame is displayed at the
        bottom. The procedure arguments are printed in bold face and
        can be further investigated (using the Browser tool) by
        clicking on them.
        <p>
        One frame is the <def>selected frame</def>. It is displayed
        white on blue. Initially, the top frame is selected
        implicitely, without being marked in any way.  You can
        navigate through the stack by clicking on a frame (search for
        a position within the line where no arguments are displayed!)
        or by using the up and down cursor keys.
      <section>
        <title/Variable View/
        <p>
        Below the stack window, there are two windows, labeled
        <def>Local Variables</def> and <def>Global Variables</def>, to
        display information about local and global variables of the
        currently selected stack frame. The local environment is
        sorted by introduction order of the variables in the source
        code, the global environment is sorted alphabetically. As with
        the arguments in the stack window, you can click on the (bold
        faced) values of the variables to browse them.
      <section>
        <title/Status Line/
        <p>
        At the bottom of the main window, there is a <def>Status
        Line</def> which is used to display miscellaneous useful
        information.
      <section>
        <title/Source view/
        <p>
        This view is the only one which is not located inside Ozcar's
        main window. Instead, Emacs serves for this purpose by
        highlightening source code lines appropriately while single stepping.
        <p>
        <Para class=apropos><Title/Color scheme/
        Emacs gives the highlighted lines different colors, depending on
        how the line was reached by the corresponding thread. The idea
        is quite simple: If nothing really special has happened (just
        some booring step into or unleash), the color is blue, otherwise,
        that is, if a breakpoint has been reached or an unhandled exception
        was raised, the color is red.
      <chapter id="chapter.example">
        <title/A First Interaction
        <p>
        So, how can Ozcar actually be used? Consider the following
        small program:
<<<local
   S = 'hello'
in
   {Show S # ' world!'}
end>>>
        <Para class=apropos><Title/Attaching the thread/
        Let's check how this code is executed by the virtual machine
        of mozart&emdash;step by step. The default behaviour of Ozcar
        is to <q>catch</q> all threads which are created by Emacs
        queries, so all you have to do in order to debug the code
        is to feed it in the normal way, for example using the
        Emacs function <span proglang=elisp><<oz-feed-paragraph>></span>
        (<Key/C-c C-p/). You will see Ozcar printing the following:
        <figure class="picture" id=ozcar.hello>
          <caption/The main window after feeding the program/
          <p><picture.extern gif to="ozcar-hello.gif">
        </figure>
        First, you are informed by the status line that there
        has been attached a new thread with thread number 96, and this
        thread was selected automatically. In the thread forest
        window, you see a single, bold faced node, labeled with the
        thread number. The thread has been stopped directly
        after its creation, so the stack window displays a single
        stack frame, containing the first application of the program,
        <<S = 'hello'>>, which is, translated into core syntax,
        <<{Value.'='_ hello}>>. The variable name seems to be lost,
        and in fact, it is, at least in the stack window. But, there
        is no need to despair, we have our variable windows, and
        indeed, the variable <<S>> can be found in the local
        environment, still unbound (visualized by the underscore
        char). The right arrow at the beginning of the line in
        the stack window means: You are about to apply the
        function, but you haven't yet! The number beside the arrow
        means: This is stack frame number one.
        <p>
        In Emacs, the source line which contains
        <<{Value.'='_ hello}>> is highlighted, like this:
        <figure class="picture">
        <caption/Emacs shows the exact position of the stopped thread/
          <p><picture.extern gif to="ozcar-hello-emacs.gif">
        </figure>
        <Para class=apropos><Title/Single Stepping/ Now, how can we
        apply the function <<Value.'='>>? One way is to use the mouse,
        clicking on the <picture.extern inline gif to="step.gif">
        button in the top left corner of the main window. This activates
        the function <Q/step into/, which would enter the body of the
        current application. But since <Q/Value.'='/ is a primitive
        procedure with an implementation in C++, there is no visible body
        and thus, execution stops again directly after leaving the
        application, detectable by the left arrow at the beginning of
        the stack frame line.
        <p>
        You can click another two times on the <picture.extern inline
        gif to="step.gif"> button to apply also the <Q/Show/ application.
        Finally, the stack is empty, and the thread terminates.
        You see the thread's node in the thread view changing it's color
        to grey. To detach the thread, simply click on the
        <picture.extern inline gif to="detach.gif"> button.

      <chapter id="chapter.exec">
        <title/Execution Control
        <p>
        This chapter describes the various possibilities to execute
        only well defined parts of your program.  First, the positions
        must be defined where the execution of a thread can be
        stopped.
        <section>
        <title/Step Points/
        <p>
        These positions are called <def>step points</def>.
        What follows is a list of all currently defined step points.
        Note that all such points are dual: Both entry and exit point
        of the corresponding syntactic construct actually constitute
        a step point. Emacs always highlights the whole line where
        the thread is currently stopped, together with a second mark
        which shows the column within this line where the syntactic
        construct starts or ends.
        <list>
          <entry>Definition
          <item>
          A thread can be stopped just before and just after the definition
          of a procedure, function or class. Emacs highlights the
          <<proc>>, <<fun>>, <<class>> or <<end>> keyword, respectively. The
          stack view displays a stack frame containing the single word
          definition.
          <entry>Application
          <item>
          You can stop a thread right before and after a procedure,
          function or method application. Emacs highlights the opening
          and closing brace, respectively. The stack view displays
          a stack frame which contains the procedure, function or
          method name (if there exists any, $ otherwise), together
          which the argument list. All arguments can be browsed by
          clicking on them with the left mouse button.
          <entry>Conditional
          <item>
          You can stop a thread before entering and after leaving a
          conditional. This makes it possible to investigate the
          arbiter. Emacs highlights the <<case>> and <<end>> keyword,
          respectively. The stack view displays a stack frame containing
          the word conditional, followed by the clickable value of
          the arbiter.
          <entry>Thread Creation
          <item>
          A thread can be stopped whenever a new thread is created
          explicitely. Emacs highlights the <<thread>> and <<end>> keyword,
          respectively. The stack view displays a stack frame containing
          the single word thread.
          <entry>Installation of Exception Handlers
          <item>
          A thread can be stopped when an exception handler gets installed.
          Emacs highlights the <<try>> and <<end>> keyword,
          respectively. The stack view displays a stack frame containing
          the single word try.
          <entry>Entering Locks
          <item>
          Finally, you can stop a thread when a locked block is entered
          or leaved. Emacs highlights the <<lock>> and <<end>> keyword,
          respectively. The stack view displays a stack frame containing
          the single word lock, followed by the value of the lock.
        </list>
        <section>
        <title/Action Step Into/
        <p>
        The simplest way how to control the execution of a thread is
        to single step from step point to step point. This is exactly
        what step into (<picture.extern inline
        gif to="step.gif">) is doing. You get a very detailed view of how your
        program is executing. Often, it will be too detailed;
        this is where step over and unleash enter the scene.
        <section>
        <title/Action Step Over/
        <p>
        Whenever execution has stopped on a step point, you can decide if you
        want to enter the corresponding inner block (i.e. the procedure
        body, the case clause, etc). If yes, you do a step into (see above).
        If not, you do a step over (<picture.extern inline
        gif to="next.gif">). This continues execution until the corresponding
        block has been left again. Typically, Emacs will show you standing
        on an <<end>> keyword or a closing brace then.
        <section>
        <title/Action Unleash/
        <p>
        Actually, step over is a special case of a more generic action,
        which is called unleash (<picture.extern inline
        gif to="unleash.gif">). It continues the execution of the thread
        until the currently marked stack frame is just to be removed from
        the stack, or until the thread has finished executing the whole
        stack if no stack frame is marked. Remember you can mark a stack frame
        by clicking on it or by walking to it using the up and down cursor
        keys.
        <section>
        <title/Example
        <p>
        To illustrate the functionality, consider the following program
        which calculates the faculty:
<<<
local
   fun {Fac N}
      if N < 2 then 1 else
         N * {Fac N-1}
      end
   end
in
   {Show {Fac 5}}
end
>>>
        Suppose you already pressed the <picture.extern inline
        gif to="step.gif"> button some times, so that there was build
        a nice stack already, and that you have marked stack frame 5
        by clicking on it. What you will see is something like this:

        <figure class="picture">
        <caption/Before the action unleash 5/
          <p><picture.extern gif to="fac1.gif">
        </figure>

        You decide to directly compute the value of <<{Fac 3}>>, so
        what Ozcar needs to do is to continue the thread's execution
        until stack frame 5 is just to be removed from the stack. Unleash 5,
        activated by clicking on the <picture.extern inline
        gif to="unleash.gif"> button, does exactly this:

        <figure class="picture">
        <caption/After the action unleash 5/
          <p><picture.extern gif to="fac2.gif">
        </figure>
        <section>
        <title/Breakpoints/
        <p>
        Single stepping is nice, but often somewhat inconvenient, because
        you need a lot of steps until the interesting section of
        your program is reached. Breakpoints help you here. Ozcar supports
        two flavours of them: static and dynamic ones.
        <subsection>
        <title/Static Breakpoints/
        <p>
        Let's assume you need to debug the base case of the recursion.
        This can easily be achieved by inserting a special breakpoint
        procedure, like this:
<<<
local
   fun {Fac N}
      if N < 2 then
         {Ozcar.breakpoint} 1
      else
         N * {Fac N-1}
      end
   end
in
   {Show {Fac 5}}
end
>>>
        After feeding the code and pressing the <picture.extern inline
        gif to="unleash.gif"> button two times, you are directly at the
        desired position.

        Static breakpoints are useful if you want the breakpoint to
        survive multiple invokations of the mozart system. They
        are inserted before you feed your code. On the other
        hand, you might decide to insert a breakpoint after you
        feeded the code. Then you need dynamic breakpoints.
        <subsection>
        <title/Dynamic Breakpoints/
        <p>
        This flavour of breakpoints can be set directly from Emacs: You
        position the cursor on the line and column where you want to
        change breakpoint information and press (<Key/C-x space/)
        to set or (<Key/C-u C-x space/) to delete a breakpoint.
        <p>
        Unfortunately, there is no information yet about all currently
        defined dynamic breakpoints. You just have to keep them in mind.
        This should be changed in the future.
      <chapter id="chapter.env">
        <title/Environment Inspectation/
        <p>
        In this chapter you learn how to investigate the environment, i.e,
        how to access the values of variables. In fact, we must
        distinguish between two kinds of enviroments in Oz. First, there
        is the toplevel enviroment. Here you find all the variables
        which are defined right after you started the mozart system. The
        procedure <<Show>> is an example, the module <<String>> is another.
        Second, there exist environments for each stack frame
        (i.e. each called procedure)
        of a thread. They consist of local variables, which are the union
        of locally defined variables and formal parameters, and global
        variables, which are referenced inside the procedure, but
        defined outside.
        <p>
        Environment inspectation is easy with Ozcar. In fact,
        it is done automatically for you. Whenever you select a stack
        frame, the variables which are visible inside this frame are
        printed in the variable windows. You can browse the values by
        clicking on their type information.
        <section>
        <title/The Query Dialog/
        <p>
        There might be situations where you have to operate on some
        values which are found in the local or global environment.
        For example, you want to convert a data structure, or to
        bind an unbound variable which causes your program to hang.
        <p>
        For this purpose the query dialog exists. You can open it
        by selecting the Query... menu entry in the Stack menu.
        <subsection>
        <title/Evaluation of Expressions/
        <p>
        Using this dialog, you can evaluate arbitrary Oz expressions.
        For example, if you type
<<<{fun {$ A B C} A+B*C end 1 2 3}>>>
        in the Query line and press the Eval button,
        you get the expected result, <<7>>, in the Result line.
        Another example shows the following picture:
        <figure class="picture">
        <caption/You can evaluate arbitrary expressions/
          <p><picture.extern gif to="eval-expression.gif">
        </figure>
        <subsection>
        <title/Execution of Statements/
        <p>
        Another thing you can do with the Query dialog is to execute
        Oz statements. For example, if you type <<{Browse hugo}>>
        and press the Exec button, the Browser pops up and prints
        the obvious data. Note that the result of executing a statement
        is <<unit>>. Another example comes with
        the next picture. An unbound variable, <<G2>>, is
        bound to the value <<7>>. You would have to reprint the variable
        view's content (by reselecting the stack frame) in order to
        update its information.
        <figure class="picture">
        <caption/You can execute all kinds of statements/
          <p><picture.extern gif to="exec-statement.gif">
        </figure>
      <chapter id="chapter.exception">
        <title/Exceptions/
        <p>
        Errors in programs often manifest themselves by threads throwing
        unhandled exceptions. It would be nice to have a post mortem stack
        to check how the position of the big bang was reached. Moreover,
        the environment should be visible.
        <p>
        Ozcar provides this information. Exceptions which would normally
        be printed in the Emulator buffer are catched by Ozcar, which
        prints the post mortem stack, together with an explanation of
        the exception in the status line. All stack frames
        provide variable information.
        <p>
        Here comes an example. There was forgotten an <<else>> branch
        in the case statement.
<<<
local
   proc {Check X}
      case X
      of foo then {Show 'This is a foo'}
      [] bar then {Show 'This is a bar'}
      end
   end
in
   {Check foobar}
end
>>>
        <figure class="picture">
        <caption/An unhandled exception has been raised/
          <p><picture.extern gif to="exception.gif">
        </figure>
        Emacs prints the location in the source where the error
        happened. Note that the bar is printed in red, as you reached
        the position unexpectedly.
        <figure class="picture">
        <caption/Emacs shows the position where the error occured/
          <p><picture.extern gif to="exception-emacs.gif">
        </figure>
      <chapter id="chapter.reference">
      <title/Reference Section/
        <p>
        This chapter gives a complete description of all the
        menus Ozcar provides.
        <section>
        <title/The Main Menu/
          <p>
          The main menu is located on the top of Ozcar's main window.
          <subsection>
          <title/Ozcar/
          <p>
          <list>
            <entry><menu/About&ellipsis;/
            <item>
            Pops up an info box containing author and compilation information
            <entry><menu/Destroy/
            <item>
            Closes the internal Ozcar object. Use this menu entry only
            if Ozcar hangs, as all information about currently attached
            threads gets lost.
            <entry><menu key="C-x"/Suspend/
            <item>
            Closes the main window, sets the mozart emulator to non debug mode,
            and causes the compiler to generate non debug code. Information
            about currently attached threads is preserved.
          </list>
          <subsection>
          <title/Action/
          <p>
          <list>
            <entry><menu key="s"/Step Into/
            <item>
            Do exactly one step (stop again at the next step point, enter
            procedures). Identical to pressing the <picture.extern inline
            gif to="step.gif"> button.
            <entry><menu key="n"/Step Over/
            <item>
            Do one step, jump over procedures or other blocks which constitute
            a step point. Identical to pressing the <picture.extern inline
            gif to="next.gif"> button.
            <entry><menu key="c"/Unleash/
            <item>
            Continue execution until the marked stack frame is about to be
            removed from the stack, or until the stack is empty if
            no frame is marked. Identical to pressing the
            <picture.extern inline gif to="unleash.gif"> button.
            <entry><menu key="z"/Stop/
            <item>
            Stop the current thread at the next step point it reaches.
            Identical to pressing the
            <picture.extern inline gif to="stop.gif"> button.
          </list>
          <subsubsection>
          <title/The Detach submenu/
          <p>
          This menu contains some useful entries to
          detach one or more attached threads:
          <list>
            <entry><menu key="d"/Current/
            <item>
            Detach the current thread. Identical to pressing the
            <picture.extern inline gif to="detach.gif"> button.
            <entry><menu key="C-d"/All But Current/
            <item>
            Leave the current thread alone in Ozcar's thread forest. Detach
            all the others, let them continue to run (if they are not dead).
            <entry><menu key="M-d"/All/
            <item>
            Detach all threads, let them continue to run
            (if they are not dead).
            <entry><menu key="M-u"/All Dead/
            <item>
            Detach all dead threads.
          </list>
          <subsubsection>
          <title/The Terminate submenu/
          <p>
          This menu contains some useful entries to
          detach <em>and kill</em> one or more attached threads:
          <list>
            <entry><menu key="t"/Current/
            <item>
            Detach and kill the current thread. Identical to pressing the
            <picture.extern inline gif to="kill.gif"> button.
            <entry><menu key="C-t"/All But Current/
            <item>
            Leave the current thread alone in Ozcar's thread forest. Detach
            and kill all the others.
            <entry><menu key="M-t"/All/
            <item>
            Detach and kill all threads.
          </list>
          <subsection>
          <title/Thread/
          <p>
          <list>
            <entry><menu key="Left"/Previous/
            <item>
            Select the thread which is located above the currently
            selected thread in the thread view. If the current thread
            is the first thread in the thread view, the last thread (at
            the bottom) is selected.
            <entry><menu key="Right"/Next/
            <item>
            Select the thread which is located below the currently
            selected thread in the thread view. If the current thread
            is the last thread in the thread view, the first thread (at
            the top) is selected.
            <entry><menu key="C-s"/Status/
            <item>
            Print some useful information about the currently attached
            threads, for example:
            <em>2 attached threads, currently selected: 58/1
            (stopped, runnable)</em>. The first part of the information
            is obvious. The two numbers associated with the selected thread
            are the thread id and the parent thread id. In parentheses,
            information is given if the selected thread is stopped or
            running, and if it is runnable, blocked or terminated.


          </list>
          <subsection>
          <title/Stack/
          <p>
          <list>
            <entry><menu key="Up"/Previous Frame/
            <item>
            Select the previous stack frame (if it exists)
            of the currently selected thread. Note that the stack grows
            to the bottom of the window, so you will reach an older frame.
            <entry><menu key="Down"/Next Frame/
            <item>
            Select the next stack frame (if it exists)
            of the currently selected thread. Note that the stack grows
            to the bottom of the window, so you will reach a younger frame.
            <entry><menu key="C-l"/Re-Calculate/
            <item>
            Update the stack view. You may see special,
            compiler-generated stack frames then, as well as some
            variables which have been bound in the meanwhile appear
            which their value instead of an underscore. (There is
            <em>no</em> automatic update which forces the stack view
            to display a variable's value as soon as it becomes known.)
          </list>
          <subsection>
          <title/Options/
          <subsection>
          <title/Help/
        <section>
        <title/The SubThreads Menu/
          <subsection>
          <title/Ignore/
          <subsection>
          <title/Attach/
          <subsection>
          <title/Unleash 0/
          <subsection>
          <title/Unleash 1/
        <section>
        <title/The Queries Menu/
          <subsection>
          <title/Ignore/
          <subsection>
          <title/Attach/
</book>
