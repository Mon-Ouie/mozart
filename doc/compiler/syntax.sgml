<Appendix id="appendix.syntax">
  <Title/Syntax Tree Format/
  <Para class=apropos><Title/Input/
    <Grammar.Rule>?={input}
      <Grammar.Alt/<<parseError>>/
      <Grammar.Alt/<<[?={compilation unit}]>>/
  <Para class=apropos><Title/Compilation Units/
    <Grammar.Rule>?={compilation unit}
      <Grammar.Alt/?={phrase}/
      <Grammar.Alt/?={directive}/
      <Grammar.Alt/<<fDeclare(?={phrase} ?={phrase} ?={coord})>>/
    <Grammar.Rule>?={directive}
      <Grammar.Alt/<<dirSwitch([?={switch}])>>/
      <Grammar.Alt/<<dirPushSwitches>>/
      <Grammar.Alt/<<dirPopSwitches>>/
      <Grammar.Alt/<<dirLocalSwitches>>/
    <Grammar.Rule>?={switch}
      <Grammar.Alt/<<on(?={switch name} ?={coord})>>/
      <Grammar.Alt/<<off(?={switch name} ?={coord})>>/
    <Grammar.Rule>?={switch name}
      <Grammar.Alt/?={atom}/
  <Section>
    <Title/The Base Language/
    <Para class=apropos><Title/Phrases/
      At the syntactical level, statements can in general not be distinguished
      from expressions.  Both are subsumed by ?={phrase}.
      <Grammar.Rule>?={phrase}
	<Grammar.Alt/<<fStepPoint(?={phrase} ?={atom} ?={coord})>>/
	<Grammar.Alt/<<fAnd(?={phrase} ?={phrase})>>/
	<Grammar.Alt/<<fEq(?={phrase} ?={phrase} ?={coord})>>/
	<Grammar.Alt/<<fAssign(?={phrase} ?={phrase} ?={coord})>>/
	<Grammar.Alt/<<fOrElse(?={phrase} ?={phrase} ?={coord})>>/
	<Grammar.Alt/<<fAndThen(?={phrase} ?={phrase} ?={coord})>>/
	<Grammar.Alt/<<fOpApply(?={atom} [?={phrase}] ?={coord})>>/
	<Grammar.Alt/<<fOpApplyStatement(?={atom} [?={phrase}]>>/
	<Grammar.Alt space/<<                  ?={coord})>>/
	<Grammar.Alt/<<fObjApply(?={phrase} ?={phrase} ?={coord})>>/
	<Grammar.Alt/<<fAt(?={phrase} ?={coord})>>/
	<Grammar.Alt/?={atom literal}/
	<Grammar.Alt/?={variable}/
	<Grammar.Alt/?={wildcard}/
	<Grammar.Alt/<<fSelf(?={coord})>>/
	<Grammar.Alt/<<fDollar(?={coord})>>/
	<Grammar.Alt/?={int literal}/
	<Grammar.Alt/<<fFloat(?={float} ?={coord})>>/
	<Grammar.Alt/<<fRecord(?={label} [?={record argument}])>>/
	<Grammar.Alt/<<fOpenRecord(?={label} [?={record argument}])>>/
	<Grammar.Alt/<<fApply(?={phrase} [?={phrase}] ?={coord})>>/
	<Grammar.Alt/<<fProc(?={phrase} [?={phrase}] ?={phrase}>>/
	<Grammar.Alt space/<<      [?={proc flag}] ?={coord})>>/
	<Grammar.Alt/<<fFun(?={phrase} [?={phrase}] ?={phrase}>>/
	<Grammar.Alt space/<<      [?={proc flag}] ?={coord})>>/
	<Grammar.Alt
	  /<<fFunctor(?={phrase} [?={functor descriptor}] ?={coord})>>/
	<Grammar.Alt/<<fClass(?={phrase} [?={class descriptor}]>>/
	<Grammar.Alt space/<<       [?={meth}] ?={coord})>>/
	<Grammar.Alt/<<fLocal(?={phrase} ?={phrase} ?={coord})>>/
	<Grammar.Alt
	  /<<fBoolCase(?={phrase} ?={phrase} ?={opt else} ?={coord})>>/
	<Grammar.Alt/<<fCase(?={phrase} [?={case clause}]>>/
	<Grammar.Alt space/<<      ?={opt else} ?={coord})>>/
	<Grammar.Alt/<<fLockThen(?={phrase} ?={phrase} ?={coord})>>/
	<Grammar.Alt/<<fLock(?={phrase} ?={coord})>>/
	<Grammar.Alt/<<fThread(?={phrase} ?={coord})>>/
	<Grammar.Alt/<<fTry(?={phrase} ?={catch} ?={finally} ?={coord})>>/
	<Grammar.Alt/<<fRaise(?={phrase} ?={coord})>>/
	<Grammar.Alt/<<fRaiseWith(?={phrase} ?={phrase} ?={coord})>>/
	<Grammar.Alt/<<fSkip(?={coord})>>/
      <Grammar.Rule>?={label}
	<Grammar.Alt/?={atom literal}/
	<Grammar.Alt/?={naked variable}/
      <Grammar.Rule>?={atom literal}
	<Grammar.Alt/<<fAtom(?={literal} ?={coord})>>/
      <!--** eliminate naked variable? -->
      <Grammar.Rule>?={naked variable}
	<Grammar.Alt/<<fVar(?={atom} ?={coord})>>/
      <Grammar.Rule>?={variable}
	<Grammar.Alt/?={naked variable}/
	<Grammar.Alt/<<fEscape(?={naked variable} ?={coord})>>/
      <Grammar.Rule>?={wildcard}
	<Grammar.Alt/<<fWildcard(?={coord})>>/
      <Grammar.Rule>?={int literal}
	<Grammar.Alt/<<fInt(?={int} ?={coord})>>/
      <Grammar.Rule>?={record argument}
	<Grammar.Alt/?={phrase}/
	<Grammar.Alt/<<fColon(?={feature} ?={phrase})>>/
      For the moment, the only recognized flags are <<instantiate>>, <<lazy>>,
      <<dynamic>>, and <<native>>.
      <Grammar.Rule>?={proc flag}
	<Grammar.Alt/?={atom}/
    <Para class=apropos><Title/Functors/
      <Grammar.Rule>?={functor descriptor}
	<Grammar.Alt/<<fRequire([?={import decl}] ?={coord})>>/
	<Grammar.Alt/<<fPrepare(?={phrase} ?={phrase} ?={coord})>>/
	<Grammar.Alt/<<fImport([?={import decl}] ?={coord})>>/
	<Grammar.Alt/<<fExport([?={export decl}] ?={coord})>>/
	<Grammar.Alt/<<fDefine(?={phrase} ?={phrase} ?={coord})>>/
      <Grammar.Rule>?={import decl}
	<Grammar.Alt/<<fImportItem(?={naked variable} [?={aliased feature}]>>/
	<Grammar.Alt space/<<            ?={opt import at})>>/
      <Grammar.Rule>?={aliased feature}
	<Grammar.Alt/?={feature no var}/
	<Grammar.Alt/<<?={naked variable}#?={feature no var}>>/
      <Grammar.Rule>?={opt import at}
	<Grammar.Alt/<<fNoImportAt>>/
	<Grammar.Alt/<<fImportAt(?={atom literal})>>/
      <Grammar.Rule>?={export decl}
	<Grammar.Alt/<<fExportItem(?={export item})>>/
      <Grammar.Rule>?={export item}
	<Grammar.Alt/?={naked variable}/
	<Grammar.Alt/<<fColon(?={feature no var} ?={naked variable})>>/
    <Para class=apropos><Title/Classes/
      <Grammar.Rule>?={class descriptor}
	<Grammar.Alt/<<fFrom([?={phrase}] ?={coord})>>/
	<Grammar.Alt/<<fProp([?={phrase}] ?={coord})>>/
	<Grammar.Alt/<<fAttr([?={attr or feat}] ?={coord})>>/
	<Grammar.Alt/<<fFeat([?={attr or feat}] ?={coord})>>/
      <Grammar.Rule>?={attr or feat}
	<Grammar.Alt/?={escaped feature}/
	<Grammar.Alt/<<?={escaped feature}#?={phrase}>>/
      <Grammar.Rule>?={meth}
	<Grammar.Alt/<<fMeth(?={meth head} ?={phrase} ?={coord})>>/
      <Grammar.Rule>?={meth head}
	<Grammar.Alt/?={meth head 1}/
	<Grammar.Alt/<<fEq(?={meth head 1} ?={naked variable} ?={coord})>>/
      <Grammar.Rule class=compact>?={meth head 1}
	<Grammar.Alt/?={atom literal}/
	<Grammar.Alt/?={variable}/
	<Grammar.Alt/<<fRecord(?={meth head label} [?={meth argument}])>>/
	<Grammar.Alt/<<fOpenRecord(?={meth head label} [?={meth argument}])>>/
      <Grammar.Rule>?={meth head label}
	<Grammar.Alt/?={atom literal}/
	<Grammar.Alt/?={variable}/
      <Grammar.Rule class=compact>?={meth argument}
	<Grammar.Alt/<<fMethArg(?={meth arg term} ?={default})>>/
	<Grammar.Alt
	  /<<fMethColonArg(?={feature} ?={meth arg term} ?={default})>>/
      <Grammar.Rule>?={meth arg term}
	<Grammar.Alt/?={naked variable}/
	<Grammar.Alt/?={wildcard}/
	<Grammar.Alt/<<fDollar(?={coord})>>/
      <Grammar.Rule>?={default}
	<Grammar.Alt/<<fNoDefault>>/
	<Grammar.Alt/<<fDefault(?={phrase} ?={coord})>>/
    <Para class=apropos><Title/Features/
      <Grammar.Rule>?={feature no var}
	<Grammar.Alt/?={atom literal}/
	<Grammar.Alt/?={int literal}/
      <Grammar.Rule>?={feature}
	<Grammar.Alt/?={feature no var}/
	<Grammar.Alt/?={naked variable}/
      <Grammar.Rule>?={escaped feature}
	<Grammar.Alt/?={feature no var}/
	<Grammar.Alt/?={variable}/
    <Para class=apropos><Title/Other/
      <Grammar.Rule>?={case clause}
	<Grammar.Alt/<<fCaseClause(?={pattern} ?={phrase})>>/
      <Grammar.Rule>?={pattern}
	<Grammar.Alt/?={phrase}/
	<Grammar.Alt
	  /<<fSideCondition(?={phrase} ?={phrase} ?={phrase} ?={coord})>>/
      <Grammar.Rule>?={catch}
	<Grammar.Alt/<<fNoCatch>>/
	<Grammar.Alt/<<fCatch([?={case clause}] ?={coord})>>/
      <Grammar.Rule>?={finally}
	<Grammar.Alt/<<fNoFinally>>/
	<Grammar.Alt/?={phrase}/
      <Grammar.Rule>?={opt else}
	<Grammar.Alt/<<fNoElse(?={coord})>>/
	<Grammar.Alt/?={phrase}/
    <Para class=apropos><Title/Coordinates/
      Each triple consisting of an ?={atom} and two ?={int}s denotes a
      file name (<<''>> if none known), a line number (starting at&nbsp;<<1>>;
      required) and a column number (starting at&nbsp;<<0>>; <<~1>> if none
      known).  If two triples are given, then they denote the starting and
      ending coordinates of a construct.  A <<pos>> may be turned into a
      <<fineStep>> or a <<coarseStep>>, denoting a step point for debugging.
      <<unit>> is an unknown coordinate.
      <Grammar.Rule>?={coord}
	<Grammar.Alt/<<pos(?={atom} ?={int} ?={int})>>/
	<Grammar.Alt
	  /<<pos(?={atom} ?={int} ?={int} ?={atom} ?={int} ?={int})>>/
	<Grammar.Alt/<<fineStep(?={atom} ?={int} ?={int})>>/
	<Grammar.Alt
	  /<<fineStep(?={atom} ?={int} ?={int} ?={atom} ?={int} ?={int})>>/
	<Grammar.Alt/<<coarseStep(?={atom} ?={int} ?={int})>>/
	<Grammar.Alt
	  /<<coarseStep(?={atom} ?={int} ?={int} ?={atom} ?={int} ?={int})>>/
	<Grammar.Alt/<<unit>>/
  <Section>
    <Title/Finite Domain Extensions/
    <P>
      <Grammar.Rule>?={phrase}
	<Grammar.Alt add/?={fd expression}/
	<Grammar.Alt/<<fFail(?={coord})>>/
	<Grammar.Alt/<<fNot(?={phrase} ?={coord})>>/
	<Grammar.Alt/<<fCond([?={clause}] ?={opt else} ?={coord})>>/
	<Grammar.Alt/<<fOr([?={clause opt then}] for ?={coord})>>/
	<Grammar.Alt/<<fOr([?={clause opt then}] fdis ?={coord})>>/
	<Grammar.Alt/<<fOr([?={clause}] fchoice ?={coord})>>/
	<Grammar.Alt/<<fCondis([[?={fd expression}]] ?={coord})>>/
      <Grammar.Rule class=compact>?={fd expression}
	<Grammar.Alt/<<fFdCompare(?={atom} ?={phrase} ?={phrase} ?={coord})>>/
	<Grammar.Alt/<<fFdIn(?={atom} ?={phrase} ?={phrase} ?={coord})>>/
      <Grammar.Rule>?={clause}
	<Grammar.Alt/<<fClause(?={phrase} ?={phrase} ?={phrase})>>/
      <Grammar.Rule>?={clause opt then}
	<Grammar.Alt/<<fClause(?={phrase} ?={phrase} ?={opt then})>>/
      <Grammar.Rule>?={opt then}
	<Grammar.Alt/<<fNoThen(?={coord})>>/
	<Grammar.Alt/?={phrase}/
  <Section>
    <Title/Gump Extensions/
    <P>
      <Grammar.Rule class=compact>?={compilation unit}
	<Grammar.Alt add
	  /<<fSynTopLevelProductionTemplates([?={prod clause}])>>/
      <Grammar.Rule>?={phrase}
	<Grammar.Alt add
	  /<<fScanner(?={naked variable}>>/
	<Grammar.Alt space
	  /<<         [?={class descriptor}] [?={meth}]>>/
	<Grammar.Alt space
	  /<<         [?={scanner rule}] ?={atom} ?={coord})>>/
	<Grammar.Alt
	  /<<fParser(?={naked variable}>>/
	<Grammar.Alt space
	  /<<        [?={class descriptor}] [?={meth}]>>/
	<Grammar.Alt space
	  /<<        ?={token clause} [?={parser descriptor}] ?={int}>>/
	<Grammar.Alt space
	  /<<        ?={coord})>>/
      <Grammar.Rule>?={grammar symbol}
	<Grammar.Alt/?={atom literal}/
	<Grammar.Alt/?={naked variable}/
    <Para class=apropos><Title/Scanners/
      <Grammar.Rule>?={scanner rule}
	<Grammar.Alt/<<fMode(?={naked variable} [?={mode descriptor}])>>/
	<Grammar.Alt/?={lex clause}/
      <Grammar.Rule>?={mode descriptor}
	<Grammar.Alt/<<fInheritedModes([?={naked variable}])>>/
	<Grammar.Alt/?={lex clause}/
      <Grammar.Rule>?={lex clause}
	<Grammar.Alt/<<fLexicalAbbreviation(?={grammar symbol} ?={regex})>>/
	<Grammar.Alt/<<fLexicalRule(?={regex} ?={phrase})>>/
      <Grammar.Rule>?={regex}
	<Grammar.Alt/?={string}/
    <Para class=apropos><Title/Parsers/
      <Grammar.Rule>?={token clause}
	<Grammar.Alt/<<fToken([?={token decl}])>>/
      <Grammar.Rule>?={token decl}
	<Grammar.Alt/?={atom literal}/
	<Grammar.Alt/<<?={atom literal}#?={phrase}>>/
      <Grammar.Rule>?={parser descriptor}
	<Grammar.Alt/?={prod clause}/
	<Grammar.Alt/?={syntax rule}/
      <Grammar.Rule class=compact>?={prod clause}
	<Grammar.Alt/<<fProductionTemplate(?={prod key} [?={prod param}]>>/
	<Grammar.Alt space
	  /<<                    [?={syntax rule}] [?={syn expression}]>>/
	<Grammar.Alt space
	  /<<                    [?={prod ret}])>>/
      <Grammar.Rule>?={prod param}
	<Grammar.Alt/?={naked variable}/
	<Grammar.Alt/?={wildcard}/
      <Grammar.Rule>?={prod key}
	<Grammar.Alt/<<none#?={string}>>/
	<Grammar.Alt/<<?={atom}#?={string}>>/
      <Grammar.Rule>?={prod ret}
	<Grammar.Alt/<<none>>/
	<Grammar.Alt/?={naked variable}/
	<Grammar.Alt/<<fDollar(?={coord})>>/
      <Grammar.Rule>?={syntax rule}
	<Grammar.Alt/<<fSyntaxRule(?={grammar symbol} [?={syn formal}]>>/
	<Grammar.Alt space/<<            ?={syn expression})>>/
      <Grammar.Rule>?={syn formal}
	<Grammar.Alt/?={naked variable}/
	<Grammar.Alt/?={wildcard}/
	<Grammar.Alt/<<fDollar(?={coord})>>/
      <Grammar.Rule class=compact>?={syn expression}
	<Grammar.Alt/<<fSynApplication(?={grammar symbol} [?={phrase}])>>/
	<Grammar.Alt/<<fSynAction(?={phrase})>>/
	<Grammar.Alt
	  /<<fSynSequence([?={naked variable}] [?={syn expression}])>>/
	<Grammar.Alt/<<fSynAlternative([?={syn expression}])>>/
	<Grammar.Alt/<<fSynAssignment(?={variable} ?={syn expression})>>/
	<Grammar.Alt
	  /<<fSynTemplateInstantiation(?={prod key} [?={syn expression}]>>/
	<Grammar.Alt space/<<                          ?={coord})>>/
</Appendix>
