<Chapter id="chapter.directives">
  <Title/Directives/
  <Para class=apropos><Title/Directive Syntax/
    The Mozart compiler understands the full syntax of Oz programs.
    Additionally, it also accepts <Def/directives/ in its input.
    A directive can start anywhere on a line and is introduced by
    a backslash; it always extends until the end of the line.
  <P>
    Directives come in two flavors.  So-called <Def/compiler directives/
    provide a way to change the compiler's switches, whereas <Def/macro
    directives/ can be used for inserting files or performing compilation
    conditionally.  While macro directives may appear between any two tokens
    in the input, the use of compiler directives underlies restrictions as
    described below.
  <Para class=apropos><Title/Compilation Units/
    A single input file is split into a number of compilation units as
    follows:
    <List>
      <Item>
        A sequence of compiler directives forms a compilation unit.
      <Item>
        Each <<declare>> statement starts a compilation unit which includes
        all following non-<<declare>> statements.
      <Item>
        A sequence of statements without <<declare>> forms a compilation
        unit.
    </List>
    Note that this implies that compiler directives can only appear between
    top-level Oz statements.
  <P>
    All compilation units in a file are processed sequentially.
  <Section>
    <Title/Compiler Directives/
    <P>
      <List>
        <Entry><<\switch>> ( <Q class=terminal/+/ ?={switchname} |
          <Q class=terminal/-/ ?={switchname} )*
        <Item>
          sets (<Q class=terminal/+/) &resp; resets (<Q class=terminal/-/)
          the specified switches.  The values for ?={switchname} the compiler
          understands are described in <Ptr to="appendix.switches">.  Case
          matters.
        <Entry><<\pushSwitches>>
        <Item>
          saves the current settings of all switches onto the internal switch
          state stack.
        <Entry><<\popSwitches>>
        <Item>
          restores all switch settings from the topmost element of the
          internal switch state stack, provided it is not empty, else does
          nothing.
        <Entry><<\localSwitches>>
        <Item>
          pushes the settings of all current switches onto the internal
          switch state stack.  These settings are automatically restored
          after that last compilation unit of the current input has been
          processed.
      </List>
  <Section id="section.directives.macro">
    <Title/Macro Directives/
    <P>
      <List>
        <Entry><<\line>> ?={filename}
        <Entry><<\line>> ?={int} ?={filename}
        <Item>
          sets the internal file name (and line number for the next line)
          to the given values.  This data will appear in the error messages
          and debug information generated by the compiler.
        <Entry><<\insert>> ?={filename}
        <Item>
          substitutes itself by the contents of the referenced file.
      </List>
    <Para class=apropos><Title/Macro Names/
      The compiler stores a set of so-called <Def/macro names/, used to
      control conditional compilation.  Macro names have the same syntax
      as Oz variables (but that is about all they have in common).
      Initially, this set consists of macro names describing the Oz
      version number, &eg;, when running Oz&nbsp;3.0.10, the variables
      <<Oz_3>>, <<Oz_3_0>>, and <<Oz_3_0_10>> are macro names.
      <List>
        <Entry><<\define>> ?={variable}
        <Item>
          adjoins ?={variable} to the set of macro names.
        <Entry><<\undef>> ?={variable}
        <Item>
          removes ?={variable} from the set of macro names.
        <Entry><<\ifdef>> ?={variable}
        <Item>
          only compiles the text until the next balanced <<\else>> or
          <<\endif>> if ?={variable} is a macro name.
        <Entry><<\ifndef>> ?={variable}
        <Item>
          ignores the text until the next balanced <<\else>> or <<\endif>>
          if ?={variable} is a macro name.
        <Entry><<\else>>
        <Item>
          causes the text until the next balanced <<\else>> or <<\endif>>
          to be
          <List>
            <Item>
              ignored, if the <<\else>> occurred after a text region that was
              being compiled;
            <Item>
              compiled, if the <<\else>> occurred after a text region that was
              being ignored.
          </List>
        <Entry><<\endif>>
        <Item>
          terminates the active <<\ifdef>> or <<\ifndef>>.
      </List>
</Chapter>
