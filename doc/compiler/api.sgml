<Chapter id="chapter.api">
  <Title/Application Programmer's Interface/
  <P>
    The compiler is available to Mozart applications through the module
    <<Compiler>>.  This chapter describes the functionality provided by
    that module and its classes.
  <P>
    First, a number of additional secondary type names used in this
    description is introduced in <Ptr to="section.api.types">, then the
    <<Compiler>> module is described in <Ptr to="section.api.module">.
    The material in that section should prove sufficient for most cases.
    The remainder of the chapter is intended for advanced uses.
  <P>
    An arbitrary number of compilers may be instantiated, each with its
    own internal state, and used concurrently.  We distinguish between
    <Def/compiler engines/, described in <Ptr to="section.api.engines">,
    which store the state of a compiler and perform the compilation
    proper, and <Def/compiler interfaces/, described in <Ptr
    to="section.api.interfaces">, which allow to observe the
    activities of compiler engines and to react to them.  Both
    of these use the narrator&slash;listener mechanism described
    in <Ptr to="appendix.narrator">; familiarity with this is
    assumed.
  <P>
    Finally, serving the purpose of examples, the provided abstractions
    are explained in terms of compiler engines and interfaces in <Ptr
    to="section.api.abstractions">.
  <Section id="section.api.types">
    <Title/Additional Secondary Types/
    <P>
      This section describes additional secondary types used in the
      descriptions in this chapter.  The conventions defined in <Ptr
      to="mozart-base"> will be respected.
      <List>
	<Entry>?_{Coord}
	<Item>
	  stands for information about source coordinates.  This is
	  either <<unit>> if no information is known or a tuple
	  <<pos(?_{FileName} ?_{Line} ?_{Column})>>, where ?_{FileName}
	  is represented as an atom (<<''>> meaning <Q class=quasi/unknown/)
	  and ?_{Line} and ?_{Column} are integers.  Line numbering begins
	  at&nbsp;<<1>> and column numbering at&nbsp;<<0>>; a column number
	  of <<~1>> means <Q class=quasi/unknown/.
	<Entry>?_{SwitchName}
	<Item>
	  is an atom which must be a valid switch name (see <Ptr
	  to="appendix.switches">).
	<Entry>?_{PrintName}
	<Item>
	  is an atom which must be a valid variable print name.
	<Entry>?_{Env}
	<Item>
	  represents an environment, represented as a record whose
	  features are valid print names.
      </List>
  <Section id="section.api.module">
    <Title/The <<Compiler>> Module/
    <P>
      <List>
	<Entry><<evalExpression>>
	<Synopsis>
	  <<{Compiler.evalExpression ?+{V} ?+{Env} ??{KillP} ?_{X}}>>
	<Item>
	  evaluates an expression, given as a virtual string&nbsp;?_{V}, in
	  a base environment enriched by the bindings given by ?_{Env}, either
	  returning the result&nbsp;?_{X} of the evaluation or raising an
	  exception.  Furthermore, the variable ?_{KillP} is bound to a
	  nullary procedure which, when applied, interrupts compilation.

	<Entry><<virtualStringToValue>>
	<Synopsis>
	  <<{Compiler.virtualStringToValue ?+{V} ?_{X}}>>
	<Item>
	  is a replacement for <<System.virtualStringToValue>>, which
	  was available in Mozart's predecessor DFKI Oz.
	<P>
	  Note that you are discouraged from using this for large
	  data structures:  Because it is much more powerful than
	  <<System.virtualStringToValue>>, it can also be much less
	  efficient.  Rather, you should use pickling and unpickling
	  of data structures&nbsp;<Ptr to="mozart-ap">.

	<Entry><<engine>>
	<Synopsis>
	  <<Compiler.engine>>
	<Item>
	  is the final class from which compiler engines can be instantiated.
	  This is described in detail in <Ptr to="section.api.engines">.

	<Entry><<interface>>
	<Synopsis>
	  <<Compiler.interface>>
	<Item>
	  is a class providing a simple mechanism to create
	  compiler interfaces.  It is described in detail in
	  <Ptr to="section.api.interfaces">.

	<Entry><<parseOzFile>>
	<Synopsis>
	  <<{Compiler.parseOzFile ?+{V} ?+{O} ?+{P} ?+{Dictionary} ??{T}}>>
	<Entry><<parseOzVirtualString>>
	<Synopsis>
<<{Compiler.parseOzVirtualString ?+{V} ?+{O} ?+{P} ?+{Dictionary} ??{T}}>>
	<Item>
	  <P.silent><!--**-->

	<Entry><<assemble>>
	<Synopsis>
	  <<{Compiler.assemble ?+{Ts} ?+{Xs} ?+{SwitchR} ??{P}}>>
	<Item>
	  <P.silent><!--**-->
      </List>
  &engines;
  &interfaces;
  <Section id="section.api.abstractions">
    <Title/A Look into the Provided Abstractions/
    <P>
      <Code.Extern display to="EvalExpression.oz">
      <Code.Extern display to="VirtualStringToValue.oz">
</Chapter>
