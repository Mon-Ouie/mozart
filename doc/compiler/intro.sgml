<Chapter id="chapter.intro">
  <Title/Introduction/
  <P>
    The Mozart Compiler is, in principle, only a special kind of evaluator.
    In general, an evaluator implements the mapping:
    <Math.Choice display>
      <Math type=html>source_text &#215; environment -> value</Math>
      <Math type=latex>\mbox{source\_text} \times \mbox{environment}
      \rightarrow \mbox{value}</Math>
    </Math.Choice>
  <Para class=apropos><Title/Compiling Programs/
    Performing evaluation of Oz programs with a compiler has some
    advantages:
    <List>
      <Item>
        Programs with statically discoverable errors are rejected.  Apart
        from syntax errors and undeclared variables, this also includes
        discouraged uses of the language that are not&emdash;strictly
        speaking&emdash;necessarily errors.  For instance, applying a
        procedure with the wrong number of arguments does raise a
        catchable error, but may be reported as an error.
      <Item>
        Programs may be translated into a more efficient representation.
        In the case of the Mozart Compiler, this consists of bytecode for
        the Mozart VM.
    </List>
    For correct programs, both these steps are transparent to the user,
    but due to them the actual transformation has actually more parameters
    and output than illustrated above.
  <Para class=apropos><Title/The Manual's Structure/
    The remainder of this chapter will describe what the state of the Mozart
    Compiler consists of, and what additional parameters it takes.  <Ptr
    to="chapter.directives"> describes what programs the compiler accepts
    as input.  <Ptr to="chapter.ozbatch"> and <Ptr to="chapter.panel">
    explain how to use two applications of the compiler, namely the batch
    compiler, which is invoked from the command line, and the compiler panel,
    which is a graphical interface to the compiler's state.  Both of these
    are implemented using the compiler's Application Programmer's Interface,
    which is described in detail in <Ptr to="chapter.api">.
  <P>
    Note that there is another widely used application of the compiler,
    namely the <Def/Oz Programming Interface/.  See <Ptr to="mozart-opi">
    for a description.
  <Section class=unnumbered>
    <Title/The Compiler's State/
    <Para class=apropos><Title/Macro Definitions/
      The compiler stores a set of so-called <Def/macro names/, used to
      control conditional compilation via macro directives such as <<\ifdef>>
      (see <Ptr to="section.directives.macro">).
    <P>
      Initially, the set of macro names consists of entries describing the
      Oz version number, &eg;, when running Oz&nbsp;3.0.10, all of <<Oz_3>>,
      <<Oz_3_0>>, and <<Oz_3_0_10>> are macro names.
    <Para class=apropos><Title/Compiler Switches/
      The compiler's behaviour is influenced by a number of boolean switches.
      The current switch settings are given by a mapping from switch names
      to boolean values.  The compiler manages a stack of switch states, the
      top element of which is taken as the active state.  This allows to
      temporarily escape into a different mode of compiler operation.
    <P>
      The available switches and their effects on the compilation process
      are described in detail in <Ptr to="appendix.switches">.
    <Para class=apropos><Title/The Environment/
      An environment is a mapping from variable print names to arbitrary
      Oz values.
    <P>
      The Oz compiler does not take the environment as input for each
      evaluation as was illustrated above, but stores its active environment.
      This may be extended as a side-effects of the compilation, and it may
      be replaced by other environments at will.
    <Para class=apropos><Title/The Query Queue/
      Since the Oz compiler has internal state, it is not implemented
      as a function as described above, but as an active object that
      sequentializes all requests made to it via a <Def/query queue/.
</Chapter>
