<section id="r_expect">
<title/The class <<OZ_Expect>>/

<p>
The functionality provided by class <<OZ_Expect>> is intended to be
used for implementing header functions.

<p>

<!-- ********************************************************************** -->

<subsection id="expect.types">
<title/Types/

<p>

<List proglang=cc>

<Entry class="datatype"><<OZ_expect_t>>
<Index class=proglang><<OZ_expect_t>></Index>
<Synopsis> <<
struct OZ_expect_t {
  int size, accepted;
  OZ_expect_t(int s, int a) : size(s), accepted(a) {}
};
>>

<Item> Return type of member functions which check for constraints on
parameters (see <ptr to="expect.checkconstr">).

<Entry class="enumtype"><<OZ_FDPropState>>
<Index class=proglang><<OZ_FDPropState>></Index>
<Synopsis> <<
enum
OZ_FDPropState {fd_prop_singl = 0,
                fd_prop_bounds,
                fd_prop_any};

>>

<Item> The values of this enumerable type are used to determine what
kind of pruning of a finite domain causes a propagator to be resumed.


<Entry class="enumtype"><<OZ_PropagatorFlags>>
<Index class=proglang><<OOZ_PropagatorFlags>></Index>
<Synopsis> <<
enum OZ_PropagatorFlags {NULL_flag, OFS_flag};
>>

<Item> [fixme]
<p>

<Entry class="datatype"><<OZ_ExpectMeth>>
<Index class=proglang><<OZ_ExpectMeth>></Index>
<Synopsis> <<
typedef
OZ_expect_t (OZ_Expect::*OZ_ExpectMeth)(OZ_Term)
>>

<Item> Type of member functions which check for constraints on
parameters (see <ptr to="expect.checkconstr">).

</List>

<!-- ********************************************************************** -->

<subsection id="expect.condes">
<title/Constructor and Destructor/
<p>

<List proglang=cc>

<Entry class="default constructor"><<OZ_expect>>
<Index class=proglang><<OZ_expect>></Index>
<Synopsis> <<OZ_Expect(void);>>

<Item> Default constructor of the class <<OZ_Expect>>.


<Entry class="destructor"><<~OZ_expect>>
<Index class=proglang><<OZ_expect>><And><<~OZ_expect>></Index>
<Synopsis> <<~OZ_Expect();>>

<Item> Destructor of the class <<OZ_Expect>>.

</List>

<!-- ********************************************************************** -->

<subsection id="expect.checkconstr">
<title/Member Functions for Checking the Constraint Store/
<p>

A member function described in this section takes as first argument a
term, typically a parameter of a propagator. Extra arguments allow to
control the behaviour of the member function or to specify the way
subterms are to be checked. The returned value is of type
<<OZ_expect_t>> and denotes the result of the examination of the
constraint store.
<p>

<List proglang=cc>

<Entry class="member function"><<expectDomDescr>>
<Index class=proglang><<OZ_expect>><And><<expectDomDescr>></Index>
<Synopsis> <<
OZ_expect_t expectDomDescr(OZ_Term descr,
                           int level = 4);
>>

<Item> This member function expects <<descr>> to be a domain
description according to <<level>>.
<p>
<grammar.rule>?={level4}
  <grammar.alt/compl(?={level3})/
  <grammar.alt/?={level3}/

<grammar.rule>?={level3}
  <grammar.alt/?={level2+}/
  <grammar.alt/?={level2}/

<grammar.rule>?={level2}
  <grammar.alt/?={level1}#?={level1}/
  <grammar.alt/?={level1}/

<grammar.rule>?={level1}
  <grammar.alt/?={level2+}/
  <grammar.alt/integer out of <<{0, .. , OZ_getFDSup()} >>/

<p>
The non-terminal <em/leveln/ corresponds to <<level=n>>.
<p>

<Entry class="member function"><<expectFSetDescr>>
<Index class=proglang><<OZ_expect>><And><<expectFSetDescr>></Index>
<Synopsis> <<
OZ_expect_t expectFSetDescr(OZ_Term descr,
                           int level = 4);
>>

<Item> This member function expects <<descr>> to be a finite set
description according to <<level>> [fixme].
<p>
<grammar.rule>?={level4}
  <grammar.alt/compl(?={level3})/
  <grammar.alt/?={level3}/

<grammar.rule>?={level3}
  <grammar.alt/?={level2+}/
  <grammar.alt/?={level2}/

<grammar.rule>?={level2}
  <grammar.alt/?={level1}#?={level1}/
  <grammar.alt/?={level1}/

<grammar.rule>?={level1}
  <grammar.alt/?={level2+}/
  <grammar.alt/integer out of <<{0, .. , OZ_getFDSup()} >>/

<p>
The non-terminal <em/leveln/ corresponds to <<level=n>>.
<p>


<Entry class="member function"><<expectVar>>
<Index class=proglang><<OZ_expect>><And><<expectVar>></Index>
<Synopsis> <<OZ_expect_t expectVar(OZ_Term t);>>

<Item> Expects <<t>> to be a variable. A determined term <<t>> is
regarded as an inconsistency.


<Entry class="member function"><<expectRecordVar>>
<Index class=proglang><<OZ_expect>><And><<expectRecordVar>></Index>
<Synopsis> <<OZ_expect_t expectRecordVar(OZ_Term t);>>

<Item> Expects <<t>> to be a record.


<Entry class="member function"><<expectBoolVar>>
<Index class=proglang><<OZ_expect>><And><<expectBoolVar>></Index>
<Synopsis> <<OZ_expect_t expectRecordVar(OZ_Term t);>>

<Item> Expects <<t>> to be a boolean variable. [fixme?]


<Entry class="member function"><<expectIntVar>>
<Index class=proglang><<OZ_expect>><And><<expectIntVar>></Index>
<Synopsis> <<
OZ_expect_t
expectIntVar(OZ_Term t,
             OZ_FDPropState ps = fd_prop_any);
>>

<Item> Expects <<t>> to be a finite domain integer. The value of
<<ps>> controls on what events the propagator has to be resumed.  <!--
The type <<OZ_FDPropState>> is defined in <ptr to="r_fd.misc">.  -->
The values <<OZ_FDPropState>> have the following meaning.
<p>
<table>
<tr><th/value/ <th/explanation/
<tr><td/<<fd_prop_any>>/ <td/The propagator imposed on that variable is
     resumed if an arbitrary value is removed from the domain of the
     finite domain integer denoted by <<t>>./
<tr><td/<<fd_prop_bounds>>/ <td/The propagator imposed on that variable up
     if the bounds are narrowed of the domain of the finite domain
     integer denoted by <<t>>./
<tr><td/<<fd_prop_singl>>/ <td/The propagator imposed on that variable is
     resumed if the domain of the finite domain integer denoted by
     m4cpp{t} becomes a singleton./
</table>

<Entry class="member function"><<expectFSetVar>>
<Index class=proglang><<OZ_expect>><And><<expectFSetVar>></Index>
<Synopsis> <<
OZ_expect_t
expectFSetVar(OZ_Term t,
              OZ_FSetPropState ps = fs_prop_glb);
>>

<Item> Expects <<t>> to be a finite set variable. The value of <<ps>>
controls on what events the propagator has to be resumed.  The values
<<OZ_FSetPropState>> have the following meaning.  [fixme]
<p>
<table>
<tr><th/value/ <th/explanation/
<tr><td/<<fs_prop_any>>/ <td/The propagator imposed on that variable is
     resumed if an arbitrary value is included or excluded in the
     corresponding set<<t>>./
<tr><td/<<fs_prop_bounds>>/ <td/???./
<tr><td/<<fs_prop_glb>>/ <td/The propagator is resumed if the greatest
     lower bound of the set changes../
<tr><td/<<fs_prop_lub>>/ <td/The propagator is resumed if the least
     upper bound of the set changes./
<tr><td/<<fd_prop_val>>/ <td/???/
</table>

<!--

<para class=apropos><title/<<expectIntVarAny>>/
<em/member function/<p>
<<
OZ_expect_t expectIntVarAny(OZ_Term t);
>>
<p>
Expects <<t>> to be a finite domain integer. The propagator imposed
on that variable is resumed if an arbitrary value is removed from the
domain of the finite domain integer denoted by <<t>>.
<p>
-->

<Entry class="member function"><<expectInt>>
<Index class=proglang><<OZ_expect>><And><<expectInt>></Index>
<Synopsis> <<OZ_expect_t expectInt(OZ_Term t);>>

<Item> Expects <<t>> to be a small integer. See the systems manual
<ptr to="system"> for details.


<Entry class="member function"><<expectFloat>>
<Index class=proglang><<OZ_expect>><And><<expectFloat>></Index>
<Synopsis> <<OZ_expect_t expectFloat(OZ_Term t);>>

<Item> Expects <<t>> to be a float.


<Entry class="member function"><<expectFSetValue>>
<Index class=proglang><<OZ_expect>><And><<expectFSetValue>></Index>
<Synopsis> <<OZ_expect_t expectFSetValue(OZ_Term t);>>

<Item> Expects <<t>> to be a finite set value.


<Entry class="member function"><<expectLiteral>>
<Index class=proglang><<OZ_expect>><And><<expectLiteral>></Index>
<Synopsis> <<OZ_expect_t expectLiteral(OZ_Term t);>>

<Item> Expects <<t>> to be a literal.

<Entry class="member function"><<expectLiteral>>
<Index class=proglang><<OZ_expect>><And><<expectLiteral>></Index>
<Synopsis> <<OZ_expect_t expectLiteral(OZ_Term t, OZ_Term *);>>

<Item> [fixme]


<Entry class="member function"><<expectVector>>
<Index class=proglang><<OZ_expect>><And><<expectVector>></Index>
<Synopsis> <<
OZ_expect_t expectVector(OZ_Term t,
                         OZ_ExpectMeth expect_f);
>>

<Item> Expects <<t>> to be a vector of terms which are all
sufficiently constrained with respect to <<expect_f>>. A vector is
either a tuple, a closed record, or a list.


<Entry class="member function"><<expectProperRecord>>
<Index class=proglang><<OZ_expect>><And><<expectProperRecord>></Index>
<Synopsis> <<
OZ_expect_t
expectProperRecord(OZ_Term t,
                   OZ_ExpectMeth expect_f);
>>

<Item> Expects <<t>> to be a proper record where all subtrees are
sufficiently constrained with respect to <<expect_f>>. A proper record
expects its subtrees to be indexed by literals.

<Entry class="member function"><<expectProperRecord>>
<Index class=proglang><<OZ_expect>><And><<expectProperRecord>></Index>
<Synopsis> <<
OZ_expect_t
expectProperRecord(OZ_Term t,
                   OZ_Term *);
>>

<Item>
[fixme]


<Entry class="member function"><<expectProperTuple>>
<Index class=proglang><<OZ_expect>><And><<expectProperTuple>></Index>
<Synopsis> <<
OZ_expect_t
expectProperTuple(OZ_Term t,
                  OZ_ExpectMeth expect_f);
>>

<Item> Expects <<t>> to be a proper tuple where all subtrees are
sufficiently constrained with respect to <<expect_f>>. A proper tuple
expects its subtrees to be indexed by integers.


<Entry class="member function"><<expectList>>
<Index class=proglang><<OZ_expect>><And><<expectList>></Index>
<Synopsis> <<
OZ_expect_t expectList(OZ_Term t,
                       OZ_ExpectMeth expect_f);
>>

<Item> Expects <<t>> to be a list where all elements are sufficiently
constrained with respect to <<expect_f>>. A list is either the atom
<<nil>> or a 2-tuple with label <<'|'>> where the second subtree is a
list again.


<Entry class="member function"><<expectStream>>
<Index class=proglang><<OZ_expect>><And><<expectStream>></Index>
<Synopsis> <<OZ_expect_t expectStream(OZ_Term st);>>

<Item>
[fixme]
<p>

<Entry class="member function"><<expectGenCtVar>>
<Index class=proglang><<OZ_expect>><And><<expectGenCtVar>></Index>
<Synopsis> <<
OZ_expect_t expectGenCtVar(OZ_Term, OZ_CtDefinition *, OZ_CtWakeUp);
>>

<Item> [fixme]

</List>

<!-- ********************************************************************** -->

<subsection id="expect.control">
<title/Member Functions for Control Purposes/
<p>

<List proglang=cc>

<Entry class="member function"><<collectVarsOn>>
<Index class=proglang><<OZ_expect>><And><<collectVarsOn>></Index>
<Synopsis> <<void collectVarsOn(void);>>

<Item> This member function turns collecting variables <em/on/. That
means that pruning of parameters checked in this mode may cause the
propagator to be resumed.


<Entry class="member function"><<collectVarsOff>>
<Index class=proglang><<OZ_expect>><And><<collectVarsOff>></Index>
<Synopsis> <<void collectVarsOff(void);>>

<Item> This member function turns collecting variables <em/off/. That
means that pruning of parameters checked in this mode <em/cannot/
cause the propagator to be resumed.


<Entry class="member function"><<impose>>
<Index class=proglang><<OZ_expect>><And><<impose>></Index>
<Synopsis> <<
OZ_Return impose(OZ_Propagator *p,
                 int prio = OZ_getMediumPrio(),
                 OZ_PropagatorFlags flags = NULL_flag);
>>

<Item> [fixme] The propagator <<p>> is imposed with the thread
priority <<prio>>. An admissible value for <<prio>> can be obtained
either by the function <<OZ_getLowPrio()>>, <<OZ_getMediumPrio()>>, or
<<OZ_getHighPrio()>>. The return value is result of the initial
invocation of <<OZ_Propagator::propagate(void)>>.


<Entry class="member function"><<suspend>>
<Index class=proglang><<OZ_expect>><And><<suspend>></Index>
<Synopsis> <<OZ_Return suspend(OZ_Thread th);>>

<Item> This member function is to be called if the header function has
to be suspended. The thread <<th>> can be created with
<<OZ_makeSuspendedThread()>> which is defined by the &sci (see <ptr
to="system"> for details).


<Entry class="member function"><<fail>>
<Index class=proglang><<OZ_expect>><And><<fail>></Index>
<Synopsis> <<OZ_Return fail(void);>>

<Item> This member function is to be called if an inconsistency has
been detected.


<Entry class="member function"><<isSuspending>>
<Index class=proglang><<OZ_expect>><And><<isSuspending>></Index>
<Synopsis> <<OZ_Boolean isSuspending(OZ_expect_t r);>>

<Item> Returns <<OZ_TRUE>> if <<r>> indicates that constraints
expected on a parameter are not present in the current
store. Otherwise it returns <<OZ_FALSE>>.
<p>

<Entry class="member function"><<isFailing>>
<Index class=proglang><<OZ_expect>><And><<isFailing>></Index>
<Synopsis> <<OZ_Boolean isFailing(OZ_expect_t r);>>

<Item> Returns <<OZ_TRUE>> if <<r>> indicates an
inconsistency. Otherwise it returns <<OZ_FALSE>>.


<Entry class="member function"><<isExceptional>>
<Index class=proglang><<OZ_expect>><And><<isExceptional>></Index>
<Synopsis> <<OZ_Boolean isFailing(OZ_expect_t r);>>

<Item> [fixme]

</List>

<!-- ********************************************************************** -->

<subsection id="expect.macros">
<title/Macros/
<p>

<List proglang=cc>

<Entry class="macro"><<OZ_EXPECTED_TYPE>>
<Index class=proglang><<OZ_EXPECTED_TYPE>></Index>
<Synopsis> <<OZ_EXPECTED_TYPE(S)>>

<Item> This macro declares a &ccpp; string used by the macros
<<OZ_EXPECT>> and <<OZ_EXPECT_SUPEND>> in case an inconsistency is
detected. For details see <Ptr.Extern to="ozdoc:cpitut"
key="u_nesting.impose">.


<Entry class="macro"><<OZ_EM>>
<Index class=proglang><<OZ_EM>></Index>
<Synopsis> The macros <<OZ_EM_>> are provided to create
standardized error messages.

<Item>
<table>
<tr><th/expected constraint/ <th/macro to be used/
<tr> <td/literal/ <td/<<OZ_EM_LIT>>/
<tr> <td/small integer/ <td/<<OZ_EM_INT>>/
<tr> <td/finite domain integer/ <td/<<OZ_EM_FD>>/
<tr> <td/boolean finite domain integer in <math/\{0,1\}// <td/<<OZ_EM_BOOL>>/
<tr> <td/description of a finite domain integer/ <td/<<OZ_EM_FDDESCR>>/
<tr> <td/finite set of integers/ <td/<<OZ_EM_FSETVAL>>/
<tr> <td/finite set of integers constraint/ <td/<<OZ_EM_FSET>>/
<tr> <td/description of a finite set of integers/ <td/<<OZ_EM_FSETDESCR>>/
<tr> <td/vector of/ <td/<<OZ_EM_VECT>>/
<tr> <td/record of/ <td/<<OZ_EM_RECORD>>/
<tr> <td/truth name/ <td/<<OZ_EM_TNAME>>/
<tr> <td/stream/ <td/<<OZ_EM_STREAM>>/
</table>

<Entry class="macro"><<OZ_EXPECT>>
<Index class=proglang><<OZ_EXPECT>></Index>
<Synopsis> <<OZ_EXPECT(O, P, F)>>

<Item> This macros checks if a term occurring at argument position
<<P>> of a &sci function is currently expectedly constrained with
respect to the function <<F>>. The first parameter <<O>> must be an
instance of the class <<OZ_Expect>> &resp a class derived from
it. Only if the expected constraints are available in the store the
code following this macro is executed.
<p>

<Entry class="macro"><<OZ_EXPECT_SUSPEND>>
<Index class=proglang><<OZ_EXPECT_SUSPEND>></Index>
<Synopsis> <<OZ_EXPECT_SUSPEND(O, P, F, SC)>>

<Item> This macros has the same semantics as the previous one except
that in case that expected constraints are currently not present in
the store the counter <<SC>> is incremented and the following code is
executed.

</List>
