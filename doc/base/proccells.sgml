<!--
  - Authors:
  -   Denys Duchier <duchier@ps.uni-sb.de>
  -   Leif Kornstaedt <kornstae@ps.uni-sb.de>
  -   Christian Schulte <schulte@ps.uni-sb.de>
  -
  - Contributors:
  -   Daniel Simon <dansim@ps.uni-sb.de> (SGML Translation)
  -
  - Copyright:
  -   Denys Duchier, Leif Kornstaedt, and Christian Schulte, 1998
  -
  - Last change:
  -   $Date$ by $Author$
  -   $Revision$
  -
  - This file is part of Mozart, an implementation of Oz 3:
  -   http://www.mozart-oz.org
  -
  - See the file "LICENSE" or
  -   http://www.mozart-oz.org/LICENSE.html
  - for information on usage and redistribution
  - of this file, and for a DISCLAIMER OF ALL
  - WARRANTIES.
  -
  -->

<Chapter id="chapter.proccells">
  <Title/Procedures, Cells, and Spaces/
  <Section id="section.proccells.procedures">
    <Title/Procedures/
    <P>
      The module <Span class=index/<<Procedure>>/ specifies operations on
      procedures.
      <List>
        <Entry><Span class=index/<<IsProcedure>>/
          <Index class=tails/<<Procedure>><And><<is>>/
        <Synopsis>
          <<{Procedure.is ?+{X} ??{B}}>>
        <Item>
          tests whether ?_{X} is a procedure.

        <Entry><Span class=index/<<ProcedureArity>>/
          <Index class=tails/<<Procedure>><And><<arity>>/
        <Synopsis>
          <<{Procedure.arity ?+{P} ??{I}}>>
        <Item>
          returns the procedure arity of&nbsp;?_{P}, &ie;, the number of
          arguments which ?_{P} takes.

        <Entry><<apply>>
          <Index class=tails/<<Procedure>><And><<apply>>/
        <Synopsis>
          <<{Procedure.apply ?+{P} ?+{Xs}}>>
        <Item>
          applies the procedure&nbsp;?_{P} to the arguments given
          by the elements of the list&nbsp;?_{Xs}, provided that
          <<<{Procedure.arity ?_{P}} == {Length ?_{Xs}}>>>
      </List>

  <Section id="section.proccells.cells">
    <Title/Cells/
    <P>
      The module <Span class=index/<<Cell>>/ contains procedures operating
      on cells.
      <List>
        <Entry><Span class=index/<<IsCell>>/
          <Index class=tails/<<Cell>><And><<is>>/
        <Synopsis>
          <<{Cell.is ?+{X} ??{B}}>>
        <Item>
          tests whether ?_{X} is a cell.

        <Entry><Span class=index/<<NewCell>>/
          <Index class=tails/<<Cell>><And><<new>>/
        <Synopsis>
          <<{Cell.new ?_{X} ??{Cell}}>>
        <Item>
          returns a new cell with initial content&nbsp;?_{X}.

        <Entry><Span class=index/<<Exchange>>/
          <Index/<<Cell>><And><<exchange>>/
        <Synopsis>
          <<{Cell.exchange ?+{Cell} ?_{X} ?_{Y}}>>
        <Item>
          returns the current content of ?_{Cell} in&nbsp;?_{X}, and sets the
          content of ?_{Cell} to&nbsp;?_{Y}.

        <Entry><Span class=index/<<Access>>/
          <Index/<<Cell>><And><<access>>/
        <Synopsis>
          <<{Cell.access ?+{Cell} ?_{X}}>>
        <Item>
          returns the current content of ?_{Cell} in&nbsp;?_{X}.

        <Entry><Span class=index/<<Assign>>/
        <Synopsis>
          <<{Cell.assign ?+{Cell} ?_{X}}>>
        <Item>
          sets the content of ?_{Cell} to&nbsp;?_{X}.
      </List>


      <section  id="section.proccells.spaces">
        <title/Spaces/

<p>
First-class computation spaces can be used to program inference
engines for problem solving.

<list>
<entry><Span class=index/<<IsSpace>>/
<index class=tails/<<Space>><And><<is>>/
<synopsis>
<<{IsSpace ?+{X} ??{B}}>>
<item>
tests whether ?_{X} is a space.

<entry><<new>>
<index class=tails/<<Space>><and><<new>>/
<synopsis>
<<{Space.new ?+{P} ??{Space}}>>
<item>
returns a newly created space, in which a thread containing an
application of the unary procedure&nbsp;?_{P} to the root variable of
?_{Space} is created.

<entry><<ask>>
<index class=tails/<<Space>><and><<ask>>/
<synopsis>
<<{Space.ask ?+{Space} ??{T}}>>
<item>
waits until ?_{Space} becomes stable or merged and then returns the
status of ?_{Space}.
<p>
If ?_{Space} is merged, the atom <<merged>> is returned.
<p>
If ?_{Space} is stable and:
<list>
<entry>failed
<item>the atom <<failed>> is returned.
<entry>succeeded
<item>and there are no threads in ?_{Space} synchronizing on
choices,  the atom <<succeeded>> is returned.
<entry>succeeded
<item>and there is at least one thread in ?_{Space} which
synchronizes on a choice the tuple <<alternatives(?{I})>> is returned, where ?{I} gives the number of alternatives of the selected choice.
</list>

<entry><<askVerbose>>
<index class=tails/<<Space>><and><<askVerbose>>/
<synopsis>
<<{Space.askVerbose ?+{Space} ??{T}}>>
<item>
returns the status of ?_{Space} in verbose form. Reduces when
?_{Space} becomes merged or stable.
<p>
If ?_{Space} becomes merged, the atom <<merged>> is returned.
<p>
If ?_{Space} becomes blocked but not stable, ?_{T} is bound to the tuple
<<blocked(?{T1})>>. ?{T1} is bound to the status of
?_{Space} when ?_{Space} becomes unblocked again.
<p>
If ?_{Space} is stable and:
<list>
<entry>failed
<item>the atom <<failed>> is returned.
<entry>succeeded
<item>and there are no threads in ?_{Space} synchronizing on
choices,  the tuple <<succeeded(?{A})>> is returned.
The atom ?{A} is either <<suspended>>, when ?_{Space} still contains threads, or <<entailed>> otherwise.
<entry>succeeded
<item>and there is at least one thread in ?_{Space} which
synchronizes on a choice the tuple <<alternatives(?{I})>> is returned,
where ?_{I} gives the number of alternatives of the selected choice.
</list>
<p>
Note that execution of <<Space.askVerbose>> blocks until the space
becomes stable, even though it possibly constrains its output before having
completely reduced (in the case of blocked but not stable spaces). So
a common pattern of usage is the following:
<<<
case
   thread {Space.askVerbose ?{S}} end
of blocked(R) then &ellipsis;
[] &ellipsis;
end
>>>

<entry><<merge>>
<index class=tails/<<Space>><and><<merge>>/
<synopsis>
<<{Space.merge ?+{Space} ?_{X}}>>
<item>
merges ?_{Space} with the current space and constrains ?_{X} to the
root variable of ?_{Space}.

<p>
Raises a runtime error if ?_{Space} is already merged, or if the
current space is subordinated to ?_{Space}.

<entry><<clone>>
<index class=tails/<<Space>><and><<clone>>/
<synopsis>
<<{Space.clone ?+{Space1} ??{Space2}}>>
<item>
blocks until ?_{Space1} becomes stable and returns a new space which is a copy of ?_{Space1}.

<p>
Raises a runtime error if ?_{Space1} has been merged already.

<entry><<inject>>
<index class=tails/<<Space>><and><<inject>>/
<synopsis>
<<{Space.inject ?+{Space} ?+{P}}>>
<item>
creates a thread in the space ?_{Space} which contains an application
of the unary procedure&nbsp;?_{P} to the root variable of ?_{Space}.

<p>
Raises a runtime error if ?_{Space} has been merged already or if the
current space is subordinated to ?_{Space}.

<entry><<commit>>
<index class=tails/<<Space>><and><<commit>>/
<synopsis>
<<{Space.commit ?+{Space} ?+{IT}}>>
<item>
blocks until ?_{Space} becomes stable and then commits to alternatives
of the selected choice of ?_{Space}.

<p>
If ?_{IT} is a pair of integers <<?{l}#?{r}>> then all but the
?{l}, ?{l} + 1, &ellipsis;, ?{r} alternatives of the selected choice
of ?_{Space} are discarded. If a single
alternative remains, the topmost choice is replaced by this alternative.
If no alternative remains, the space is failed.

<p>
An integer value for ?_{IT} is an abbrevation for the pair
<<?_{IT}#?_{IT}>>.

<p>
Raises a runtime error, if ?_{Space} has been merged already, if there
exists no selected choice in ?_{Space}, or if the
current space is subordinated to ?_{Space}.
</list>



</Chapter>
