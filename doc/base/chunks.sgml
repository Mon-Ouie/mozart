<!--
  Translated to SGML by:
     Daniel Simon, dansim@ps.uni-sb.de
     Leif Kornstaedt, kornstae@ps.uni-sb.de
-->

<Chapter id="chapter.chunks">
  <Title/Chunks/
  <Section>
    <Title/Chunks in General/
    <P>
      The module <Span class=index/<<Chunk>>/ contains procedures operating
      on chunks.
      <List>
	<Entry><Span class=index/<<.>>/
	  <Index/<<Value>><And><<'.'>>/
	<Synopsis>
	  <<{Value.'.' ?+{RC} ?+{LI} ?_{X}}>>
	<Item>
	  returns the field&nbsp;?_{X} of&nbsp;?_{RC} at feature&nbsp;?_{LI}.

	<Entry><Span class=index/<<HasFeature>>/
	  <Index/<<Value>><And><<hasFeature>>/
	<Synopsis>
	  <<{Value.hasFeature ?+{RC} ?+{LI} ??{B}}>>
	<Item>
	  tests whether ?_{RC} has feature&nbsp;?_{LI}.

	<Entry><Span class=index/<<CondSelect>>/
	  <Index/<<Value>><And><<condSelect>>/
	<Synopsis>
	  <<{Value.condSelect ?+{RC} ?+{LI} ?_{X} ?_{Y}}>>
	<Item>
	  returns the field&nbsp;?_{Y} of&nbsp;?_{RC} at&nbsp;?_{LI}, if
	  ?_{RC} has feature&nbsp;?_{LI}.  Otherwise, returns&nbsp;?_{X}.

	<Entry><Span class=index/<<IsChunk>>/
	  <Index class=tails/<<Chunk>><And><<is>>/
	<Synopsis>
	  <<{Chunk.is ?+{X} ??{B}}>>
	<Item>
	  tests whether ?_{X} is a chunk.

	<Entry><Span class=index/<<NewChunk>>/
	  <Index class=tails/<<Chunk>><And><<new>>/
	<Synopsis>
	  <<{Chunk.new ?+{R} ??{C}}>>
	<Item>
	  returns a new chunk with the same features and fields as&nbsp;?_{R}.

	<Entry><Span class=index/<<ChunkSelectFeature>>/
	  <Index class=tails/<<Chunk>><And><<selectFeature>>/
	<Synopsis>
	  <<{Chunk.selectFeature ?+{C} ?+{F} ?_{X}}>>
	<Item>
	  returns the field&nbsp;?_{X} of&nbsp;?_{C} at feature&nbsp;?_{F}.

	<Entry><Span class=index/<<ChunkHasFeature>>/
	  <Index class=tails/<<Chunk>><And><<hasFeature>>/
	<Synopsis>
	  <<{Chunk.hasFeature ?+{C} ?+{F} ??{B}}>>
	<Item>
	  tests whether ?_{C} has feature&nbsp;?_{F}.
      </List>

  <Section>
    <Title/Arrays/
    <P>
      The module <Span class=index/<<Array>>/ contains procedures operating
      on arrays.  Whenever an array access is indexed with an illegal key, an
      error exception is raised.
      <List>
	<Entry><Span class=index/<<IsArray>>/
	  <Index class=tails/<<Array>><And><<is>>/
	<Synopsis>
	  <<{Array.is ?+{X} ??{B}}>>
	<Item>
	  tests whether ?_{X} is an array.

	<Entry><Span class=index/<<NewArray>>/
	  <Index class=tails/<<Array>><And><<new>>/
	<Synopsis>
	  <<{Array.new ?+{LowI} ?+{HighI} ?_{InitX} ??{Array}}>>
	<Item>
	  returns a new array with key range from ?_{LowI} to ?_{HighI}
	  including both.  All items are initialized to ?_{InitX}.

	<Entry><Span class=index/<<Put>>/
	  <Index/<<Array>><And><<put>>/
	<Synopsis>
	  <<{Array.put ?+{Array} ?+{I} ?_{X}}>>
	<Item>
	  sets the item of ?_{Array} under key&nbsp;?_{I} to&nbsp;?_{X}.

	<Entry><Span class=index/<<Get>>/
	  <Index/<<Array>><And><<get>>/
	<Synopsis>
	  <<{Array.get ?+{Array} ?+{I} ?_{X}}>>
	<Item>
	  returns the item of ?_{Array} under key&nbsp;?_{I}.

	<Entry><<low>>
	  <Index class=tails/<<Array>><And><<low>>/
	<Synopsis>
	  <<{Array.low ?+{Array} ??{LowI}}>>
	<Item>
	  returns the lower bound of the key range of ?_{Array}.

	<Entry><<high>>
	  <Index class=tails/<<Array>><And><<high>>/
	<Synopsis>
	  <<{Array.high ?+{Array} ??{HighI}}>>
	<Item>
	  returns the upper bound of the key range of ?_{Array}.

	<Entry><<clone>>
	  <Index class=tails/<<Array>><And><<clone>>/
	<Synopsis>
	  <<{Array.clone ?+{A1} ??{A2}}>>
	<Item>
	  returns a new array with the same bounds and contents as&nbsp;?_{A1}.

	<Entry><<toRecord>>
	  <Index class=tails/<<Array>><And><<toRecord>>/
	<Synopsis>
	  <<{Array.toRecord ?+{L} ?+{A} ??{R}}>>
	<Item>
	  returns a record with label&nbsp;L that contains as features the
	  integers between <<{Array.low ?_{A}}>> and <<{Array.high ?_{A}}>>
	  and with the corresponding fields.
      </List>

  <Section>
    <Title/Dictionaries/
    <P>
      The module <Span class=index/<<Dictionary>>/ contains procedures
      operating on dictionaries.  If a dictionary contains an item under
      some key&nbsp;?_{LI}, we say ?_{LI} is a <Def/valid key/.  Whenever
      a dictionary access is indexed with an invalid key, a type error is
      raised.
      <List>
	<Entry><Span class=index/<<IsDictionary>>/
	  <Index class=tails/<<Dictionary>><And><<is>>/
	<Synopsis>
	  <<{Dictionary.is ?+{X} ??{B}}>>
	<Item>
	  tests whether ?_{X} is a dictionary.

	<Entry><Span class=index/<<NewDictionary>>/
	  <Index class=tails/<<Dictionary>><And><<new>>/
	<Synopsis>
	  <<{Dictionary.new ??{Dictionary}}>>
	<Item>
	  returns a new empty dictionary.

	<Entry><<put>>
	  <Index class=tails/<<Dictionary>><And><<put>>/
	<Synopsis>
	  <<{Dictionary.put ?+{Dictionary} ?+{LI} ?_{X}}>>
	<Item>
	  sets the item in ?_{Dictionary} under key&nbsp;?_{LI} to&nbsp;?_{X}.

	<Entry><<get>>
	  <Index class=tails/<<Dictionary>><And><<get>>/
	<Synopsis>
	  <<{Dictionary.get ?+{Dictionary} ?+{LI} ?_{X}}>>
	<Item>
	  returns the item&nbsp;?_{X} of ?_{Dictionary} under key&nbsp;?_{LI}.

	<Entry><<condGet>>
	  <Index class=tails/<<Dictionary>><And><<condGet>>/
	<Synopsis>
	  <<{Dictionary.condGet ?+{Dictionary} ?+{LI} ?_{X} ?_{Y}}>>
	<Item>
	  returns the item&nbsp;?_{Y} of ?_{Dictionary} under key&nbsp;?_{LI},
	  if ?_{LI} is a valid key of ?_{Dictionary}.  Otherwise,
	  returns&nbsp;?_{X}.

	<Entry><<keys>>
	  <Index class=tails/<<Dictionary>><And><<keys>>/
	<Synopsis>
	  <<{Dictionary.keys ?+{Dictionary} ??{LIs}}>>
	<Item>
	  returns a list of all currently valid keys of ?_{Dictionary}.

	<Entry><<entries>>
	  <Index class=tails/<<Dictionary>><And><<entries>>/
	<Synopsis>
	  <<{Dictionary.entries ?+{Dictionary} ??{Ts}}>>
	<Item>
	  returns the list of current entries of ?_{Dictionary}.  An entry is a
	  pair <<?_{LI}#?_{X}>>, where ?_{LI} is a valid key of ?_{Dictionary}
	  and ?_{X} the corresponding item.

	<Entry><<items>>
	  <Index class=tails/<<Dictionary>><And><<items>>/
	<Synopsis>
	  <<{Dictionary.items ?+{Dictionary} ??{Xs}}>>
	<Item>
	  returns the list of all items currently in ?_{Dictionary}.

	<Entry><<remove>>
	  <Index class=tails/<<Dictionary>><And><<remove>>/
	<Synopsis>
	  <<{Dictionary.remove ?+{Dictionary} ?+{LI}}>>
	<Item>
	  removes the item under key&nbsp;?_{LI} from ?_{Dictionary} if
	  ?_{LI} is a valid key.  Otherwise, does nothing.

	<Entry><<removeAll>>
	  <Index class=tails/<<Dictionary>><And><<removeAll>>/
	<Synopsis>
	  <<{Dictionary.removeAll ?+{Dictionary}}>>
	<Item>
	  removes all entries currently in ?_{Dictionary}.

	<Entry><<member>>
	  <Index class=tails/<<Dictionary>><And><<member>>/
	<Synopsis>
	  <<{Dictionary.member ?+{Dictionary} ?+{LI} ??{B}}>>
	<Item>
	  tests whether ?_{LI} is a valid key of ?_{Dictionary}.

	<Entry><<clone>>
	  <Index class=tails/<<Dictionary>><And><<clone>>/
	<Synopsis>
	  <<{Dictionary.clone ?+{Dictionary1} ??{Dictionary2}}>>
	<Item>
	  returns a new dictionary ?_{Dictionary2} containing the currently
	  valid keys and corresponding items of ?_{Dictionary1}.

	<Entry><<toRecord>>
	  <Index class=tails/<<Dictionary>><And><<toRecord>>/
	<Synopsis>
	  <<{Dictionary.toRecord ?+{L} ?+{Dictionary} ??{R}}>>
	<Item>
	  returns a record&nbsp;?_{R} with label&nbsp;?_{L} whose features
	  and their fields correspond to the keys and their entries of
	  ?_{Dictionary}.
      </List>

  <Section>
    <Title/Bit Arrays/
    <P>
      The module <Span class=index/<<BitArray>>/ contains procedures operating
      on arrays of bits (&ie;, units of information each being either <Def/set/
      or <Def/reset/).

      <!--** BitArray operations -->

  <Section>
    <Title/Ports/
    <P>
      The module <Span class=index/<<Port>>/ contains procedures operating on
      ports.
      <List>
	<Entry><Span class=index/<<IsPort>>/
	  <Index class=tails/<<Port>><And><<is>>/
	<Synopsis>
	  <<{Port.is ?+{X} ??{B}}>>
	<Item>
	  tests whether ?_{X} is a port.

	<Entry><Span class=index/<<NewPort>>/
	  <Index class=tails/<<Port>><And><<new>>/
	<Synopsis>
	  <<{Port.new ?_{Xs} ??{Port}}>>
	<Item>
	  returns a new port pointing to the stream&nbsp;?_{Xs}.

	<Entry><Span class=index/<<Send>>/
	  <Index/<<Port>><And><<send>>/
	<Synopsis>
	  <<{Port.send ?+{Port} ?_{X}}>>
	<Item>
	  sends ?_{X} to the port ?_{Port}:  The stream pointed to by
	  ?_{Port} is unified with <<?_{X}|_>> (in a newly created thread),
	  and the pointer advances to the stream's new tail.
      </List>

  <Section>
    <Title/Locks/
    <P>
      The module <Span class=index/<<Lock>>/ contains procedures for locks.
      <List>
	<Entry><Span class=index/<<IsLock>>/
	  <Index class=tails/<<Lock>><And><<is>>/
	<Synopsis>
	  <<{Lock.is ?+{X} ??{B}}>>
	<Item>
	  tests whether ?_{X} is a lock.

	<Entry><Span class=index/<<NewLock>>/
	  <Index class=tails/<<Lock>><And><<new>>/
	<Synopsis>
	  <<{Lock.new ??{LockC}}>>
	<Item>
	  creates and returns a new lock.
      </List>

  <Section>
    <Title/Classes/
    <P>
      The module <Span class=index/<<Class>>/ contains procedures operating
      on classes.
      <List>
	<Entry><Span class=index/<<IsClass>>/
	  <Index class=tails/<<Class>><And><<is>>/
	<Synopsis>
	  <<{Class.is ?+{X} ??{B}}>>
	<Item>
	  tests whether ?_{X} is a class.

	<Entry><Span class=index/<<IsInstanceOf>>/
	  <Index/<<Class>><And><<isInstanceOf>>/
	<Synopsis>
	  <<{Class.isInstanceOf ?+{O} ?+{K} ??{B}}>>
	<Item>
	  The object&nbsp;?_{O} is an instance of the class&nbsp;?_{K},
	  &ie;, ?_{K}&nbsp;is above the class of&nbsp;?_{O} in the inheritance
	  hierarchy.

	<Entry><<get>>
	  <Index class=tails/<<Class>><And><<get>>/
	<Synopsis>
	  <<{Class.get ?+{O} ??{K}}>>
	<Item>
	  binds ?_{K} to the class of&nbsp;?_{O}.

	<Entry><<methodNames>>
	  <Index class=tails/<<Class>><And><<methodNames>>/
	<Synopsis>
	  <<{Class.methodNames ?+{K} ??{Ls}}>>
	<Item>
	  returns the alphabetically sorted list of public (atomic) method
	  names that the instances of the class&nbsp;?_{K} can serve.
	  <!--** this is not true currently, names are also returned -->

	<!--** attrNames, featNames, propNames, extendFeatures, hasProperty -->

	<Entry><<parents>>
	  <Index class=tails/<<Class>><And><<parents>>/
	<Synopsis>
	  <<{Class.parents ?+{K} ??{Ks}}>>
	<Item>
	  binds ?_{Ks} to the list of direct parents of&nbsp;?_{K} in the
	  order of increasing priority.

	<Entry><<getFeature>>
	  <Index class=tails/<<Class>><And><<getFeature>>/
	<Synopsis>
	  <<{Class.getFeature ?+{K} ?+{LI} ??{X}}>>
	<Item>
	  returns the class feature&nbsp;?_{X} of&nbsp;?_{K} at&nbsp;?_{LI}.

	<Entry><<hasFeature>>
	  <Index class=tails/<<Class>><And><<hasFeature>>/
	<Synopsis>
	  <<{Class.hasFeature ?+{K} ?+{LI} ??{B}}>>
	<Item>
	  tests whether ?_{K} has class feature at&nbsp;?_{LI}.
      </List>

  <Section>
    <Title/Objects/
    <P>
      The module <Span class=index/<<Object>>/ contains procedures operating
      on objects.
    <P>
      The system procedures that define the behaviour of &Oz; objects and
      classes are also given in this section.
      <List>
	<Entry><Span class=index/<<IsObject>>/
	  <Index class=tails/<<Object>><And><<is>>/
	<Synopsis>
	  <<{Object.is ?+{X} ??{B}}>>
	<Item>
	  tests whether ?_{X} is an object.

	<Entry><Span class=index/<<New>>/
	  <Index class=tails/<<Object>><And><<new>>/
	<Synopsis>
	  <<{Object.new ?+{K} ?+{InitMessageR} ??{O}}>>
	<Item>
	  Creates a new object from class&nbsp;?_{K} with initial message
	  ?_{InitMessageR}.

	<!--** ',', '@', '<-', exchange, send, 'class', meta -->
      </List>
    <SubSection class=unnumbered>
      <Title/The <<BaseObject>> Class/
      <P>
	<Index class=tails/<<Object>><And><<base>>/
	The class <Span class=index/<<BaseObject>>/ defines the following
	method.
	<List>
	  <Entry><<noop>>
	    <Index/<<Object>><And><<base>><And><<noop>>/
	  <Synopsis>
	    <<noop()>>
	  <Item>
	    does nothing.  It is defined as <<meth noop() skip end>>.
	</List>
    <SubSection class=unnumbered>
      <Title/Classes for Master&slash;Slave Behaviour/
      <P>
	<Index class=tails/<<Object>><And><<master>>/
	An instance ?_{MasterO} of class <<Object.master>> becomes
	a <Def/master/ of an <<Object.slave>> object when the latter
	receives the message <<becomeSlave(?_{MasterO})>>.
      <Para class=apropos><Title/Methods for Masters/
	<List>
	  <Entry><<init>>
	    <Index/<<Object>><And><<master>><And><<init>>/
	  <Synopsis>
	    <<init()>>
	  <Item>
	    initialization; mandatory for internal reasons.

	  <Entry><<getSlaves>>
	    <Index/<<Object>><And><<master>><And><<getSlaves>>/
	  <Synopsis>
	    <<getSlaves(??{SlaveOs})>>
	  <Item>
	    binds ?_{SlavesOs} to the list of current slaves.
	</List>
      <P>
	<Index class=tails/<<Object>><And><<slave>>/
	An instance of <<Object.slave>> becomes a <Def/slave/ of an
	<<Object.master>> object ?_{MasterO} when it receives the message
	<<becomeSlave(?_{MasterO})>>.
      <Para class=apropos><Title/Methods for Slaves/
	<List>
	  <Entry><<becomeSlave>>
	    <Index/<<Object>><And><<slave>><And><<becomeSlave>>/
	  <Synopsis>
	    <<becomeSlave(?+{MasterO})>>
	  <Item>
	    makes <<self>> become a slave of ?_{MasterO}.  <<self>> must
	    not yet be a slave of any object, else the error exception
	    <<object(slaveNotFree)>> is raised.

	  <Entry><<isFree>>
	    <Index/<<Object>><And><<slave>><And><<isFree>>/
	  <Synopsis>
	    <<isFree(??{B})>>
	  <Item>
	    tests whether <<self>> is not the slave of any object.

	  <Entry><<free>>
	    <Index/<<Object>><And><<slave>><And><<free>>/
	  <Synopsis>
	    <<free()>>
	  <Item>
	    frees <<self>>.  <<self>> must be the slave of some object,
	    else the error exception <<object(slaveAlreadyFree)>> is
	    raised.
	</List>

  <Section>
    <Title/Functors/
    <P>
      The module <Span class=index/<<Functor>>/ contains procedures operating
      on functors.
      <List>
	<Entry><<is>>
	  <Index class=tails/<<Functor>><And><<is>>/
	<Synopsis>
	  <<{Functor.is ?+{X} ??{B}}>>
	<Item>
	  tests whether ?_{X} is a functor.

	<Entry><<new>>
	  <Index class=tails/<<Functor>><And><<new>>/
	<Synopsis>
	  <<{Functor.new ?+{T1} ?+{T2} ?+{P} ??{B}}>>
	<Item>
	  returns a new functor with imports as described by&nbsp;?_{T1},
	  exports as described by&nbsp;?_{T2} and body as performed
	  by&nbsp;?_{P}.
	  <!--** be a bit more verbose -->

	<Entry><<getFeatures>>
	  <Index class=tails/<<Functor>><And><<getFeatures>>/
	<Synopsis>
	  <<{Functor.getFeatures ?+{Functor} ??{LIs}}>>
	<Item>
	  returns a list of the features exported by <<?_{Functor}>>.
      </List>
</Chapter>
