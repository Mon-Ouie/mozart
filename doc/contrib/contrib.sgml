<!doctype book system "ozdoc.dtd" [
<!entity EG PI "PI:EG">
]>
<book proglang=oz>
    <meta name="html.split" value="chapter.regex">
    <meta name="html.split" value="chapter.gdbm">
    <title/Contributed Libraries/
    <author.extern to="author.db" key="Denys.Duchier">

    <chapter id=chapter.regex>
      <title/Regular Expressions/
      <p>The <code/regex/ module implements an interface to the POSIX
regex library and builds some higher level facilities on top of it.
The module may be imported as follows:
<code display>import Regex @ 'x-oz://contrib/regex'</code>
      <list>
	<entry>Regex.is
	<synopsis>{Regex.is ?+{X} ??{B}}
	<item>Returns <code/true/ iff ?_{X} is a regex object.
	<entry>Regex.make
	<synopsis>{Regex.make ?+{PAT} ??{RE}}
	<item>Creates regex object ?_{RE} from virtual string pattern ?_{PAT}.
	<entry>Regex.search
	<synopsis>{Regex.search ?+{RE} ?+{TXT} ??{MATCH}}
	<item>Returns the next ?_{MATCH} of regex ?_{RE} in virtual string
?_{TXT}, or <code/false/ if there is no such match.  ?_{RE} is also
permitted to be a virtual string pattern, in which case it is
automatically compiled into a regex object.
<p>A match is a record with integer features: one for each group in
the pattern and also feature 0 for the whole match.  The value on each
feature is a pair <code/I#J/ of start and end indices into ?_{TXT}.
If ?_{TXT} is a byte string, you can simply invoke
<code/{ByteString.slice TXT I J}/ to extract the match.
	<entry>Regex.group
	<synopsis>{Regex.group ?+{N} ?+{MATCH} ?+{TXT} ??{GROUP}}
	<item>Return the substring ?_{GROUP} matched by the ?_{N} group of
?_{MATCH} in virtual string ?_{TXT}.  ?_{MATCH} should be the result
of calling <code/Regex.search/ on ?_{TXT}.
	<entry>Regex.groups
	<synopsis>{Regex.groups ?+{MATCH} ?+{TXT} ??{GROUPS}}
	<item>Returns the list ?_{GROUPS} of substrings of ?_{TXT}
corresponding to the groups of ?_{MATCH}.  Group 0 (the whole match)
is not included.
	<entry>Regex.allMatches
	<synopsis>{Regex.allMatches ?+{RE} ?+{TXT} ??{MATCHES}}
	<item>Returns the list of all ?_{MATCHES} of regular expression ?_{RE}
in virtual string ?_{TXT}.  ?_{RE} should not be anchored.
	<entry>Regex.forAll
	<synopsis>{Regex.forAll ?+{RE} ?+{TXT} ?+{P}}
	<item>Applies the 1 argument procedure ?_{P} to every match of ?_{RE}
in ?_{TXT}.
	<entry>Regex.map
	<synopsis>{Regex.map ?+{RE} ?+{TXT} ?+{F} ??{RESULTS}}
	<item>Applies the 1 argument function ?_{F} to every match of ?_{RE}
in ?_{TXT} and returns the corresponding list of ?_{RESULTS}.
	<entry>Regex.foldR
	<synopsis/{Regex.foldR ?+{RE} ?+{TXT} ?+{F} ?_{INIT} ??{RESULT}}/
	<entry>Regex.foldL
	<synopsis/{Regex.foldL ?+{RE} ?+{TXT} ?+{F} ?_{INIT} ??{RESULT}}/
	<item>The usual reduction procedure (see List module).
	<entry>Regex.split
	<synopsis>{Regex.split ?+{RE} ?+{TXT} ??{STRINGS}}
	<item>Splits the input ?_{TXT} at every match of separator
?_{RE}, and returns the resulting list of strings.
	<entry>Regex.compile
	<synopsis>{Regex.compile ?+{PAT} ?+{CFLAGS} ??{RE}}
	<item>This is the more complicated version of
<code/Regex.make/.  The 
additional ?_{CFLAGS} argument further parametrizes the regex
compilation process.  It is either an atom or a list of atoms, from
the set: <code/extended/, <code/icase/, <code/nosub/, <code/newline/.
The default is <code/[extended newline]/.  See the man page for
<code proglang=c/regcomp/ for further details.
	<entry>Regex.execute
	<synopsis>{Regex.execute ?+{RE} ?+{TXT} ?+{IDX} ?+{EFLAGS} ??{MATCH}}
	<item>This is the more complicated version of <code/Regex.search/.
Integer ?_{IDX} is the offset at which to start the search in
?+{TXT}. ?_{EFLAGS} further specify how to search: it is an atom or
list of atoms, from the set: <code/notbol/, <code/noteol/.  The
default is <code/nil/.  See the man page for <code
proglang=c/regexec/ for further details.
	<entry>Regex.cflags.set
	<entry>Regex.cflags.get
	<synopsis>{Regex.cflags.set ?+{SPEC}}
	<synopsis>{Regex.cflags.get ??{SPEC}}
	<item>Set or get the current ?_{CFLAGS} defaults, &EG; used by
<code/Regex.make/.
	<entry>Regex.eflags.set
	<entry>Regex.eflags.get
	<synopsis>{Regex.eflags.set ?+{SPEC}}
	<synopsis>{Regex.eflags.get ??{SPEC}}
	<item>Set or get the current ?_{EFLAGS} defaults, &EG; used by
<code/Regex.search/.
</list>

    <chapter id=chapter.gdbm>
      <title/GDBM Database/
      <p>The <code/gdbm/ module implements an interface to the GNU
GDBM database library and builds some higher level facilities on top
of it.  The module may be imported as follows:
<code display>import Gdbm @ 'x-oz://contrib/gdbm'</code>
The interface provided is similar to dictionaries and allows to store
stateless Oz terms under keys.  A key is an arbitrary virtual string.
      <list>
	  <entry/Gdbm.is/
	  <synopsis/{Gdbm.is ?+{X} ??{B}}/
	  <item>Returns <code/true/ iff ?_{X} is a gdbm object.
	  <entry/Gdbm.new/
	  <synopsis/{Gdbm.new ?+{R} ??{DB}}/
	  <item>This is the convenient way of creating a gdbm
object ?_{DB}. ?_{R} is a record that describes how to open the
database.  The label is the opening method, &EG; <code/read/,
<code/write/, <code/create/, or <code/new/.  The first
argument of the record is the file name.  For example
<code>read('/usr/local/people.db')</code> asks to open the database
located in <file>/usr/local/people.db</file> for reading only.
<code>create('~/data')</code> opens or creates the database
<file/data/ in the user's home directory and opens it both for reading
and writing; <code>new('~/data')</code> is similar, but overwrites it
if it already existed.
	    <p>Optional feature <code/mode/ indicates with what
permissions the file should be created (this of course is only
relevant for creating a new database).  The mode may be specified as
an integer, with the usual Unix meaning.  It may also be specified
symbolically, as a record or list of records:
<code display/[owner group(read)]/
This indicates that the owner has all permission rights and that group
members are granted read access.  Others have no rights.  To also
grant write access to group members, you could say:
<code display/[owner group(read write)]/
The default is 0644: owner has read and write access; all others have
read access.
	    <p>Optional feature boolean <code/fast/ requests updates
without disk synchronization.  See the GDBM documentation for details.
Default is <code/false/.
	  <entry/Gdbm.open/
	  <synopsis/{Gdbm.open ?+{FILE} ?+{FLAGS} ?+{MODE} ?+{BLOCK} ??{DB}}/
	  <item>This is the more complicated way of opening a gdbm database.
The ?_{FLAGS} specify the opening method. This is an atom or list of
atoms from the set: <code/read/, <code/write/, <code/create/
(equivalently <code/new/ or <code/truncate/).  It may also include the
atom <code/fast/ (see above).  Each symbol may be abbreviated to its
initial letter. ?_{MODE} was described above. ?_{BLOCK} is an integer
for the block size of transfers (see GDBM documentation): use 0 to get
a system dependent appropriate default.
	  <entry/Gdbm.get/
	  <synopsis/{Gdbm.get ?+{DB} ?+{KEY} ??{VAL}}/
	  <item>Retrieves the Oz value ?_{VAL} stored under ?_{KEY}.
The latter may be an arbitrary virtual string.  If there is no such
?_{KEY} in ?_{DB}, an exception is raised.
	  <entry/Gdbm.condGet/
	  <synopsis/{Gdbm.condGet ?+{DB} ?+{KEY} ?_{DEFAULT} ??{VAL}}/
	  <item>Similar to the above, but returns ?_{DEFAULT} if there
is no such ?_{KEY} in ?_{DB}.
	  <entry/Gdbm.put/
	  <synopsis/{Gdbm.put ?+{DB} ?+{KEY} ?+{VAL}}/
	  <item>Stores Oz value ?_{VAL} under ?_{KEY} in
?_{DB}. ?_{VAL} must be ground and stateless.
	  <entry/Gdbm.firstkey/
	  <synopsis/{Gdbm.firstkey ?+{DB} ??{KEY}}/
	  <item>Returns a ?_{KEY} in ?_{DB} (see below).  There is
absolutely no guarantee as to which key this is going to be.  Returns
<code/unit/ if the database is empty.
	  <entry/Gdbm.nextkey/
	  <synopsis/{Gdbm.nextkey ?+{DB} ?+{KEY} ??{NEXT}}/
	  <item>Returns the ?_{NEXT} key after ?_{KEY}.  Again, there
is no guarantee as to which key this is going to be.  The only
guarantee is that if you continue in this manner, you will enumerate
all the keys in the database, in some order, without repeats.  Returns
<code/unit/ when there are no more keys.
	  <entry/Gdbm.close/
	  <synopsis/{Gdbm.close ?+{DB}}/
	  <item>Closes the database.  Subsequent access attempts
raise an exception.
	  <entry/Gdbm.remove/
	  <synopsis/{Gdbm.remove ?+{DB} ?+{KEY}}/
	  <item>Deletes the entry for ?_{KEY} if it exists.
	  <entry/Gdbm.reorganize/
	  <synopsis/{Gdbm.reorganize ?+{DB}}/
	  <item>see the GDBM documentation.
	  <entry/Gdbm.keys/
	  <synopsis/{Gdbm.key ?+{DB} ??{KEYS}}/
	  <item>Returns the lazy list of all ?_{KEYS} in the database.
	  <entry/Gdbm.entries/
	  <synopsis/{Gdbm.entries ?+{DB} ??{ENTRIES}}/
	  <item>Returns the lazy list of all pairs <code/KEY#VALUE/ in
the database.
	  <entry/Gdbm.items/
	  <synopsis/{Gdbm.items ?+{DB} ??{ITEMS}}/
	  <item>Returns the lazy list of all values stored in the
database.
	  <entry/Gdbm.forAll/
	  <synopsis/{Gdbm.forAll ?+{DB} ?+{P}}/
	  <item>Calls <code/{P KEY}/ for every key in the database.
	  <entry/Gdbm.forAllInd/
	  <synopsis/{Gdbm.forAllInd ?+{DB} ?+{P}}/
	  <item>Calls <code/{P KEY VALUE}/ for every entry in the
database.
	</list>
</book>
<!--
Local Variables:
mode: sgml
mode: auto-fill
sgml-default-dtd-file: "book.ced"
sgml-auto-activate-dtd: t
adaptive-fill-mode: nil
End:
-->
