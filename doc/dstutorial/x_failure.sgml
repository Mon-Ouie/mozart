<CHAPTER ID="chapter.failure">
  <TITLE>Handling failure</TITLE>

<P> This chapter first introduces the Mozart failure model:
what we assume can go wrong with the system
and how this is reflected in the language entities.
We then show how to program with this model.
We first present
basic fault-tolerant versions of
the common language operations.
Then we present
fault-tolerant versions of the server examples.
Finally
we summarize the basic fault-detection
and handling primitives of the language.
These primitives are used to build
the fault-tolerant abstractions.

<SECTION><TITLE>Failure model</TITLE>

<P> The failure model is designed to cover the
vast majority of failures occurring in distributed systems,
namely instantaneous, permanent site failures (fail-stop)
and both temporary and permanent communication failures.
This failure model is reflected in each language entity.
The system provides mechanisms to be informed of failures
and to program with language entities that are subject
to failures.

<P> All failure modes are defined with respect to
a given language entity on a given site.
For example, one would like to send a message
to a port from a given site.
In general,
there are four situations that can occur
relative to a language entity on a given site:
<LIST>
<ITEM> The entity works normally (fault state <<ok>>).
<ITEM> The entity is temporarily not working
(fault state <<tempBlock>>).
This is because a site crucial to the entity's operation
is unreachable due to a network problem.
This fault state can go away.
The network layer actively tries
to reestablish another connection.
<ITEM> The entity is permanently not working
(fault state <<permBlock>>).
This is because a site crucial to the entity's operation
has crashed.
This fault state is permanent.
<ITEM> The entity works normally on the given site
(fault state <<remoteProblem>>),
but there are some remote problems that might
have a bearing on the application's use of the entity.
For example, one is waiting for a variable
binding on a given site,
but the site that will bind the value has crashed.
This fault state can go away if the
remote problems are temporary.
</LIST>
<P> An entity on a site therefore has four
possible basic fault states.
We now explain how these fault states occur
in terms of the possible system failures.
Each language entity has a different
distributed protocol, and therefore the
fault states occur in different ways.
In the case of <<remoteProblem>>, it is usually
possible to find out something about what the
problem is, depending on the type of the entity.

<SUBSECTION><TITLE>Eager stateless data</TITLE>

<P> Eager stateless data are
copied immediately in messages.
There are therefore no remote references to eager
stateless data, which are
always local to a site.
Therefore no special failure handling is needed for them.
Their only possible fault state is <<ok>>.

<P> In future releases, procedures, functions, classes, and functors
will not send their code immediately in the message,
but will send only their global name.
Upon arrival, if the code is not present,
then it will be immediately requested.
This will guarantee that code is sent at most
once to a given site.
This will introduce fault states <<tempBlock>> and <<permBlock>>
if the site containing the code
becomes unreachable or crashes.


<SUBSECTION><TITLE>Sited entities</TITLE>

<P> Sited entities can be referenced remotely
but can only be used on their home site.
Attempting to use one outside of its home
site immediately raises an exception,
without any network operations.
Therefore no special failure handling is needed for them.
Their only possible fault state is <<ok>>.

<SUBSECTION><TITLE>Ports</TITLE>

<SUBSECTION><TITLE>Logic variables</TITLE>

<SUBSECTION><TITLE>Objects and cells</TITLE>

<SECTION><TITLE>Basic fault-tolerant operations</TITLE>


</CHAPTER>
