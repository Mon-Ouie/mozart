<CHAPTER ID="chapter.failure">
  <TITLE>Failure Model</TITLE>

<P>Distributed systems have the partial failure
property, that is, part of the system can fail
while the rest continues to work.
Partial failures are not at all rare.
Properly-designed applications must take
them into account.
This is both good and bad for application design.
The bad part is that it makes applications more complex.
The good part is that applications can take
advantage of the redundancy offered by
distributed systems to become more robust.

<P>The Mozart failure model defines what failures
are recognized by the system
and how they are reflected in the language.
The system recognizes
permanent site failures that are instantaneous (fail-stop)
and both temporary and permanent communication failures.
The system provides mechanisms
to program with language entities that are subject
to failures.

<P>The Mozart failure model is accessed
through the module <<Fault>>.
This chapter explains and justifies this
functionality, and gives examples
showing how to use it.
We present the failure model in two steps:
the basic model and the advanced model.
To start writing fault-tolerant applications
it is enough to understand the basic model.
To build fault-tolerant abstractions it
is often necessary to use the advanced model.

<P>In its current state,
the Mozart system provides only the
primitive operations needed to detect failure
and reflect it in the language.
The design and implementation of
fault-tolerant abstractions
within the language
by using these primitives
is the subject of ongoing research.
This chapter and the next one give the first results
of this research.
All comments and suggestions for improvements are welcome.

<SECTION><TITLE>Fault states</TITLE>

<P>All failure modes are defined with respect to
both a language entity and a particular site.
For example, one would like to send a message
to a port from a given site.
The site may or may not be able to send the message.
In general, a language entity can be in four states
on a given site:
<LIST>
<ITEM> The entity works normally (local fault state <<ok>>).
<ITEM> The entity is temporarily not working
(local fault state <<tempFail>>).
This is because a site crucial to the entity
is currently unreachable due to a network problem.
This fault state can go away.
The network layer actively tries
to reestablish another connection.
<ITEM> The entity is permanently not working
(local fault state <<permFail>>).
This is because a site crucial to the entity
has crashed.
This fault state is permanent.
<ITEM> The entity works normally on the given site
(local fault state <<remoteProblem(I)>>, where <<I>>
identifies the remote problem),
but there are some remote problems that might
have a bearing on the application's use of the entity.
For example, a given site waits for a variable binding,
but the site that will do the binding has crashed.
This fault state can go away if the
remote problems are temporary.
</LIST>
<P>The system cannot always determine
whether a fault is temporary or permanent.
In particular, a <<tempFail>> may hide
a crash on the other side.

<P>The fault state <<remoteProblem(I)>>
identifies four different remote problems:
<LIST>
<ITEM> <<I=permSome>>: At least one of the other sites
referencing the entity is failed.
<ITEM> <<I=permAll>>: All of the other sites referencing
the entity are failed.
<ITEM> <<I=tempSome>>: At least one of the other sites
referencing the entity is currently unreachable.
<ITEM> <<I=tempAll>>: All of the other sites
referencing the entity are currently unreachable.
</LIST>

<P>There are six fault states in all, namely
<<tempFail>>,
<<permFail>>,
<<remoteProblem(permSome)>>,
<<remoteProblem(permAll)>>,
<<remoteProblem(tempSome)>>, and
<<remoteProblem(tempAll)>>.
All fault detection primitives
are triggered on
some subset of these fault states.


<SUBSECTION><TITLE>Temporary faults</TITLE>

<P>The fault state <<tempFail>> exists to allow the
application to react quickly to temporary network problems.
It is raised by the system as soon as a network problem
is recognized.
It is therefore fundamentally different from a time-out.
For example, TCP gives a time-out after some minutes.
This duration has been chosen to be very long,
approximating infinity from the viewpoint of the
network connection.
After the time-out,
one can be sure that the connection is no longer working.

<P>The purpose of <<tempFail>> is quite different from a time-out.
It is to <EM>inform</EM> the application
of network problems, not to mark the <EM>end</EM> of a connection.
For example, an application might be connected to a given server.
If there are problems with this server, the application
would like to be informed quickly so that it can try connecting
to another server.
The <<tempFail>> exceptions will therefore be relatively frequent,
much more frequent than time-outs.

<P>It is possible for a <<tempFail>> state to last forever.
For example, if a user disconnects the network connection of a laptop
machine, then only he or she knows whether the problem is permanent.
The application cannot know this in general.
The decision whether to continue waiting on a temporary failure
or whether to interrupt the wait can cut through all levels of
abstraction to appear at the top level.
The application might then pop up a window to ask the user whether
to continue waiting or not.

<SECTION><TITLE>Basic model</TITLE>

<P>We present the failure model in two steps:
the basic model and the advanced model.
In the basic model,
attempting to perform operations
on entities with problems will
either block or raise an exception without doing the operation.
The simplest way to start writing fault-tolerant
applications is to use the basic model.

<SUBSECTION><TITLE>Enabling exceptions on faults</TITLE>

<P>By default, an exception will be raised on fault states
<<tempFail>> or <<permFail>>.
A <<remoteProblem>> is ignored, i.e., the operation
completes normally.
The following operations are provided to change this behavior:
<LIST>
<ITEM> <<proc {Fault.defaultEnable FStates}>> sets the global default.
<<FStates>> is a list of fault states that cause exceptions.
When the system starts up, the defaults are set up as if
the call <<{Fault.defaultEnable [tempFail,permFail]}>> had been done.

<ITEM> <<fun {Fault.enable Entity Level FStates}>> is a more targeted
way to do fault detection.
It enables fault detection on a given entity at a given
level for a given set of fault states.
If one or more of these faults occurs while attempting
an operation at the given level (levels are explained below),
then an exception is raised instead of doing the operation.
The <<Entity>> is a reference to
a particular object, cell, port, lock, or logic variable.
The <<Level>> is <<global>>, <<site>>, or <<thread(T)>>
(where <<T>> is a thread identifier, e.g., <<{Thread.this T}>>).

<ITEM> <<fun {Fault.disable Entity Level}>> disables
fault detection on the given entity at the given level.
</LIST>
<P>The function <<Fault.enable>> returns <<true>> if and only if the
enable was successful, i.e., the entity was not already
enabled for that level.
The function <<Fault.disable>> returns <<false>> if and only if the
disable was successful, i.e., the entity was already
enabled for that level.
Both functions raise a type error exception if their arguments
do not have the correct type.

<SUBSECTION><TITLE>Exception formats</TITLE>

<P>The exceptions raised have the format
<<system(dp(entity:E type:T conditions:FS op:OP) ...)>>,
where the four arguments are defined as follows:
<LIST>
<ITEM> <<E>> is the entity on which the operation was attempted.
A temporary limitation of the current release is that
if the entity is an object, then <<E>> is undefined.
<ITEM> <<T>> is the type of the entity, which is one
of <<variable>>, <<cell>>, <<lock>>, <<port>>, or <<object>>.
<ITEM> <<FS>> is the list of actual fault states occurring
at the site on which the operation was attempted.
This list is a subset of the list for which fault detection
was enabled.
Each fault state in <<FS>> may have an extra
field <<info:>> that gives additional information about
the fault.
The possible elements of <<FS>> are
currently the following:
<LIST>
<ITEM> <<tempFail(info:I)>> or <<permFail(info:I)>>,
where <<I>> is in {<<state>>, <<owner>>}.
The <<info:>> field only exists for
objects, cells, and locks.
<ITEM> <<remoteProblem(tempSome)>>, <<remoteProblem(permSome)>>,
<<remoteProblem(tempAll)>>, or
<<remoteProblem(permAll)>>.
</LIST>

<ITEM> <<OP>> indicates which attempted operation caused the exception.
The possible values of <<OP>> are currently:
<LIST>
<ITEM> For logic variables: <<bind(T)>>, <<wait>>, and <<isDet>>,
where <<T>> is what the variable was attempted to be bound with.
<ITEM> For cells:
<<cellExchange(Old New)>>,
<<cellAssign(New)>>, and
<<cellAccess(Old)>>,
where <<Old>> is the cell content before the attempted operation
and <<New>> is the cell content after the attempted operation.
<ITEM> For locks: <<lock>>.
<ITEM> For ports: <<send(Msg)>>,
where <<Msg>> is the message attempted to be sent to the port.
<ITEM> For objects:
<<objectExchange(Attr Old New)>>,
<<objectAssign(Attr New)>>,
<<objectAccess(Attr Old)>>, and
<<objectFetch>>,
where <<Attr>> is the name of the object attribute,
<<Old>> is the attribute value before the attempted operation,
and <<New>> is the attribute value after the attempted operation.
The <<objectFetch>> operation exists because object-records
are copied lazily: the first time the object is used, the
object-record is fetched over the network, which might fail.
<ITEM> For any probed entity: <<probe>>.
The operation <<{Probe Entity}>> can be done on all
entities and will block forever until a distribution fault
causes an exception to be raised or a handler to be called.
Watchers (see below) are implemented by means of <<Probe>>.
A temporary limitation of the current release is that
the <<Probe>> operation is not available to users.
</LIST>

</LIST>

<SUBSECTION><TITLE>Levels of fault detection</TITLE>

<P>There are three levels of fault detection,
depending on where the attempted operation is executed.
The most general is
<<global>>, which detects the fault when the operation
is attempted anywhere.
Next is <<site>>, which detects the fault when the
operation is attempted on one particular site.
Each site can have a set of enabled fault states.
Finally, the most fine-grained is
<<thread(T)>>, which detects the fault when the
operation is attempted in a particular thread.
The thread is identified by
<<T>>, which can be obtained in the thread by <<{Thread.this T}>>.
Each thread can have a set of enabled fault states.

<P>The thread level is the most specific; if it is enabled
it overrides the two others in its thread.
The site level, if it is enabled, overrides the global level.
Finally, if neither a thread nor a site level are
enabled, then the global level is used.
It doesn't matter what the actual fault states are;
the thread level always overrides the site level,
which always overrides the global level.

<P>For example, let's say that the cell <<C>>
has a global detection for <<[tempFail,permFail]>>
and a thread-specific detection for <<[permFail]>>
in thread <<T1>>.
Let's say that many threads are trying to do
an exchange, but that the cell's actual fault state
is <<tempFail>> everywhere.
Then thread <<T1>> will block, since it is set up
to detect only <<permFail>>.
All other threads will raise the exception <<tempFail>>.

<SECTION><TITLE>Advanced model</TITLE>

<P>The basic model lets you set up the system to do
one of two things when an operation is attempted:
either raise an exception or block (do nothing).
The advanced model calls a user-defined
procedure instead of raising an exception.
This procedure is called a <EM>fault handler</EM>.
When an operation is attempted
on an entity with a problem,
then a handler call replaces the operation.
This call is done in the context of the thread
that attempted the operation.
If the entity is working again later
(which is possible with <<tempFail>>
and <<remoteProblem>>) then the
handler can just try the operation again.

<P>In an exact analogy to the basic model,
a fault handler can be installed to be called
on a given entity at a given level
for a given set of fault states.
The possible entities, levels, and fault states
are the same.

<P>Handlers are installed and deinstalled with the
following two built-in operations:
<LIST>
<ITEM> <<fun {Fault.install Entity Level FStates HandlerProc}>>
<ITEM> <<fun {Fault.deInstall Entity Level}>>
</LIST>
<P>The function <<Fault.install>> returns <<true>> if and only if the
installation was successful, i.e., the entity did not already
have an installation or an enable for that level.
The function <<Fault.deInstall>> returns <<true>> if and only if the
disable was successful, i.e., the entity was already
enabled for that level.
Both functions raise a type error exception if their arguments
do not have the correct type.
A temporary limitation of the current release is that
one cannot install global handlers.

<P>A handler <<HandlerProc>> is a three-argument
procedure that is called as <<{HandlerProc E FS OP}>>.
The arguments <<E>>, <<FS>>, and <<OP>>,
are exactly the same arguments as given
in a distribution exception.

<SUBSECTION><TITLE>Eager failure detection</TITLE>

<P>Fault handlers detect failure when an operation is attempted.
One often wants to be informed earlier.
The advanced model allows the application to be informed
as soon as the site finds out about the failure.
Two operations are provided:
<LIST>
<ITEM> <<proc {Fault.installWatcher Entity FStates WatcherProc}>>
<ITEM> <<proc {Fault.deinstallWatcher Entity}>>
</LIST>
<P>The procedure <<Fault.installWatcher>> creates a new thread
on the current site, in which <<WatcherProc>> will be invoked
as soon as the site detects that
a fault state in <<FStates>> occurs.
The procedure <<Fault.deinstallWatcher>> removes all watchers
on the current site.

<P>A watcher <<WatcherProc>> is a three-argument
procedure with exactly the same argument list as a handler.
It is called as <<{WatcherProc E FS OP}>>.
The arguments <<E>> and <<FS>>
are exactly the same arguments as given
in a distribution exception.
The argument <<OP>> always has the value <<probe>>.


<SECTION><TITLE>Fault states for language entities</TITLE>

<P>This section explains the possible fault states
of each language entity in terms of its distributed behavior.
The fault state is
a consequence of two things:
the entity's distributed implementation and
the system's failure mode.
For example, let's consider a variable.
There is one owner site and a set of proxy sites.
If a variable proxy is
on a crashed site and the owner site
is still working,
then to another variable proxy this
will be a <<remoteProblem>>.
If the owner site crashes, then
all proxies will see a <<permFail>>.

<SUBSECTION><TITLE>Eager stateless data</TITLE>

<P>Eager stateless data, namely records, procedures,
functions, and functors, are
copied immediately in messages.
There are no remote references to eager
stateless data, which are always local to a site.
So their only possible fault state is <<ok>>.

<P>In future releases, procedures, functions, and functors
will not send their code immediately in the message,
but will send only their global name.
Upon arrival, if the code is not present,
then it will be immediately requested.
This will guarantee that code is sent at most
once to a given site.
This will introduce fault states <<tempFail>> and <<permFail>>
if the site containing the code
becomes unreachable or crashes.


<SUBSECTION><TITLE>Sited entities</TITLE>

<P>Sited entities can be referenced remotely
but can only be used on their home site.
Attempting to use one outside of its home
site immediately raises an exception.
Detecting this does not need any network operations.
So their only possible fault state is <<ok>>.

<SUBSECTION><TITLE>Ports</TITLE>

<P>A port has one owner site
and a set of proxy sites.
The following failure modes are possible:
<LIST>
<ITEM> Normal operation (<<ok>>).
<ITEM> Owner site down (<<permFail>>).
<ITEM> Owner site unreachable (<<tempFail>>).
</LIST>
<P>A port has a single operation, <<Send>>,
which can complete if the fault state is <<ok>>.
The <<Send>> operation is asynchronous,
that is, it completes immediately on the
sender site and at some later point in time
it will complete on the port's owner site.
The fact that it completes on the sender site
does not imply that it will complete on the owner site.
This is because the owner site may fail.

<P>We will see later how to build a <<SafeSend>> abstraction
that only completes on the sender site if it completes
on the owner site.

<SUBSECTION><TITLE>Logic variables</TITLE>

<P>A logic variable has one owner site
and a set of proxy sites.
The following failure modes are possible:
<LIST>
<ITEM> Normal operation (<<ok>>).
<ITEM> Owner site down (<<permFail>>).
<ITEM> Owner site unreachable (<<tempFail>>).
<ITEM> Some or all proxy sites down
(<<remoteProblem(I)>> where <<I>> is <<permSome>> or <<permAll>>).
<ITEM> Some or all proxy sites unreachable
(<<remoteProblem(I))>> where <<I>> is <<tempSome>> or <<tempAll>>).
</LIST>
<P A logic variable has two operations,
binding and waiting until bound.
Bind operations are explicit in the program text.
Most wait operations are implicit:
threads block until their data is available.
The bind operation will only complete if the
fault state is <<ok>> or <<remoteProblem>>.

<P>If the application binds a variable,
then its wait operation is only sure to complete if the
fault state is <<ok>>.
When it completes, this means
that another proxy has bound the variable.
If the fault state is <<remoteProblem>>,
then the wait operation may not be able
to complete if the problem exists
at the proxy that should bind the variable.
Therefore, it is important to detect the
fault state <<remoteProblem>>.

<P>A common case for variables is the client-server.
The client sends a request containing a variable to the server.
The server binds the variable to the answer.
The variable exists only on the client and server sites.
In this case, if the client detects a <<remoteProblem>>
then it knows that the variable binding will be delayed.

<SUBSECTION><TITLE>Cells and locks</TITLE>

<P>Cells and locks have almost the same failure behavior.
A cell or lock has one owner site and a set of proxy sites.
At any given time instant,
the cell's state pointer or the lock's token
is at one proxy or in the network.
The following failure modes are possible:
<LIST>
<ITEM> Normal operation (<<ok>>).
<ITEM> Owner site down and state pointer not present
(<<permFail(info:owner)>>).
<ITEM> Owner site unreachable and state pointer not present
(<<tempFail(info:owner)>>).
<ITEM> State pointer lost (owner site up)
(<<permFail(info:state)>>).
This failure mode is only for cells.
If a lock token is lost then the owner recreates it.
<ITEM> State pointer unreachable (owner site up)
(<<tempFail(info:state)>>).
<ITEM> State pointer present and owner site down
(<<remoteProblem(permAll)>>).
<ITEM> State pointer present and owner site unreachable
(<<remoteProblem(tempAll)>>).
</LIST>
<P>Objects and cells have one primitive operation,
namely a state update.
For a cell this operation is called <<Exchange>>.

<SUBSECTION><TITLE>Objects</TITLE>

<P>An object consists of
an object-record that is a lazy chunk
and that references
the object's features, a cell, and a class.
The object-record is lazy: it is copied to the site
when the object is used for the first time.
This means that
the following failure modes are possible:
<LIST>
<ITEM> Normal operation (<<ok>>).
<ITEM> Owner site down and
object-record or state pointer not present
(<<permFail(info:owner)>>).
<ITEM> Owner site unreachable and
object-record or state pointer not present
(<<tempFail(info:owner)>>).
<ITEM> State pointer lost (owner site up)
(<<permFail(info:state)>>).
<ITEM> State pointer unreachable (owner site up)
(<<tempFail(info:state)>>).
<ITEM> Object-record and state pointer present and owner site down
(<<remoteProblem(permAll)>>).
<ITEM> Object-record and state pointer present and owner site unreachable
(<<remoteProblem(tempAll)>>).
</LIST>
Compared to cells,
objects have two new failure modes:
the object-record can be temporarily or permanently absent.
In both cases the object
cannot be used, so we simply consider the new failure modes
to be instances of <<permFail>> and <<tempFail>>.

<SECTION><TITLE>Limitations of current release</TITLE>

<P>The current release has the following limitations:
<LIST>
<ITEM>If an exception is raised or a handler invoked
due to a distribution fault of an object,
then the entity argument <<E>> is undefined.
<ITEM>The <<global>> level is not implemented for handler installation,
i.e., the call <<{Fault.install global _ _}>> is not implemented.
If an attempt is made to install a global handler,
then a <<notImplemented>> exception is given.
<ITEM>The operation <<Probe>> is not available to the user.
</LIST>

</CHAPTER>
