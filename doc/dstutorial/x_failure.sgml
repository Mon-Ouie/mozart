<CHAPTER ID="chapter.failure">
  <TITLE>Failure Model</TITLE>

<P>Distributed systems have the partial failure
property, that is, part of the system can fail
while the rest continues to work.
Partial failures are not at all rare.
Properly-designed applications must take
them into account.
This is both good and bad for application design.
The bad part is that it makes applications more complex.
The good part is that applications can take
advantage of the redundancy offered by
distributed systems to become more robust.

<P>The Mozart failure model defines what failures
are recognized by the system
and how they are reflected in the language.
The system recognizes
permanent site failures that are instantaneous (fail-stop)
and both temporary and permanent communication failures.
The system provides mechanisms
to program with language entities that are subject
to failures.

<P>The Mozart failure model is accessed
through the module <ref.extern to="ozdoc:system"
key="chapter.fault"/<<Fault>>/.
This chapter explains and justifies this
functionality, and gives examples
showing how to use it.
We present the failure model in two steps:
the basic model and the advanced model.
To start writing fault-tolerant applications
it is enough to understand the basic model.
To build fault-tolerant abstractions it
is often necessary to use the advanced model.

<P>In its current state,
the Mozart system provides only the
primitive operations needed to detect failure
and reflect it in the language.
The design and implementation of
fault-tolerant abstractions 
within the language
by using these primitives
is the subject of ongoing research.
This chapter and the next one give the first results
of this research.
All comments and suggestions for improvements are welcome.

<P>This chapter carefully indicates where the current release
is incomplete with respect to the specification
(this is called a <EM>limitation</EM>)
or has a different behavior (this is called a <EM>modification</EM>).
All limitations and modifications are listed where
they occur.
A complete list is given at the end of the chapter.

<SECTION><TITLE>Fault states</TITLE>

<P>All failure modes are defined with respect to
both a language entity and a particular site.
For example, one would like to send a message
to a port from a given site.
The site may or may not be able to send the message.
A language entity can be in three fault states
on a given site:
<LIST>
<ITEM> The entity works normally (local fault state <<ok>>).
<ITEM> The entity is temporarily not working
(local fault state <<tempFail>>).
This is because a remote site crucial to the entity
is currently unreachable due to a network problem.
This fault state can go away.
A limitation of the current release is that
temporary problems are indicated very slowly.
<ITEM> The entity is permanently not working
(local fault state <<permFail>>).
This is because a site crucial to the entity
has crashed.
This fault state is permanent.
</LIST>
<P>The system cannot always determine
whether a fault is temporary or permanent.
In particular, a <<tempFail>> may hide a site crash.
However, network failures can always
be considered temporary since the
system actively tries
to reestablish another connection.

<P>These three fault states pertain
to whether an entity operation can be performed locally.
An entity can also contain additional information.
<LIST>
<ITEM> On at least one remote site,
the entity is not working
(local fault state <<remoteProblem(I)>>, where <<I>>
identifies the remote problem).
For example, the current site waits for a variable binding,
but the remote site that will do the binding has crashed.
This is a permanent remote problem.
It never goes away.
A temporary remote problem can go away,
just like a <<tempFail>>.
</LIST>
<P>If there is a remote problem,
then it is not always possible to
return a <<remoteProblem>> fault state.
For example,
if the owner site is inaccessible
then it might not be possible to learn
anything about the remote sites.
But if there is no <<tempFail>>
or <<permFail>>, then one will always
be able to get a <<remoteProblem>> fault state.

<P>The fault state <<remoteProblem(I)>> 
identifies four different remote problems:
<LIST>
<ITEM> <<I=permSome>>: At least one of the other sites
referencing the entity has crashed.
<ITEM> <<I=permAll>>: All of the other sites referencing
the entity have crashed.
<ITEM> <<I=tempSome>>: At least one of the other sites
referencing the entity is currently unreachable.
<ITEM> <<I=tempAll>>: All of the other sites
referencing the entity are currently unreachable.
</LIST>

<P>The complete fault state of an
entity consists of at most one
element from the set
{<<tempFail>>, <<permFail>>}
together with at most one element from the set
{<<remoteProblem(permSome)>>,
<<remoteProblem(permAll)>>,
<<remoteProblem(tempSome)>>,
<<remoteProblem(tempAll)>>}.
Permanent remote problems mask temporary ones,
i.e., if <<remoteProblem<<permSome>> is detected
then <<remoteProblem<<tempSome>> cannot be detected.


<SUBSECTION><TITLE>Temporary faults</TITLE>

<P>The fault state <<tempFail>> exists to allow the
application to react quickly to temporary network problems.
It is raised by the system as soon as a network problem
is recognized.
It is therefore fundamentally different from a time-out.
For example, TCP gives a time-out after some minutes.
This duration has been chosen to be very long,
approximating infinity from the viewpoint of the
network connection.
After the time-out,
one can be sure that the connection is no longer working.

<P>The purpose of <<tempFail>> is quite different from a time-out.
It is to <EM>inform</EM> the application
of network problems, not to mark the <EM>end</EM> of a connection.
For example, an application might be connected to a given server.
If there are problems with this server, the application
would like to be informed quickly so that it can try connecting
to another server.
A <<tempFail>> fault state will therefore be relatively frequent,
much more frequent than a time-out.
In most cases, a <<tempFail>> fault state will eventually go away.

<P>It is possible for a <<tempFail>> state to last forever.
For example, if a user disconnects the network connection of a laptop
machine, then only he or she knows whether the problem is permanent.
The application cannot know this in general.
The decision whether to continue waiting on a temporary failure
or whether to interrupt the wait can cut through all levels of
abstraction to appear at the top level.
The application might then pop up a window to ask the user whether
to continue waiting or not.
The important thing is that the network layer does not make this decision;
the application is completely free to decide or to let the user decide.


<SECTION><TITLE>Basic model</TITLE>

<P>We present the failure model in two steps:
the basic model and the advanced model.
In the basic model,
attempting to perform operations
on entities with problems will
either block or raise an exception without doing the operation.
The simplest way to start writing fault-tolerant
applications is to use the basic model.

<SUBSECTION><TITLE>Enabling exceptions on faults</TITLE>

<P>By default, new entities are
set up so that an exception will be raised
on fault states <<tempFail>> or <<permFail>>.
The following operations are provided to do other
kinds of fault detection:
<LIST>
<ENTRY> <<fun {Fault.defaultEnable FStates}>>
<ITEM> enables the default
fault states for the <<global>> level.
For any new entity <<E>> declared after the default is enabled,
it is as if the call <<{Fault.enable E global FStates}>>
were done at its declaration.
<<FStates>> is a list of fault states that cause exceptions.
When the system starts up, the defaults are set up as if
the call <<{Fault.defaultEnable [tempFail permFail]}>> had been done.

<ENTRY> <<fun {Fault.defaultDisable}>>
<ITEM> disables the default
for the <<global>> level.

<ENTRY> <<fun {Fault.enable Entity Level FStates}>>
<ITEM> is a more targeted
way to do fault detection.
It enables fault detection on a given entity at a given
level for a given set of fault states.
If one or more of these faults occurs while attempting
an operation at the given level (levels are explained below),
then an exception is raised instead of doing the operation.
The <<Entity>> is a reference to
a particular object, cell, port, lock, or logic variable.
The <<Level>> is <<global>>, <<site>>, or <<'thread'(T)>>
(where <<T>> is a thread identifier, e.g., <<{Thread.this T}>>).<NOTE
FOOT>Since <<thread>> is already used as a keyword in the language,
it has to be quoted.</NOTE>

<ENTRY> <<fun {Fault.disable Entity Level}>>
<ITEM> disables
fault detection on the given entity at the given level.
</LIST>
<P>The functions <<Fault.defaultEnable>> and <<Fault.enable>> return
<<true>> if and only if the
enable was successful, i.e., the entity was not already
enabled for that level.
The functions <<Fault.defaultDisable>> and <<Fault.disable>> return
<<true>> if and only if the
disable was successful, i.e., the entity was already
enabled for that level.
All functions raise a type error exception if their arguments
do not have the correct type.

<SUBSECTION><TITLE>Exception formats</TITLE>

<P>The exceptions raised have the format
<<<system(dp(entity:E conditions:FS op:OP) ...)>>>
where the four arguments are defined as follows:
<LIST>
<ITEM> <<E>> is the entity on which the operation was attempted.
A temporary limitation of the current release is that
if the entity is an object, then <<E>> is undefined.
<ITEM> <<FS>> is the list of actual fault states occurring
at the site on which the operation was attempted.
This list is a subset of the list for which fault detection
was enabled.
Each fault state in <<FS>> may have an extra
field <<info>> that gives additional information about
the fault.
The possible elements of <<FS>> are
currently the following:
<LIST>
<ITEM> <<tempFail(info:I)>> or <<permFail(info:I)>>,
where <<I>> is in {<<state>>, <<owner>>}.
The <<info>> field only exists for
objects, cells, and locks.
<ITEM> <<remoteProblem(tempSome)>>, <<remoteProblem(permSome)>>,
<<remoteProblem(tempAll)>>, or
<<remoteProblem(permAll)>>.
</LIST>

<ITEM> <<OP>> indicates which attempted operation caused the exception.
The possible values of <<OP>> are currently:
<LIST>
<ITEM> For logic variables: <<bind(T)>>, <<wait>>, and <<isDet>>,
where <<T>> is what the variable was attempted to be bound with.
<ITEM> For cells: 
<<cellExchange(Old New)>>, 
<<cellAssign(New)>>, and
<<cellAccess(Old)>>,
where <<Old>> is the cell content before the attempted operation
and <<New>> is the cell content after the attempted operation.
<ITEM> For locks: <<'lock'>>.
<ITEM> For ports: <<send(Msg)>>,
where <<Msg>> is the message attempted to be sent to the port.
<ITEM> For objects: 
<<objectExchange(Attr Old New)>>,
<<objectAssign(Attr New)>>, 
<<objectAccess(Attr Old)>>, and
<<objectFetch>>,
where <<Attr>> is the name of the object attribute,
<<Old>> is the attribute value before the attempted operation,
and <<New>> is the attribute value after the attempted operation.
A limitation of the current release is that the attempted
operation cannot be retried.
The <<objectFetch>> operation exists because object-records
are copied lazily: the first time the object is used, the
object-record is fetched over the network, which might fail.
<ITEM> For any probed entity: <<probe>>.
The operation <<{Probe Entity}>> can be done on all
entities and will block forever until a distribution fault
causes an exception to be raised or a handler to be called.
A temporary limitation of the current release is that
the <<Probe>> operation is not available to users.
</LIST>

</LIST>

<SUBSECTION><TITLE>Levels of fault detection</TITLE>

<P>There are three levels of fault detection,
global, site-based, and thread-based.
The more specific levels, if they exist,
override the more general levels.
The most general is
<<global>>, which detects the fault when the operation
is attempted anywhere.
Next is <<site>>, which detects the fault when the
operation is attempted on one particular site.
Each site can have a set of enabled fault states.
Finally, the most fine-grained is 
<<'thread'(T)>>, which detects the fault when the
operation is attempted in a particular thread.
The thread is identified by
<<T>>, which can be obtained in the thread by <<{Thread.this T}>>.
Each thread can have a set of enabled fault states.

<P>The thread level is the most specific; if it is enabled 
it overrides the two others in its thread.
The site level, if it is enabled, overrides the global level.
Finally, if neither a thread nor a site level are
enabled, then the global level is used.
It doesn't matter what the actual fault states are;
the thread level always overrides the site level,
which always overrides the global level.

<P>For example, assume that the cell <<C>>
has a global detection for <<[tempFail permFail]>>
and a thread-specific detection for <<[permFail]>>
in thread <<T1>>.
What happens if many threads try to do
an exchange if cell's actual fault state
is <<tempFail>> everywhere?
Then thread <<T1>> will block, since it is set up
to detect only <<permFail>>.
All other threads will raise the exception <<tempFail>>.
Thread <<T1>> will continue the operation when and
if the <<tempFail>> state goes away.

<SECTION><TITLE>Advanced model</TITLE>

<P>The basic model lets you set up the system to do
one of two things when an operation is attempted:
either raise an exception or block (do nothing).
The advanced model calls a user-defined
procedure instead of raising an exception.
This procedure is called a <EM>fault handler</EM>.
When an operation is attempted
on an entity with a problem,
then a handler call replaces the operation.
This call is done in the context of the thread
that attempted the operation.
If the entity works again later
(which is possible with <<tempFail>>
and <<remoteProblem>>) then the
handler can just try the operation again.

<P>In an exact analogy to the basic model,
a fault handler can be installed to be called
on a given entity at a given level
for a given set of fault states.
The possible entities, levels, and fault states
are the same.

<P>Handlers are installed and deinstalled with the
following two built-in operations:
<LIST>
<ENTRY> <<fun {Fault.install Entity Level FStates HandlerProc}>>
<ITEM>The function <<Fault.install>> returns <<true>> if and only if the
installation was successful, i.e., the entity did not already
have an installation or an enable for that level.
<ENTRY> <<fun {Fault.deInstall Entity Level}>>
<ITEM>The function <<Fault.deInstall>> returns <<true>> if and only if the
disable was successful, i.e., the entity was already
enabled for that level.
</LIST>
<P>
Both functions raise a type error exception if their arguments
do not have the correct type.
A limitation of the current release is that
handlers cannot be installed at the <<global>> level.
Another limitation of the current release is that
handlers installed on variables always retry
the operation after they return.

<P>A handler <<HandlerProc>> is a three-argument
procedure that is called as <<{HandlerProc E FS OP}>>.
The arguments <<E>>, <<FS>>, <<OP>>,
are exactly the same as in a distribution exception.

<SUBSECTION><TITLE>Eager failure detection</TITLE>

<P>Fault handlers detect failure when an operation is attempted.
One often wants to be informed earlier.
The advanced model allows the application to be informed
as soon as the site finds out about the failure.
Two operations are provided:
<LIST>
<ENTRY> <<proc {Fault.installWatcher Entity FStates WatcherProc}>>
<ITEM>The procedure <<Fault.installWatcher>> creates a new thread
on the current site, in which <<WatcherProc>> will be invoked
as soon as the site detects that
a fault state in <<FStates>> occurs.
<ENTRY> <<proc {Fault.deInstallWatcher Entity WatcherProc}>>
<ITEM>The procedure <<Fault.deInstallWatcher>> removes the given
watcher from the current site.
</LIST>
<P>A watcher <<WatcherProc>> is a two-argument
procedure that is called as <<{WatcherProc E FS}>>.
Any number of watchers may be installed on a given
entity and deinstalled selectively.
The arguments <<E>> and <<FS>>
are exactly the same arguments are
in a distribution exception or in a handler call.
Watchers are a derived concept.
They are implemented with handlers and the <<Probe>> operation.

<SECTION><TITLE>Fault states for language entities</TITLE>

<P>This section explains the possible fault states
of each language entity in terms of its distributed semantics.
The fault state is
a consequence of two things:
the entity's distributed implementation and
the system's failure mode.
For example, let's consider a variable.
There is one owner site and a set of proxy sites.
If a variable proxy is
on a crashed site and the owner site
is still working,
then to another variable proxy this
will be a <<remoteProblem>>.
If the owner site crashes, then
all proxies will see a <<permFail>>.

<SUBSECTION><TITLE>Eager stateless data</TITLE>

<P>Eager stateless data, namely records, procedures,
functions, classes, and functors, are
copied immediately in messages.
There are no remote references to eager
stateless data, which are always local to a site.
So their only possible fault state is <<ok>>.

<P>In future releases, procedures, functions, and functors
will not send their code immediately in the message,
but will send only their global name.
Upon arrival, if the code is not present,
then it will be immediately requested.
This will guarantee that code is sent at most
once to a given site.
This will introduce fault states <<tempFail>> and <<permFail>>
if the site containing the code
becomes unreachable or crashes.


<SUBSECTION><TITLE>Sited entities</TITLE>

<P>Sited entities can be referenced remotely
but can only be used on their home site.
Attempting to use one outside of its home
site immediately raises an exception.
Detecting this does not need any network operations.
So their only possible fault state is <<ok>>.

<SUBSECTION><TITLE>Ports</TITLE>

<P>A port has one owner site
and a set of proxy sites.
The following failure modes are possible:
<LIST>
<ITEM> Normal operation (<<ok>>).
<ITEM> Owner site down (<<permFail>>).
<ITEM> Owner site unreachable (<<tempFail>>).
</LIST>
<P>A port has a single operation, <<Send>>,
which can complete if the fault state is <<ok>>.
The <<Send>> operation is asynchronous,
that is, it completes immediately on the
sender site and at some later point in time
it will complete on the port's owner site.
The fact that it completes on the sender site
does not imply that it will complete on the owner site.
This is because the owner site may fail.

<P>We will see later how to build a <<SafeSend>> abstraction
that only completes on the sender site if it completes
on the owner site.

<SUBSECTION><TITLE>Logic variables</TITLE>

<P>A logic variable has one owner site
and a set of proxy sites.
The following failure modes are possible:
<LIST>
<ITEM> Normal operation (<<ok>>).
<ITEM> Owner site down (<<permFail>>).
<ITEM> Owner site unreachable (<<tempFail>>).
<ITEM> Some or all proxy sites down
(<<remoteProblem(I)>> where <<I>> is <<permSome>> or <<permAll>>).
<ITEM> Some or all proxy sites unreachable
(<<remoteProblem(I))>> where <<I>> is <<tempSome>> or <<tempAll>>).
</LIST>
<P> A logic variable has two operations,
binding and waiting until bound.
Bind operations are explicit in the program text.
Most wait operations are implicit:
threads block until their data is available.
The bind operation will only complete if the
fault state is <<ok>> or <<remoteProblem>>.

<P>If the application binds a variable,
then its wait operation is only sure to complete if the
fault state is <<ok>>.
When it completes, this means
that another proxy has bound the variable.
If the fault state is <<remoteProblem>>,
then the wait operation may not be able
to complete if the problem exists 
at the proxy that should bind the variable.
Therefore, it is important to detect the
fault state <<remoteProblem>>.

<P>A common case for variables is the client-server.
The client sends a request containing a variable to the server.
The server binds the variable to the answer.
The variable exists only on the client and server sites.
In this case, if the client detects a <<remoteProblem>>
then it knows that the variable binding will be delayed.

<SUBSECTION><TITLE>Cells and locks</TITLE>

<P>Cells and locks have almost the same failure behavior.
A cell or lock has one owner site and a set of proxy sites.
At any given time instant,
the cell's state pointer or the lock's token
is at one proxy or in the network.
The following failure modes are possible:
<LIST>
<ITEM> Normal operation (<<ok>>).
<ITEM> Owner site down and state pointer not present
(<<permFail(info:owner)>>).
<ITEM> Owner site unreachable and state pointer not present
(<<tempFail(info:owner)>>).
<ITEM> State pointer lost (owner site up)
(<<permFail(info:state)>>).
This failure mode is only for cells.
If a lock token is lost then the owner recreates it.
<ITEM> State pointer unreachable (owner site up)
(<<tempFail(info:state)>>).
<ITEM> State pointer present and owner site down
(<<remoteProblem(permAll)>>).
<ITEM> State pointer present and owner site unreachable
(<<remoteProblem(tempAll)>>).
</LIST>
<P>Objects and cells have one primitive operation,
namely a state update.
For a cell this operation is called <<Exchange>>.

<SUBSECTION><TITLE>Objects</TITLE>

<P>An object consists of
an object-record that is a lazy chunk
and that references
the object's features, a cell, and a class.
The object-record is lazy: it is copied to the site
when the object is used for the first time.
This means that
the following failure modes are possible:
<LIST>
<ITEM> Normal operation (<<ok>>).
<ITEM> Owner site down and
object-record or state pointer not present
(<<permFail(info:owner)>>).
<ITEM> Owner site unreachable and
object-record or state pointer not present
(<<tempFail(info:owner)>>).
<ITEM> State pointer lost (owner site up)
(<<permFail(info:state)>>).
<ITEM> State pointer unreachable (owner site up)
(<<tempFail(info:state)>>).
<ITEM> Object-record and state pointer present and owner site down
(<<remoteProblem(permAll)>>).
<ITEM> Object-record and state pointer present and owner site unreachable
(<<remoteProblem(tempAll)>>).
</LIST>
Compared to cells,
objects have two new failure modes:
the object-record can be temporarily or permanently absent.
In both cases the object
cannot be used, so we simply consider the new failure modes
to be instances of <<tempFail>> and <<permFail>>.

<section><title/Limitations and modifications/
 
<P>The current release has the following limitations
and modifications with respect to the specification.
A <EM>limitation</EM> is an operation that is specified
but not possible in the current release.
A <EM>modification</EM> is an operation that is specified
but behaves differently in the current release.
The limitations are:
<list>
<item>The code of functions, procedures, classes, and functors
(but not objects) is always inserted in messages,
even this code is already present at the destination.
In future releases, these entities will be copied
across the network only
if they are not present on the destination site.
In both current and future releases, at most a single copy
of these entities can exist per site.
<item>The fault state <<tempFail>> is indicated only after
a long delay.
<item>If an exception is raised or a handler or watcher
is invoked for an <EM>object</EM>,
then the <<Entity>> argument is undefined.
For handlers and watchers, this limitation can
be circumvented by letting the handler or watcher
reference the object.
<item>If an exception is raised or a handler is invoked
for an <EM>object</EM>,
then the attempted object operation cannot be retried.
<item>A handler cannot be installed at the <<global>> level,
i.e., the call <<{Fault.install _ global _ _}>> is undefined.
If an attempt is made to install a <<global>> handler,
then a <<notImplemented>> exception is given.
</list>
<P>The modifications are:
<list>
<item>A handler installed on a <EM>variable</EM> will retry
the operation (i.e., bind or wait) after it returns.
That is, the handler is inserted before the operation
instead of replacing the operation.
</list>
<P>These limitations and modifications
will be removed in future releases.

</CHAPTER>

