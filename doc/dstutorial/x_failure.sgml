<CHAPTER ID="chapter.failure">
  <TITLE>Handling failure</TITLE>

<P> This chapter first introduces the Mozart failure model:
what we assume can go wrong with the system
and how this is reflected in the language entities.
We then show how to program with this model.
We first present
basic fault-tolerant versions of
the common language operations.
Then we present
fault-tolerant versions of the server examples.
Finally
we summarize the basic fault-detection
and handling primitives of the language.
These primitives are used to build
the fault-tolerant abstractions.

<SECTION><TITLE>Failure model</TITLE>

<P> The failure model is designed to cover the
vast majority of failures occurring in the system
that are due to distribution.
This consists of
permanent site failures that are instantaneous (fail-stop)
and both temporary and permanent communication failures.
This failure model is reflected in each language entity.
The system provides mechanisms to be informed of failures
and to program with language entities that are subject
to failures.

<P> All failure modes are defined with respect to
a given language entity on a given site.
For example, one would like to send a message
to a port from a given site.
In general,
there are four situations that can occur
relative to a language entity on a given site:
<LIST>
<ITEM> The entity works normally (fault state <<ok>>).
<ITEM> The entity is temporarily not working
(fault state <<tempFail>>).
This is because a site crucial to the entity
is unreachable due to a network problem.
This fault state can go away.
The network layer actively tries
to reestablish another connection.
<ITEM> The entity is permanently not working
(fault state <<permFail>>).
This is because a site crucial to the entity
has crashed.
This fault state is permanent.
<ITEM> The entity works normally on the given site
(fault state <<remoteProblem>>),
but there are some remote problems that might
have a bearing on the application's use of the entity.
For example, a given site waits for a variable binding,
but the site that will do the binding has crashed.
This fault state can go away if the
remote problems are temporary.
</LIST>
<P> An entity on a site therefore has four
basic fault states.
We now explain how these fault states occur
in terms of the possible system failures
for each language entity.
Each language entity has a different
distributed protocol, and therefore the
fault states occur in different ways.
In the case of <<tempFail>> and <<permFail>>,
operations on the entity will not complete.
In the case of <<remoteProblem>>, operations
will complete and it is usually
possible to find out something about what the
problem is, depending on the type of the entity.

<P> A fault state <<F>> different from <<ok>> will
cause the distribution exception <<system(dp(F))>>
to be raised when an operation is attempted on the entity.

<P> The fault state <<tempFail>> exists to allow the
application to react quickly to temporary network problems.
It is raised by the system as soon as a network problem
is recognized.
It is therefore fundamentally different from a time-out.
For example, TCP gives a time-out after some minutes.
This duration has been chosen to be very long,
approximating infinity from the viewpoint of the
network connection.
After the time-out,
one can be sure that the connection is no longer working.
The purpose of <<tempFail>> is quite different:
it is to <EM>inform</EM> the application
of network problems, not to mark the <EM>end</EM> of a connection.
For example, an application might be connected to a given server.
If there are problems with this server, the application
would like to be informed quickly so that it can try connecting
to another server.
The <<tempFail>> exceptions will therefore be relatively frequent,
much more frequent than time-outs.

<P> It is possible for
a temporary network error to be effectively permanent.
In general, the distinction between the two cannot be made from inside
the application.
For example, if a user disconnects the network connection of a laptop
machine, then only he or she knows whether the problem is permanent.
The decision whether to continue waiting on a temporary error
or whether to interrupt the wait can cut through all levels of
abstraction to appear at the top level.
The application then pops up a window to ask the user whether
to continue waiting or not.

<SUBSECTION><TITLE>Eager stateless data</TITLE>

<P> Eager stateless data, namely records, procedures,
functions, and functors, are
copied immediately in messages.
There are no remote references to eager
stateless data, which are always local to a site.
So their only possible fault state is <<ok>>.

<P> In future releases, procedures, functions, and functors
will not send their code immediately in the message,
but will send only their global name.
Upon arrival, if the code is not present,
then it will be immediately requested.
This will guarantee that code is sent at most
once to a given site.
This will introduce fault states <<tempFail>> and <<permFail>>
if the site containing the code
becomes unreachable or crashes.


<SUBSECTION><TITLE>Sited entities</TITLE>

<P> Sited entities can be referenced remotely
but can only be used on their home site.
Attempting to use one outside of its home
site immediately raises an exception.
Detecting this does not need any network operations.
So their only possible fault state is <<ok>>.

<SUBSECTION><TITLE>Ports</TITLE>

<P> A port has one owner site
and a set of proxy sites.
The following failure modes are possible:
<LIST>
<ITEM> Normal operation (<<ok>>).
<ITEM> Owner site down (<<permFail(type:port)>>).
<ITEM> Owner site unreachable (<<tempFail(type:port)>>).
</LIST>
<P> A port has a single operation, <<Send>>,
which can complete if the fault state is <<ok>>.
The <<Send>> operation is asynchronous,
that is, it completes immediately on the
sender site and at some later point in time
it will complete on the port's owner site.
The fact that it completes on the sender site
does not imply that it will complete on the owner site.
This is because the owner site may fail.

<P> We will see later how to build a <<SafeSend>> abstraction
that only completes on the sender site if it completes
on the owner site.

<SUBSECTION><TITLE>Logic variables</TITLE>

<P> A logic variable has one owner site
and a set of proxy sites.
The following failure modes are possible:
<LIST>
<ITEM> Normal operation (<<ok>>).
<ITEM> Owner site down (<<permFail(type:variable)>>).
<ITEM> Owner site unreachable (<<tempFail(type:variable)>>).
<ITEM> Some proxy sites down
(<<remoteProblem(type:variable permFail:SiteList)>>).
<ITEM> Some proxy sites unreachable
(<<remoteProblem(type:variable tempFail:SiteList)>>).
</LIST>
<P> (The <<SiteList>> lists the site identifiers
of the problem sites.)
A logic variable has two operations,
binding and waiting until bound.
Bind operations are explicit in the program text.
Most wait operations are implicit:
threads block until their data is available.
The bind operation will only complete if the
fault state is <<ok>> or <<remoteProblem>>.

<P> The wait operation will only complete if the
fault state is <<ok>>.
When it completes, this means
that another proxy has bound the variable.
If the fault state is <<remoteProblem>>,
then the wait operation may not be able
to complete if the problem exists
at the proxy that should bind the variable.
Therefore, it is important to detect the
fault state <<remoteProblem>>.

<P> A common case for variables is the client-server.
The client sends a request containing a variable to the server.
The server binds the variable to the answer.
The variable exists only on the client and server sites.
In this case, if the client detects a <<remoteProblem>>
then it knows that the variable binding will be delayed.

<SUBSECTION><TITLE>Objects and cells</TITLE>

<P> Objects and cells have the same failure behavior.
An object has one owner site and a set of proxy sites.
At any given time instant,
the object's state pointer is at one proxy
or in the network.
The following failure modes are possible:
<LIST>
<ITEM> Normal operation (<<ok>>).
<ITEM> Owner site down and state pointer not present
(<<permFail(type:CO info:owner)>>).
<ITEM> Owner site unreachable and state pointer not present
(<<tempFail(type:CO info:owner)>>).
<ITEM> State pointer lost (owner site up)
(<<permFail(type:CO info:state)>>).
<ITEM> State pointer unreachable (owner site up)
(<<tempFail(type:CO info:state)>>).
</LIST>
<P> (The <<CO>> is <<cell>> or <<object>>.)
Objects and cells have one primitive operation,
namely a state update.
For a cell this operation is called <<Exchange>>.
The exchange operation can complete if the
fault state is <<ok>>.

<SECTION><TITLE>Fault-tolerant examples</TITLE>

<SUBSECTION><TITLE>A fault-tolerant hello server</TITLE>

<P> Let's take a fresh look at the hello server.
How can we make it resistant to distribution faults?
First we specify the client and server behavior.
The server should
continue working even though there is a
problem with a particular client.
The client should
be informed in finite time of a server problem
by means of a new exception, <<server_error>>.

<P> The system raises exceptions
when it tries to do operations
on entities that have problems.
All distributed exceptions are of the
form <<system(dp(C))>> where <<C>> is any fault state
as defined before except <<ok>>.

<P> Assume that we have two new abstractions.
<<{SafeSend Prt X}>> sends to a port
and raises the exception <<server_error>>
if this is permanently impossible.
<<{SafeWait X}>> waits until <<X>> is
instantiated and raises the exception
<<server_error>> if this is permanently impossible.
We first show how to use these abstractions
before defining them in our failure model.

<P> With <<SafeSend>> and <<SafeWait>>, we can
write the client and the server almost exactly
as before.
Let's first write the server:
<<<
declare Str Prt Srv in
{NewPort Str Prt}
thread
   {ForAll Str
    proc {$ S}
       try
          S="Hello world"
       catch system(dp(C)) then skip end
    end}
end

proc {Srv X}
   {SafeSend Prt X}
end

{Pickle.save
 {Connection_many Srv}
 "http://www.sics.se/~pvr/hw"}
>>>

<P> This server does one distributed operation,
namely the binding <<S="Hello world">>.
We wrap this binding
to catch any distributed exception that occurs.
This allows the server to ignore clients
with problems and to continue working.

<P> Here's the client:
<<<
declare Srv

try X in
   try
      Srv={Connection.take {Pickle.load "http://www.sics.se/~pvr/hw"}}
   catch _ then raise server_error end
   end

   {Srv X}
   {SafeWait X infinity}
   {Browse X}
catch server_error then
   {Browse 'Server down'}
end
>>>

<P> This client does two distributed operations,
namely a send (inside <<Srv>>) which is replaced with <<SafeSend>>
and a wait which is replaced with <<{SafeWait}>>.
If there is a problem sending the
message or receiving the reply,
then the exception <<server_error>> is raised.
Note that we also catch exceptions during the
<<Connection.take>> and the <<Pickle.load>>.

<P> <<SafeSend>> is defined as follows:

<<<
proc {SafeSend Prt X}
   try
      {Send Prt X}
   catch system(dp(C)) then
      case C
      of permFail then
         raise server_error end
      [] tempFail then
         {Delay 100} {SafeSend Prt X}
      else
         skip
      end
   end
end
>>>

<P> This raises a <<server_error>> if there is
a permanent server failure
and retries indefinitely each 100 ms if there
is a temporary failure.

<P> <<SafeWait>> is defined as follows:

<<<
declare
local
   proc {InnerSafeWait X Time}
      try
         {WaitOr X Time}
         if {IsDet Time} then raise server_error end end
      catch system(dp(C)) then
         case C
         of permFail(...) then
            raise server_error end
         [] remoteProblem(permFail:_ ...) then
            raise server_error end
         [] tempFail(...) then
            {Delay 100} {InnerSafeWait X Time}
         [] remoteProblem(tempFail:_ ...) then
            {Delay 100} {InnerSafeWait X Time}
         else
            skip
         end
      end
   end
in
   proc {SafeWait X TimeOut}
   Time in
      if TimeOut\=infinity then
         thread {Delay TimeOut} Time=done end
      end
      {InnerSafeWait X Time}
   end
end
>>>

<P> This raises a <<server_error>> if there is
a permanent server failure
and retries each 100 ms if there is a
temporary failure.
The client and the server
are the only two sites on which <<X>> exists.
Therefore <<remoteProblem(permFail:_)>> means
that the server has crashed.

<P> To keep the client from blocking
indefinitely, it must time out.
We need a time-out since otherwise a client
will be stuck when the server drops it like a hot potato.
The time-out is an argument to <<SafeWait>>.

<SUBSECTION><TITLE>Making fault-tolerant stationary objects</TITLE>

<P> To be useful in practice,
stationary objects must have well-defined behavior when
there are faults.

<P> We propose the following specification:
<LIST>
<ITEM> The call <<C={NewSafeStat Class Init}>>
creates a new stationary object <<C>>.
<ITEM> The call <<{C Msg}>> can raise
the additional distribution exceptions
<<permFail>> and <<tempFail>>,
in addition to the exceptions raised in the object.
<ITEM> The call <<{C Msg T}>> adds a time-out <<T>> (in ms).
If there is no result after this time,
then the distribution exception <<timeOut>> is raised.
</LIST>

</CHAPTER>
