<CHAPTER ID="chapter.failure">
  <TITLE>Handling failure</TITLE>

<P> This chapter first introduces the Mozart failure model:
what we assume can go wrong with the system
and how this is reflected in the language entities.
We then show how to program with this model.
We first present
basic fault-tolerant versions of 
the common language operations.
Then we present
fault-tolerant versions of the server examples.
Finally
we summarize the basic fault-detection
and handling primitives of the language.
These primitives are used to build
the fault-tolerant abstractions.

<SECTION><TITLE>Failure model</TITLE>

<P> The failure model is designed to cover the
vast majority of failures occurring in the system
that are due to distribution.
This consists of
permanent site failures that are instantaneous (fail-stop)
and both temporary and permanent communication failures.
This failure model is reflected in each language entity.
The system provides mechanisms to be informed of failures
and to program with language entities that are subject
to failures.

<P> All failure modes are defined with respect to
a given language entity on a given site.
For example, one would like to send a message
to a port from a given site.
In general,
there are four situations that can occur
relative to a language entity on a given site:
<LIST>
<ITEM> The entity works normally (fault state <<ok>>).
<ITEM> The entity is temporarily not working
(fault state <<tempFail>>).
This is because a site crucial to the entity
is unreachable due to a network problem.
This fault state can go away.
The network layer actively tries
to reestablish another connection.
<ITEM> The entity is permanently not working
(fault state <<permFail>>).
This is because a site crucial to the entity
has crashed.
This fault state is permanent.
<ITEM> The entity works normally on the given site
(fault state <<remoteProblem>>),
but there are some remote problems that might
have a bearing on the application's use of the entity.
For example, a given site waits for a variable binding,
but the site that will do the binding has crashed.
This fault state can go away if the
remote problems are temporary.
</LIST>
<P> An entity on a site therefore has four
basic fault states.
In the next sections
we explain how these fault states occur
in terms of the possible system failures
for each language entity.
Each language entity has a different
distributed protocol, and therefore the
fault states occur in different ways.
In the case of <<tempFail>> and <<permFail>>,
operations on the entity will not complete.
In the case of <<remoteProblem>>, operations
will complete and it is usually
possible to find out something about what the
problem is, depending on the type of the entity.

<P> A fault state <<F>> different from <<ok>> will
cause the distribution exception <<system(dp(F) ...)>>
to be raised when an operation is attempted on the entity.
In most cases the fault state contains more
information than just <<permFail>>, <<tempFail>>,
<<remoteProblem>>.
This is denoted by making these fault states
the labels of <EM>records</EM> that give
the full information, e.g.,
<<permFail(type:cell info:owner)>>
and
<<remoteProblem(type:variable permFail:[S1,S2])>>.
The exception handler can do
pattern matching on just a part of this
information using the <<...>> notation, e.g.,
<<permFail(...)>>
and
<<remoteProblem(permFail:_ ...)>>.


<SUBSECTION><TITLE>Temporary fault states</TITLE>

<P> The fault state <<tempFail>> exists to allow the
application to react quickly to temporary network problems.
It is raised by the system as soon as a network problem
is recognized.
It is therefore fundamentally different from a time-out.
For example, TCP gives a time-out after some minutes.
This duration has been chosen to be very long,
approximating infinity from the viewpoint of the
network connection.
After the time-out,
one can be sure that the connection is no longer working.

<P> The purpose of <<tempFail>> is quite different from
a time-out:
it is to <EM>inform</EM> the application
of network problems, not to mark the <EM>end</EM> of a connection.
For example, an application might be connected to a given server.
If there are problems with this server, the application
would like to be informed quickly so that it can try connecting
to another server.
The <<tempFail>> exceptions will therefore be relatively frequent,
much more frequent than time-outs.

<P> It is possible for
a temporary network failure to be effectively permanent.
In general, the distinction between the two cannot be made from inside
the application.
For example, if a user disconnects the network connection of a laptop
machine, then only he or she knows whether the problem is permanent.
The decision whether to continue waiting on a temporary failure
or whether to interrupt the wait can cut through all levels of
abstraction to appear at the top level.
The application then pops up a window to ask the user whether
to continue waiting or not.

<SUBSECTION><TITLE>Eager stateless data</TITLE>

<P> Eager stateless data, namely records, procedures,
functions, and functors, are
copied immediately in messages.
There are no remote references to eager
stateless data, which are always local to a site.
So their only possible fault state is <<ok>>.

<P> In future releases, procedures, functions, and functors
will not send their code immediately in the message,
but will send only their global name.
Upon arrival, if the code is not present,
then it will be immediately requested.
This will guarantee that code is sent at most
once to a given site.
This will introduce fault states <<tempFail>> and <<permFail>>
if the site containing the code
becomes unreachable or crashes.


<SUBSECTION><TITLE>Sited entities</TITLE>

<P> Sited entities can be referenced remotely
but can only be used on their home site.
Attempting to use one outside of its home
site immediately raises an exception.
Detecting this does not need any network operations.
So their only possible fault state is <<ok>>.

<SUBSECTION><TITLE>Ports</TITLE>

<P> A port has one owner site
and a set of proxy sites.
The following failure modes are possible:
<LIST>
<ITEM> Normal operation (<<ok>>).
<ITEM> Owner site down (<<permFail(type:port)>>).
<ITEM> Owner site unreachable (<<tempFail(type:port)>>).
</LIST>
<P> A port has a single operation, <<Send>>,
which can complete if the fault state is <<ok>>.
The <<Send>> operation is asynchronous,
that is, it completes immediately on the
sender site and at some later point in time
it will complete on the port's owner site.
The fact that it completes on the sender site
does not imply that it will complete on the owner site.
This is because the owner site may fail.

<P> We will see later how to build a <<SafeSend>> abstraction
that only completes on the sender site if it completes
on the owner site.

<SUBSECTION><TITLE>Logic variables</TITLE>

<P> A logic variable has one owner site
and a set of proxy sites.
The following failure modes are possible:
<LIST>
<ITEM> Normal operation (<<ok>>).
<ITEM> Owner site down (<<permFail(type:variable)>>).
<ITEM> Owner site unreachable (<<tempFail(type:variable)>>).
<ITEM> Some proxy sites down
(<<remoteProblem(type:variable permFail:SiteList)>>).
<ITEM> Some proxy sites unreachable
(<<remoteProblem(type:variable tempFail:SiteList)>>).
</LIST>
<P> (The <<SiteList>> lists the site identifiers
of the problem sites.)
A logic variable has two operations,
binding and waiting until bound.
Bind operations are explicit in the program text.
Most wait operations are implicit:
threads block until their data is available.
The bind operation will only complete if the
fault state is <<ok>> or <<remoteProblem>>.

<P> The wait operation will only complete if the
fault state is <<ok>>.
When it completes, this means
that another proxy has bound the variable.
If the fault state is <<remoteProblem>>,
then the wait operation may not be able
to complete if the problem exists 
at the proxy that should bind the variable.
Therefore, it is important to detect the
fault state <<remoteProblem>>.

<P> A common case for variables is the client-server.
The client sends a request containing a variable to the server.
The server binds the variable to the answer.
The variable exists only on the client and server sites.
In this case, if the client detects a <<remoteProblem>>
then it knows that the variable binding will be delayed.

<SUBSECTION><TITLE>Cells and locks</TITLE>

<P> Cells and locks have almost the same failure behavior.
A cell or lock has one owner site and a set of proxy sites.
At any given time instant,
the cell's state pointer or the lock's token
is at one proxy or in the network.
The following failure modes are possible:
<LIST>
<ITEM> Normal operation (<<ok>>).
<ITEM> Owner site down and state pointer not present
(<<permFail(type:CL info:owner)>>).
<ITEM> Owner site unreachable and state pointer not present
(<<tempFail(type:CL info:owner)>>).
<ITEM> State pointer lost (owner site up)
(<<permFail(type:CL info:state)>>).
This failure mode is only for cells.
If a lock token is lost then the owner recreates it.
<ITEM> State pointer unreachable (owner site up)
(<<tempFail(type:CL info:state)>>).
</LIST>
<P> (The <<CL>> is <<cell>> or <<lock>>.)
Objects and cells have one primitive operation,
namely a state update.
For a cell this operation is called <<Exchange>>.
The exchange operation can complete if the
fault state is <<ok>>.

<SUBSECTION><TITLE>Objects</TITLE>

<P> An object consists of
an object-record that is a lazy chunk
and that references
the object's features, a cell, a class.
The object-record and the class are
copied when requested.
This means that
the following failure modes are possible:
<LIST>
<ITEM> Normal operation (<<ok>>).
<ITEM> Owner site down and
object-record or state pointer not present
(<<permFail(type:object info:owner)>>).
<ITEM> Owner site unreachable and
object-record or state pointer not present
(<<tempFail(type:object info:owner)>>).
<ITEM> State pointer lost (owner site up)
(<<permFail(type:object info:state)>>).
<ITEM> State pointer unreachable (owner site up)
(<<tempFail(type:object info:state)>>).
</LIST>
There are two new failure modes that
occur because the object-record can be absent.
Since in both cases the object
cannot be used, we simply consider the new failure modes
to be instances of <<permFail>> and <<tempFail>>.

<SECTION><TITLE>Fault-tolerant examples</TITLE>

<SUBSECTION><TITLE>A fault-tolerant hello server</TITLE>

<P> Let's take a fresh look at the hello server.
How can we make it resistant to distribution faults?
First we specify the client and server behavior.
The server should
continue working even though there is a 
problem with a particular client.
The client should
be informed in finite time of a server problem
by means of a new exception, <<serverError>>.

<P> The system raises exceptions
when it tries to do operations
on entities that have problems.
All distributed exceptions are of the
form <<system(dp(C) ...)>> where <<C>> is any fault state
as defined before except <<ok>>.

<P> Assume that we have two new abstractions.
<<{SafeSend Prt X}>> sends to a port
and raises the exception <<serverError>>
if this is permanently impossible.
<<{SafeWait X T}>> waits until <<X>> is
instantiated, raises the exception
<<serverError>> if this is permanently impossible
or if the time <<T>> is exceeded.
We first show how to use these abstractions
before defining them in our failure model.

<P> With <<SafeSend>> and <<SafeWait>>, we can
write the client and the server almost exactly
as before.
Let's first write the server:
<<<
declare Str Prt Srv in 
{NewPort Str Prt}
thread  
   {ForAll Str
    proc {$ S}
       try
          S="Hello world"
       catch system(dp(C) ...) then skip end
    end}
end

proc {Srv X}
   {SafeSend Prt X}
end
                                        
{Pickle.save  
 {Connection_many Srv}
 "http://www.sics.se/~pvr/hw"}
>>>

<P> This server does one distributed operation,
namely the binding <<S="Hello world">>.
We wrap this binding
to catch any distributed exception that occurs.
This allows the server to ignore clients
with problems and to continue working.

<P> Here's the client:
<<<
declare Srv

try X in
   try
      Srv={Connection.take {Pickle.load "http://www.sics.se/~pvr/hw"}}
   catch _ then raise serverError end
   end
   
   {Srv X}
   {SafeWait X infinity}
   {Browse X}
catch serverError then
   {Browse 'Server down'}
end
>>>

<P> This client does two distributed operations,
namely a send (inside <<Srv>>), which is replaced by <<SafeSend>>,
and a wait, which is replaced by <<SafeWait>>.
If there is a problem sending the
message or receiving the reply,
then the exception <<serverError>> is raised.
Note that we also catch exceptions during the
<<Connection.take>> and the <<Pickle.load>>.

<P> <<SafeSend>> is defined as follows:

<<<
proc {SafeSend Prt X}
   try
      {Send Prt X}
   catch system(dp(C) ...) then
      case C
      of permFail(...) then
         raise serverError end
      [] tempFail(...) then
         {Delay 100} {SafeSend Prt X}
      else
         skip
      end
   end
end
>>>

<P> This raises a <<serverError>> if there is
a permanent server failure
and retries indefinitely each 100 ms if there
is a temporary failure.

<P> <<SafeWait>> is defined as follows:

<<<
declare
local
   proc {InnerSafeWait X Time}
      try
         {WaitOr X Time}
         if {IsDet Time} then raise serverError end end
      catch system(dp(C) ...) then
         case C
         of permFail(...) then
            raise serverError end
         [] remoteProblem(permFail:_ ...) then
            raise serverError end
         [] tempFail(...) then
            {Delay 100} {InnerSafeWait X Time}
         [] remoteProblem(tempFail:_ ...) then
            {Delay 100} {InnerSafeWait X Time}
         else
            skip
         end
      end
   end
in
   proc {SafeWait X TimeOut}
   Time in
      if TimeOut\=infinity then
         thread {Delay TimeOut} Time=done end
      end
      {InnerSafeWait X Time}
   end
end
>>>

<P> This raises a <<serverError>> if there is
a permanent server failure
and retries each 100 ms if there is a
temporary failure.
The client and the server
are the only two sites on which <<X>> exists.
Therefore <<remoteProblem(permFail:_ ...)>> means
that the server has crashed.

<P> To keep the client from blocking 
indefinitely, it must time out.
We need a time-out since otherwise a client
will be stuck when the server drops it like a hot potato.
The time-out is an argument to <<SafeWait>>.

<SUBSECTION><TITLE>Making fault-tolerant stationary objects</TITLE>

<P> To be useful in practice, 
stationary objects must have well-defined behavior when
there are faults.
We propose the following specification for the 
stationary object (the "server")
and a caller (the "client"):
<LIST>
<ITEM> The call <<C={NewSafeStat Class Init}>>
creates a new server <<C>>.
<ITEM> If there is no problem in the distributed execution
then the call <<{C Msg}>> has identical language semantics
to a centralized execution of the object,
including raising the same exceptions.
<ITEM> If there is a problem in the distributed execution preventing
its successful completion, then the call <<{C Msg}>> will raise
the exception <<remoteObjectError>>.
<ITEM> If there is a problem communicating with the client,
then the server tries repeatedly during a short period to communicate
with the client and then gives up.
This does not affect the continued execution of the server.
</LIST>

<P> We present the implementation of <<NewStat>>.
First <<New>> makes
an instance of the object
and then <<MakeStat>> makes it stationary.
In <<MakeStat>>, we distinguish four parts.
The first two implement the client interface
to the server.

<chunk><title/Making stationary objects/
declare
proc {NewStat Class Init Object}
   Object={MakeStat {New Class Init}}
end

declare
proc {MakeStat PO ?StatP}
   S P={NewPort S}
   N={NewName}
   EndLoop TryToBind
in
   % Client interface to server:
   <chunk.ref/Client call to the server/
   <chunk.ref/Client synchronizes with the server/
   % Server implementation:
   <chunk.ref/Main server loop/
   <chunk.ref/Server synchronizes with the client/
end
</chunk>

<P> First the client sends its message to the
server together with a synchronizing variable.
This variable is used to signal
to the client that the server has
finished the object call.
The variable passes an exception
back to the client if there was one.
<P> If there is a permanent failure of
the send, then raise <<remoteObjectError>>.
If there is a temporary failure of the
send, then wait 100 ms and try again.
<chunk><title/Client call to the server/
   proc {StatP M}
      R in
      try
         {Send P M#R}
      catch system(dp(C)) then
         case C
         of permFail(...) then
            raise remoteObjectError end
         [] tempFail(...) then
            {Delay 100}
            {StatP M}
         else skip end
      end
      {EndLoop R}
   end
</chunk>

<P> Then the client waits for the server
to bind the synchronizing variable.
If there is a permanent failure, then
raise the exception.
If there is a temporary failure, then
wait 100 ms and try again.
<chunk><title/Client synchronizes with the server/
   proc {EndLoop R}
      try
         if R==N then skip else raise R end end
      catch system(dp(C)) then
         case C
         of permFail(...) then
            raise remoteObjectError end
         [] remoteProblem(permFail:_ ...) then
            raise remoteObjectError end
         [] tempFail(...) then
            {Delay 100} {EndLoop R}
         [] remoteProblem(tempFail:_ ...) then
            {Delay 100} {EndLoop R}
         else skip end
      end
   end
</chunk>

<P> The following two parts implement the server.
The server runs in its own thread and
creates a new thread for each client call.
The server is less tenacious on
temporary failures than the client:
it tries once every 2000 ms and gives
up after 10 tries.
<chunk><title/Main server loop/
   thread
      {ForAll S
       proc {$ M#R}
          thread
             try
                {PO M}
                {TryToBind 10 R N}
             catch X then
                try
                   {TryToBind 10 R X}
                catch Y then skip end
             end
          end
       end}
   end
</chunk>

<chunk><title/Server synchronizes with the client/
   proc {TryToBind Count R N}
      if Count==0 then skip
      else
         try
            R=N
         catch system(dp(tempFail(...))) then
            {Delay 2000}
            {TryToBind Count-1 R N}
         end
      end
   end
</chunk>


</CHAPTER>

