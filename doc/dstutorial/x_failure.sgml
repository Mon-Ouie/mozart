<CHAPTER ID="chapter.failure">
  <TITLE>Handling failure</TITLE>

<P> This chapter first introduces the Mozart failure model:
what we assume can go wrong with the system
and how this is reflected in the language entities.
We then show how to program with this model.
We first present
basic fault-tolerant versions of 
the common language operations.
Then we present
fault-tolerant versions of the server examples.
Finally
we summarize the basic fault-detection
and handling primitives of the language.
These primitives are used to build
the fault-tolerant abstractions.

<SECTION><TITLE>Failure model</TITLE>

<P> The failure model is designed to cover the
vast majority of failures occurring in distributed systems,
namely instantaneous, permanent site failures (fail-stop)
and both temporary and permanent communication failures.
This failure model is reflected in each language entity.
The system provides mechanisms to be informed of failures
and to program with language entities that are subject
to failures.

<P> All failure modes are defined with respect to
a given language entity on a given site.
For example, one would like to send a message
to a port from a given site.
In general,
there are four situations that can occur
relative to a language entity on a given site:
<LIST>
<ITEM> The entity works normally (fault state <<ok>>).
<ITEM> The entity is temporarily not working
(fault state <<tempBlock>>).
This is because a site crucial to the entity's operation
is unreachable due to a network problem.
This fault state can go away.
The network layer actively tries
to reestablish another connection.
<ITEM> The entity is permanently not working
(fault state <<permBlock>>).
This is because a site crucial to the entity's operation
has crashed.
This fault state is permanent.
<ITEM> The entity works normally on the given site
(fault state <<remoteProblem>>),
but there are some remote problems that might
have a bearing on the application's use of the entity.
For example, one is waiting for a variable
binding on a given site,
but the site that will bind the value has crashed.
This fault state can go away if the
remote problems are temporary.
</LIST>
<P> An entity on a site therefore has four
possible basic fault states.
We now explain how these fault states occur
in terms of the possible system failures.
Each language entity has a different
distributed protocol, and therefore the
fault states occur in different ways.
In the case of <<remoteProblem>>, it is usually
possible to find out something about what the
problem is, depending on the type of the entity.

<SUBSECTION><TITLE>Eager stateless data</TITLE>

<P> Eager stateless data are
copied immediately in messages.
There are therefore no remote references to eager
stateless data, which are
always local to a site.
Therefore no special failure handling is needed for them.
Their only possible fault state is <<ok>>.

<P> In future releases, procedures, functions, classes, and functors
will not send their code immediately in the message,
but will send only their global name.
Upon arrival, if the code is not present,
then it will be immediately requested.
This will guarantee that code is sent at most
once to a given site.
This will introduce fault states <<tempBlock>> and <<permBlock>>
if the site containing the code
becomes unreachable or crashes.


<SUBSECTION><TITLE>Sited entities</TITLE>

<P> Sited entities can be referenced remotely
but can only be used on their home site.
Attempting to use one outside of its home
site immediately raises an exception,
without any network operations.
Therefore no special failure handling is needed for them.
Their only possible fault state is <<ok>>.

<SUBSECTION><TITLE>Ports</TITLE>

<P> A port has one owner site
and a set of proxy sites.
The following failure modes are possible:
<LIST>
<ITEM> Normal operation (<<ok>>).
<ITEM> Owner site down (<<permBlock>>).
<ITEM> Owner site unreachable (<<tempBlock>>).
</LIST>
A port has a single operation, <<Send>>,
which can complete if the fault state is <<ok>>.

<SUBSECTION><TITLE>Logic variables</TITLE>

<P> A logic variable has one owner site
and a set of proxy sites.
The following failure modes are possible:
<LIST>
<ITEM> Normal operation (<<ok>>).
<ITEM> Owner site down (<<permBlock>>).
<ITEM> Owner site unreachable (<<tempBlock>>).
<ITEM> Some proxy sites down (<<remoteProblem>>).
<ITEM> Some proxy sites unreachable (<<remoteProblem>>).
</LIST>
<P> A logic variable has two operations,
binding and waiting until bound.
The bind operation can complete if the
fault state is <<ok>> or <<remoteProblem>>.

<P> The wait operation completes when another
proxy binds the variable.
The wait operation can complete if the
fault state is <<ok>>.
If the fault state is <<remoteProblem>>,
then the wait operation may not be able
to complete if the problem exists 
at the proxy that should bind the variable.
Therefore, it is important to detect the
fault state <<remoteProblem>>.

<P> A common case for variables is the client-server.
The client sends a request containing a variable to the server.
The server binds the variable to the answer.
The variable exists only on the client and server sites.
In this case, if the client detects a <<remoteProblem>>
then it knows that the variable binding will be delayed.

<SUBSECTION><TITLE>Objects and cells</TITLE>

<P> Objects and cells have the same failure behavior.
An object has one owner site and a set of proxy sites.
At any given time instant,
the object's state pointer is at one proxy
or in the network.
The following failure modes are possible:
<LIST>
<ITEM> Normal operation (<<ok>>).
<ITEM> Owner site down and state pointer not present (<<permBlock>>).
<ITEM> Owner site unreachable and state pointer not present (<<tempBlock>>).
<ITEM> State pointer lost (owner site up) (<<permBlock>>).
<ITEM> State pointer unreachable (owner site up) (<<tempBlock>>).
<ITEM>
</LIST>
<P> Objects and cells have one primitive operation,
namely a state update.
For a cell this operation is called exchange.
The exchange operation can complete if the
fault state is <<ok>>.

<SECTION><TITLE>Basic fault-tolerant operations</TITLE>


</CHAPTER>

