<CHAPTER ID="chapter.basics">
  <TITLE>Basic Operations</TITLE>

<SECTION><TITLE>Distribution model</TITLE>

The distribution model gives well-defined distribution
behaviors to the Oz language entities.
The distribution behaviors are designed to do the
right thing by default in almost all cases.
For example, procedure code is transferred to sites
immediately, so that sites never need ask for
procedure code.
In the other cases, e.g., objects, the developer can
specify what distribution behavior he wants, e.g.,
mobile (cached) objects, stationary objects,
stationary single-threaded objects.

The most critical entities in an application
in terms of network efficiency are the objects.
Objects have a state that is updated in a
globally consistent way.
This can be more or less efficient
in certain cases,
depending on the object's distributed behavior.
Many distribution behaviors are possible for objects.
Here are some of the more useful ones
that the system provides:
<LIST>
<ITEM> <EM>Cached object</EM>:
Objects and cells are cached by default--we also call
this "mobile objects".
A site attempting to execute a method will first fetch the object,
which requires up to three network messages.
After this, no further messages are needed as long
as the object stays on the site.
If many sites use the object, then it will travel
among the sites, giving everyone a fair share of the object use.

<P>The class of a cached object is copied to each
site that calls the object.
This is done lazily, i.e., the class is only
copied when the object is called for the first time.
Once the class is on the site, no further copies are done.

<ITEM> <EM>Stationary object</EM>:
A stationary object remains on the site at which it was created.
Each method invocation uses one message to start the method
and one message to synchronize when the method is finished.
Each method executes in its own thread on the object's site.
Threads in Mozart are extremely efficient, millions can be
created on one machine, so this is reasonable.

<ITEM> <EM>Server (sequential asynchronous object)</EM>:
A server is a stripped-down stationary object.
Each method invocation uses one message only and does not
wait until the method is finished.
All method invocations execute in the same thread,
so the object is executed in a completely sequential way.
</LIST>
Deciding between these three behaviors is done
when the object is created from its class.
A cached object is created with <<New>>,
a stationary object is created with <<NewStat>>,
and a server is created with <<NewServer>>.

The other language entities have the following
distribution behaviors:
<LIST>
<ITEM> <EM>Port</EM>:
A port is an asynchronous many-to-one channel
that respects FIFO for messages sent from within the same thread.
A port is stationary on the site it is created.
The messages are appended to a stream
on the port's site.
Messages from the same thread appear
in the stream in the same order 
in which they were sent in the thread.

<ITEM> <EM>Cell</EM>:
A cell is an updatable pointer to any other entity,
i.e., it is analogous to a standard updatable variable
in imperative languages such as C and Java.
Cells have the same distribution behavior
as cached objects, i.e., updating the pointer
may need up to three network messages,
but once the cell is local, then further
updates do not use the network any more.

<ITEM> <EM>Logic variable</EM>:
A logic variable is a kind of single-assignment variable.
It is more than that because two logic variables can
be bound together even before they are assigned,
and because a variable can be assigned more than
once, if it is always to the same value.
Logic variables are important for two reasons:
<LIST>
<ITEM> They have a more efficient protocol than cells.
Often, variables are just used like placeholders, that is,
they will be assigned only once.
It would be highly inefficient in a distributed system
to create a cell for that case.
<ITEM> They can be used to improve latency tolerance.
A logic variable can be passed in a message
or stored in a data structure
even before it is assigned its value.
When the value is there, then
it is sent to all sites that need it.
</LIST>
When a logic variable is bound,
the value is sent to its owner site
(the site on which it was created),
which then multicasts it to all the
sites that have the variable.
That is, if the variable is on <EM>n</EM> sites,
then a maximum of <EM>n</EM>+1 messages are
used to bind the variable.
When a variable arrives on a site
for the first time, it is immediately
registered with the owner site.
This takes one message.

<ITEM> <EM>Stream</EM>:
A stream is an asynchronous one-to-many communication channel.
In fact,
a stream is just a list whose last element is a logic variable.
If the stream is bound on the owner site,
then the binding is sent asynchronously to all sites that
have the variable.
Messages from the same thread appear
in the stream in the same order 
in which they were sent in the thread.

<P>A port together with a stream implement an
asynchronous many-to-many channel
that respects the order of messages
from the same thread.

</LIST>

Finally, there are the stateless entities.
Stateless entities never
change, i.e., they do not have any internal state.
Their distribution behavior is very efficient:
they are copied across the net in a single message.
The different kinds of stateless entities differ
in when the copy is done (eager or lazy)
and in how many copies of the entity
can exist on a site:
<LIST>

<ITEM> <EM>Records, lists, and numbers</EM>:
these entities are copied eagerly across the network,
in the message that references them.
The same record, list, and number may occur many
times on a site, once per copy
(remember that integers in Mozart
may have any number of digits).
Since these entities are so very basic
and primitive, it would be highly inefficient
to manage remote references to them
and to ensure that they exist only once on a site.
Of course, records and lists may refer
to any other kind of entity,
and the distribution behavior of that
entity depends on its type, not on
the fact of its being inside a record
or a list.

<ITEM> <EM>Procedures, functions, classes, functors,
atoms, and names</EM>:
These entities are copied eagerly across the
network, but can only exist once on a given site.
For example, an object class contains the code
of all the object's methods.
If many objects of a given class
exist on a site, then the class only exists once.

<P>Note that classes are copied eagerly,
whereas objects are lazy.
I.e., if an object is passed to a site,
then the object's class is not copied to
the site until the object is called.
However, if a class is passed to a site,
then it is copied eagerly.

<ITEM> <EM>Chunks</EM>
A chunk is a lazy record.
If a chunk is passed to a site,
then the site initially only
has a reference to the chunk.
The chunk is copied only when a thread
on the site tries to access one of
the chunk's fields.
Chunks exist to make it easy to introduce
laziness into large data structures when needed.

</LIST>

<SECTION><TITLE>Global naming</TITLE>

Global names are needed when an application
wants to interact with the world outside it.
Mozart supports three basic kinds of global names:
<LIST>
<ITEM> A <EM>ticket</EM> is a string that references a data
structure inside a running application.
Tickets are created by Mozart and
can be used to connect running applications together.
<ITEM> A <EM>URL</EM> is a string that references
a file across the network.
The string follows the standard URL syntax.
In Mozart the file can be a <EM>pickle</EM>, in which case
it can hold any kind of stateless data--procedures,
classes, records, strings, etc.
<ITEM> A <EM>hostname</EM> is a string that
refers to a host (another machine) across the network.
The string follows the standard DNS syntax.
An application can use the hostname to start up another
Mozart process there.
</LIST>

<SUBSECTION><TITLE>Connecting applications with tickets</TITLE>

Let's say Application 1 has a stream that
it wants others to access.
It can do this by creating a ticket
that references the stream.
The module <<Connection>> implements tickets.
Application 1 first creates a ticket for the stream
by using <<Connection>> as follows:

<<<
declare Stream Tkt in
{Connection.offer Stream Tkt}
{Show Tkt}
>>>

Then Application 1 publishes the ticket somewhere so that
other applications can access it.
Our example displays
the ticket string in the emulator window.
We will use copy and paste to communicate the ticket
to another application.
The ticket looks something like
<<'x-ozticket://193.10.66.30:9002:SpGK0:U4v/y:s:f:xl'>>.
Don't worry about exactly what's inside the ticket.
Users don't normally see tickets:
they are stored in files or passed across the network,
e.g., in mail messages.
Application 2 can use the ticket to get a reference
to the stream:

<<<
declare Stream in
{Connection.take 
   'x-ozticket://193.10.66.30:9002:SpGK0:U4v/y:s:f:xl'
   Stream}
{Browse Stream}
>>>

If Application 1 binds the stream
by doing <<Stream=a|b|c|_>>
then Application 2's browse window will show the bindings.


<SUBSECTION><TITLE>Persistent data structures</TITLE>

An application can save
any stateless data structure
in a file and load it again from a file.
The loading may be done from a URL, used as 
a file's global name.
The module <<Pickle>> implements the saving
and loading, and the conversion to and from
the file format.

For example, let's define a function and save it:

<<<
declare
fun {Fact N}
   if N=<1 then 1 else X*{Fact N-1} end
end

{Pickle.save Fact "~pvr/public_html/fact"}
>>>

Since the function is in a <<public_html>> directory,
anyone can load it by giving a URL that specifies
the file:

<<<
declare
Fact={Pickle.load "http://www.sics.se/~pvr/fact"}

{Browse {Fact 10}}
>>>

Anything stateless can be saved in a pickle,
including functions, procedures, classes,
records, and atoms.
Stateful entities, such as objects and variables,
cannot be pickled.

<SUBSECTION><TITLE>Remote computations</TITLE>

An application can start a computation
on a given host that uses the resources
of that host and
that continues to interact with the
application.
The computation is specified as a functor,
which is the standard way to
define computations with the resources they need.

First we create a new Mozart process
that is ready to accept new computations:
<<<
declare
R={New Remote.manager init(host:"sinuhe.sics.se")}
>>>

Let's make the process do some work:
<<<
declare F X in
F=functor define X={Fact 30} end

{R apply(name:"" F)}  % Do the calculation remotely

{Browse X}            % See the answer
>>>

If the remote computation needs resources,
you have to specify the base URL for the resources.

<SECTION><TITLE>


</CHAPTER>

