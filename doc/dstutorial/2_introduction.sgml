<CHAPTER ID="chapter.introduction">
  <TITLE>Introduction</TITLE>

<P>Fueled by the explosive development
of the Internet,
distributed programming is becoming more and more popular.
The Internet provides
a global infrastructure for distributed applications.
Platforms such as Java and CORBA that take advantage
of this infrastructure have become widely-used.
On first glance, one might think that distributed
programming has become a solved problem.
But this is far from the case.
Writing efficient, open, and robust distributed
applications remains much harder than writing
centralized applications.
Making them secure increases the difficulty
by another quantum leap.
The abstractions offered by Java and CORBA,
for example the notion of distributed object,
provide only rudimentary help.
The programmer must still
keep distribution and fault-tolerance strongly in mind.

<P>The Mozart platform is the result of three years
of research into distributed programming and
ten years of research into concurrent constraint programming.
The driving goal is to separate the fundamental aspects
of programming a distributed system:
application functionality, distribution structure,
fault tolerance, security, and open computing.
The current release completely separates
application functionality and distribution structure,
and provides primitives for fault-tolerance,
open computing, and partial support for security.
Current research is focused on completing
the separation for fault tolerance and open computing,
which will be offered in future releases.

<P>This tutorial presents many examples
of practical programs and techniques of distributed
programming and fault-tolerant programming.
The tutorial also gives many examples of
useful abstractions, such as cached objects,
stationary objects,
fault-tolerant stationary objects,
mobile agents, and
fault-tolerant mobile agents,
and shows how easy it is to develop new abstractions
in the Mozart platform.

<P>Essentially all the distribution abilities of Mozart are
given by four modules:
<LIST>
<ITEM> The module <ref.extern to="ozdoc:system"
key="chapter.connection"/<<Connection>>/
provides the basic mechanism (known as <EM>tickets</EM>)
for active applications to connect with each other.
<ITEM> The module <ref.extern to="ozdoc:system"
key="chapter.remote"/<<Remote>>/
allows an active application to create
a new site on another host machine and connect with it.
<ITEM> The module <ref.extern to="ozdoc:system"
key="chapter.pickle"/<<Pickle>>/ gives the basic primitives
for storing and retrieving
arbitrary stateless data from files and URLs.
<ITEM> The module <ref.extern to="ozdoc:system"
key="chapter.fault"/<<Fault>>/ gives the basic primitives
for fault detection and handling.
</LIST>
The first three modules, <ref.extern to="ozdoc:system"
key="chapter.connection"/<<Connection>>/, <ref.extern to="ozdoc:system"
key="chapter.remote"/<<Remote>>/,
and <ref.extern to="ozdoc:system"
key="chapter.pickle"/<<Pickle>>/, are extremely simple to use.
In each case, there are just one or two basic operations.
For example, <ref.extern to="ozdoc:system"
key="chapter.connection"/<<Connection>>/ has just two basic operations:
offering a ticket and taking a ticket.
The fourth module, <ref.extern to="ozdoc:system"
key="chapter.fault"/<<Fault>>/, is the base on which
fault-tolerant abstractions are built.
This release provides a few of the most useful abstractions
to get you started.
The development of more powerful ones is still ongoing
research and will be provided in future releases.

<P>This tutorial attempts to give a precise specification
of the distribution model and the failure model.
The tutorial carefully indicates where the current release
is incomplete with respect to the specification
(this is called a <EM>limitation</EM>)
or has a different behavior (this is called a <EM>modification</EM>).
All limitations and modifications are listed where they occur.
In addition,
they are listed together at the end of the tutorial.

<P>We say two or more applications are <EM>connected</EM>
if they share a reference to a language entity that allows
them to exchange information.
For example, let's say that Application 1 and Application 2
reference the same object.
Then either application can call the object.
All low-level data transfer between the two applications
is automatic; from the viewpoint of the system, it's just one
big concurrent program where one object is being called from
more than one thread.
There is never any explicit message passing or encoding of data.

<P>The Mozart platform provides much functionality
in addition to distribution.
It provides an interactive development environment
with incremental compiler,
many tools including a browser, debugger, and parser-generator,
a C++ interface for developing dynamically-linked libraries,
and state-of-the-art constraint programming support.
We refer the reader to the other tutorials and the extensive
system documentation.

</CHAPTER>
