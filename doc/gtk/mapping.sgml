<!--
  - Authors:
  -   Thorsten Brunklaus  <brunklaus@ps.uni-sb.de>
  -   Leif Kornstaedt <kornstae@ps.uni-sb.de>
  -
  - Copyright:
  -   Thorsten Brunklaus, 2001
  -   Leif Kornstaedt, 2001
  -
  - Last change:
  -   $Date$ by $Author$
  -   $Revision$
  -
  - This file is part of Mozart, an implementation of Oz 3:
  -   http://www.mozart-oz.org
  -
  - See the file "LICENSE" or
  -   http://www.mozart-oz.org/LICENSE.html
  - for information on usage and redistribution
  - of this file, and for a DISCLAIMER OF ALL
  - WARRANTIES.
  -
  -->

<Chapter id="chapter.mapping">
  <Title/How the C API is mapped to Oz/
  <P>
    This chapter describes the details on how the C API is mapped to Oz.
    This knowledge is required when you want to make use of the original
    reference documentation at <Ref.Extern to="http://www.gtk.org/api/"
    ><File>http://www.gtk.org/api/</File></Ref.Extern> with the binding.
  <Section>
    <Title/Modules/
    <P>
      GTK+ is organized into the following modules:
      <List>
       <Item><<GDK at 'x-oz://system/gtk/GDK'>>
       <Item><<GTK at 'x-oz://system/gtk/GTK'>>
       <Item><<GtkCanvas at 'x-oz://system/gtk/GTKCANVAS'>>
      </List>
      Each module represents a namespace.  The corresponding API constants
      and functions are mapped to constants and classes and class methods
      in these namespaces.  The Oz class hierarchy corresponds to the widget
      hierarchy.
    <Para class=apropos><Title/Toplevel Functions/
      Note that toplevel C functions are also mapped to methods of the
      appropriate classes.  Since Oz has no static methods, it may be
      necessary in practice to create a dummy object using the <<noop>>
      constructor to call them.  The <<noop>> constructor does not actually
      create a widget.
  <Section>
    <Title/Name Translation/
    <P>
      We will illustrate how C structure fields and C functions are mapped
      to methods by an example.  Consider the C API for <Code proglang=c
      /GtkButton/, which is derived from <Code proglang=c/GtkBin/:
<Code display proglang=c>/* fields */
struct _GtkButton {
  GtkBin bin;
  GtkWidget *child;
  guint in_button : 1;
  guint button_down : 1;
  guint relief : 2;
};
/* constructors */
GtkWidget *gtk_button_new();
GtkWidget *gtk_button_new_with_label
           (const gchar *label);
/* signal emitters */
void gtk_button_pressed(GtkButton *button);
void gtk_button_released(GtkButton *button);
void gtk_button_clicked(GtkButton *button);
void gtk_button_enter(GtkButton *button);
void gtk_button_leave(GtkButton *button);
/* attribute accessors */
void gtk_button_set_relief
     (GtkButton *button, GtkReliefStyle newstyle);
GtkReliefStyle gtk_button_get_relief(GtkButton *button);</Code>
This is mapped an Oz class as follows:
<<<class GTK.button from GTK.bin
   %% fields
   meth buttonGetFieldBin(?Bin)
   meth buttonGetFieldChild(?Widget)
   meth buttonGetFieldInButton(?I)
   meth buttonGetFieldButtonDown(?I)
   meth buttonGetFieldRelief(?I)
   %% constructors
   meth new()
   meth newWithLabel(Label)
   %% signal emitters
   meth pressed()
   meth released()
   meth clicked()
   meth enter()
   meth leave()
   %% attribute accessors
   meth setRelief(ReliefStyle)
   meth getRelief(?ReliefStyle)
end>>>
    <Para class=apropos><Title/General Scheme/
      The general scheme is that all underscored identifiers are translated to
      use camel-casing.  Since classes belong to a module and methods belong
      to a class, the module and class name prefixes are cut off to increase
      readability.  The first letter of method labels is downcased to allow
      to use convenient Oz atom syntax.
    <Para class=apropos><Title/Field Accessors/
      Field accessors are also camel-cased, but in contrast to the standard
      methods, they use the <<?{className}GetField?{FieldName}>> pattern.
      For example, the <Code proglang=c/button_down/ field above is read
      using the <<buttonGetFieldButtonDown>> accessor method of the class
      <<GTK.button>>.  Fields cannot be written to directly.
    <Para class=apropos><Title/Constants/
      The members of enumerations and flags are translated to constants
      exported with all upper case names containing underscores, with the
      module prefix cut off.
  <Section>
    <Title/Types/
    <P>
      <!--** still incomplete -->
      <Ptr to="figure.types"> shows the mapping of the C types onto Oz types.
      Values are converted back and forth transparently, preserving identity
      whenever possible.
      <Figure id="figure.types">
	<Caption/C to Oz Type Translation/
	<Table>
	  <Tr><Th>C Type<Th>Oz Type
	  <Tr><Td proglang=c><<gint>>, <<guint>>, <<glong>>, <<gulong>><Td>int
	  <Tr><Td proglang=c><<gboolean>><Td><<0>> and <<1>>
	  <Tr><Td proglang=c><<gchar>>, <<guchar>><Td>int
	  <Tr><Td proglang=c><<gfloat>>, <<gdouble>><Td>float
	  <Tr><Td>enumerations, flags<Td>integer
	  <Tr><Td proglang=c><<gchar *>>, <<guchar *>><Td>virtual string
	  <Tr><Td proglang=c><<gchar *[]>>, <<guchar *[]>>
	    <Td>list of virtual strings
	  <Tr><Td proglang=c><<GdkEvent *>><Td>record
	  <Tr><Td proglang=c><<GList *>><Td>list of objects
	  <Tr><Td proglang=c><<double[4]>><Td>list of four floats
	  <Tr><Td proglang=c>all other pointers (&ie;, <<GtkWidget *>>)
	    <Td>object
	</Table>
      </Figure>
    <Para class=apropos><Title/Flags/
      Flags are translated to integer constants.  In general, several
      constants can be combined using addition (<<+>>).
    <Para class=apropos><Title/Inout Arguments/
      The <<int *>> and <<double *>> types are considered to be <Def/inout/
      arguments.  They are mapped to pairs <<XIn#XOut>> where <<XIn>> is the
      value at the time the function is called and <<XOut>> will be bound to
      the value assigned by the function.
    <Para class=apropos><Title/Gdk Events/
      Where a GDK event (a value of the <Code proglang=c/GdkEvent/ union
      type) appears as argument to a callback, a record is constructed using
      the label to indicate which member it belongs to.
      <!--** what are the subtrees? -->
  <Section>
    <Title/Memory Management/
    <P>
      GTK+ and GDK use reference counting garbage collection for most of
      their datastructures, and the binding safely keeps up this property
      for those items.
    <P>
      Some data, however, needs manual allocation and deallocation by the
      user.  These types are shown in <Ptr to="figure.manualgc">.
      <!--** still incomplete -->
      <Figure id="figure.manualgc">
	<Caption/Manually Managed Data Structures/
	<Table>
	  <Tr>
	    <Th>C Type
	    <Th>Oz Type
	    <Th>Constructor
	    <Th>Accessor
	    <Th>Destructor
	  <Tr>
	    <Td proglang=c><<GdkImlibImage *>>
	    <Td><<GDK.imlib>>
	    <Td><<loadImage>> method
	    <Td>object
	    <Td><<destroyImage>> method
	  <Tr>
	    <Td proglang=c><<GtkArg *>>
	    <Td>foreign pointer
	    <Td><<GTK.makeArg>>
	    <Td><<GTK.getArg>>
	    <Td><<GTK.freeArg>>
	  <Tr>
	    <Td proglang=c><<gchar *[]>>, <<guchar *[]>>
	    <Td>foreign pointer
	    <Td><<GTK.makeStrArr>>
	    <Td><<GTK.getStrArr>>
	    <Td><P.silent><!--** missing -->
	</Table>
      </Figure>
      For details on how to use these, refer to <Ptr to="chapter.reference">.
  <Section>
    <Title/Limitations/
    <P>
      Due to implementation limitations, not all functions are fully supported:
      All functions using arrays of <Code proglang=c/GtkArg/s and all variable
      argument versions of those functions support only a single argument.
      This usually only results in performance loss (not loss of expressivity)
      since most of these functions can be called iteratively.
</Chapter>
