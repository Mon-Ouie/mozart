<!--
  - Authors:
  -   Thorsten Brunklaus  <brunklaus@ps.uni-sb.de>
  -   Leif Kornstaedt <kornstae@ps.uni-sb.de>
  -
  - Copyright:
  -   Thorsten Brunklaus, 2001
  -   Leif Kornstaedt, 2001
  -
  - Last change:
  -   $Date$ by $Author$
  -   $Revision$
  -
  - This file is part of Mozart, an implementation of Oz 3:
  -   http://www.mozart-oz.org
  -
  - See the file "LICENSE" or
  -   http://www.mozart-oz.org/LICENSE.html
  - for information on usage and redistribution
  - of this file, and for a DISCLAIMER OF ALL
  - WARRANTIES.
  -
  -->

<Chapter id="chapter.basics">
  <Title/GTK+ Basics/
  <P>
    GTK+ is organized into visual units called widgets. Some Widgets are
    the result of refining a parent widget using inheritance. Therefore,
    widgets are naturally represented as Oz classes.
  <P>
    The general steps to creating a widget in GTK+ are
    <List>
      <Item>Create a widget object using the appropriate class constructor
      <Item>Connect all Signals and Events
        we wish to use to the appropriate handlers
      <Item>Set the attributes of the widget
      <Item>Pack the widget into a container
      <Item>Make the widget visible
    </List>
  <Section><Title/Widget Creation/
  <P>
    A widget object is created by calling a constructor of the widget.
    For example,
<<<Button = {New GTK.button newWithLabel("Hello, World!")}>>>
    creates a new button object which will show <<"Hello, World!">>.
  <P>
    Object creation yields a freshly created widget object
    whose attributes are set to reasonable default values. I will not appear
    on the screen until it has been packed into a container which then is
    made visible.
  <P>
    A widget might provide more than one constructor.
  <Section><Title/Signals and Callbacks/
  <P>
    GTK+ is an event driven toolkit, which means that the dispatcher
    will sleep until an event occurs and control is passed
    to the appropriate function.
  <Para class=apropos><Title/Signals/
    This passing of control is done using the idea of "signals".
    (Note that these signals are not the same as the Unix system signals,
    and are not implemented using them, although the terminology
    is almost identical.)
    When an event occurs, such as the press of a mouse button,
    the appropriate signal will be "emitted" by the widget that was pressed.
    This is how GTK+ does most of its useful work.
    There are signals that all widgets inherit, such as "destroy",
    and there are signals that are widget specific,
    such as "toggled" on a toggle button.
  <Para class=apropos><Title/Connecting Handlers/
    To make our widget object <<Button>>
    perform an action, we set up a signal handler
    to catch these signals and call the appropriate function.
    This is done by calling the method <<signalConnect>>
<<<SignalId = {Button signalConnect(Signal SignalCallback $)}>>>
  <P>
    where <<Signal>> denotes the name of the signal you wish to catch
    and <<SignalCallback>> denotes the function
    you wish to be called when it is caught. <<SignalId>> denotes an
    unique identifier which can be used to manually emit the signal.
  <Para class=apropos><Title/Callback Structure/
    The function specified in the second argument
    is called a "callback function", and should generally be of the form
<<<proc {SignalCallback Args}
   &ellipsis; /* Computations */ &ellipsis;
end>>>
    where <<Args>> will be the list of arguments
    provided for the chosen signal.
  <Subsection><Title/Events/
  <P>
    In addition to the signal mechanism described above,
    there is a set of events that reflect the X event mechanism
    (which are simulated on Windows and other non X platforms).
    Callbacks may also be attached to these events.
  <P>
    In order to connect a callback function to one of these events
    you use the method <<signalConnect>> as described above,
    using <<'event'>> as the <<Signal>> parameter.
    The callback functions for those events look the same as for signals.
  <P>
    For details on those events, see the reference api.
  <Section><Title/Widget Attributes/
  <P>
    GTK+ Widgets organize their data using attributes. Depending on
    the widget, attributes are made available either read-only or mutable.
    The latter case allows for object reconfiguration after the widget object
    has been created.
  <P>
    Attributes are essentially a mapping from a attribute name to value.
    The can be read and written using the widgets set and get Methods.
    Trying to access a non-existing attribute yields an error.
  <P>
    Deping on your style of programming widgets, attribute access might
    occur very seldomly.
  <Section><Title/Container/
  <P>
    Widgets are arranged on the screen using so-called containers.
    A container widget itself usually does not provide
    any visible information but displays its child widgets
    according to a built-in strategy. For example, a <<hBox>>
    container will align all packed children horizontally on the screen.
  <P>
    GTK+ provides a variety of different container types covering the "daily"
    needs, which are all descendants of the <<GTK.container>> class.
    In addition, a container is allowed to contain container widgets.
  <P>
    In the case of our hello world example, the <<GTK.window>> class is
    the container the button is assigned to.
  <Section><Title/Visibility/
  <P>
    The last step to start working with widgets on the sreen is making them
    visible. This can be done manually by bottom-up traversing the spanned
    container tree and calling each containers <<show>> Method or automaticly
    using the topmost containers <<showAll>> method.
  <P>
    With few exceptions, events are only caught while the widget remains
    visible on the screen.
</Chapter>
