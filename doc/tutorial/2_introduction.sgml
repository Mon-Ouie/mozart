<CHAPTER ID="chapter.introduction">
  <TITLE>Introduction</TITLE>
  <P>The current Oz version is referred to as Oz 3. Oz 3 is largely
  compatible to the previous version Oz 2. Oz 2 is the successor Oz 1.
  Oz 3 and its programming system Mozart is developed mainly by the
  research groups of Gert Smolka at DFKI (the German Research Center
  for Artificial Intelligent)
<!-- DENYS: university of saarbruecken -->
 and Seif Haridi at SICS (the Swedish Institute
  of Computer Science).

  <P>Oz is in essence a concurrent constraint programming language, see
  <PTR TO="saraswat94">. A good exposition of the programming model underlying
  Oz 1 is found in <PTR TO="smolka95">. Underlying Oz versions is a concurrent
  constraint-programming model, which is extended to support stateful
  computations, i.e. computations on mutable objects. The Oz 1
  computation model supported a fine-grained notion of concurrency where
  each statement can potentially be executed concurrently. This resulted
  in a fine-grained concurrent object model similar to the actor
  model. Our experience using Oz 1 showed that this kind of model, while
  theoretically appealing, makes it very hard for the programmer to
  control the resources of his/her application. It is also very hard to
  debug programs and the object model becomes unnecessarily awkward.

  <P>In Oz 2, these problems have been remedied by using instead a
  thread-based concurrency model, with programmable control over
  concurrency. A powerful new object system has been designed and
  traditional exception handling constructs have been added. In
  addition, the constraint solving and search capabilities have been
  greatly enhanced.

  <P>The current version of Oz, Oz 3 is almost upward compatible with Oz 2
  apart from minor syntactic simplifications. Oz 3 is extended with a concept
  for module specification called <EM>functor</EM> to support
  incremental construction of programs from components that may be
  addressable over the Internet by URLs, see <PTR TO="duchier98">. 
  The Mozart implementation of Oz 3 supports distributed and networked
  applications. It is possible, in network-transparent fashion, to
  connect different Oz computations located on different sites. Mozart
  supports automatic transfer of stateless data and code among sites,
  mobile computation (objects), message passing, shared logic
  variables and orthogonal mechanisms for network/site fault detection
  and handling.

  <SECTION><TITLE>Summary of Oz features</TITLE>
  <P>A very good starting point is to ask why Oz. Well, one rough short
  answer is that, compared to other existing languages, it is magic! It
  provides the programmers and system developers with a wide range of
  programming abstractions to enable them to develop complex
  applications quickly and robustly. Oz tries to merge several
  directions of programming language designs into a single coherent
  one. Yet, Oz is a simple and coherent design. Most of us know the
  benefits of the various programming paradigms whether object-oriented,
  functional or constraint logic programming. When we start writing
  programs in any existing language, we quickly find ourselves confined
  by the concepts of the underlying paradigm. Oz tries to attack this
  problem by a coherent design that combines the programming
  abstractions of various paradigms in clean and simple way.

  <P>So, before answering the above question, let us see what Oz
  is. This is again a difficult question to answer in a few
  sentences. So, here is the first shot. It is a high level programming
  language that is designed for modern advanced, concurrent,
  intelligent, networked, soft real-time, parallel, interactive and
  pro-active applications. As you see, it is still hard to know what all
  this jargon means. More concretely:

  <LIST>
  <ITEM>Oz combines the salient features of object-oriented programming,
  by providing state, abstract data types, classes, objects and
  inheritance.

  <ITEM>Oz provides the salient features of functional programming by
  providing a compositional syntax, first-class procedures, and lexical
  scoping. In fact, every Oz entity is first class, including
  procedures, threads, classes, methods, and objects.

  <ITEM>Oz provides the salient features of logic and constraint
  programming by providing logic variables, disjunctive constructs,
  programmable search strategies and constraint programming.

  <ITEM>Oz is a concurrent language where users can create dynamically any
  number of sequential threads that can interact with each
  other. However, in contrast to conventional concurrent languages, each
  Oz thread is a data-flow thread. Executing a statement in Oz proceeds
  only when all <EM>real</EM> data-flow dependencies on the variables
  involved are resolved.

  <ITEM>The Mozart platform supports network transparent distribution of
  Oz computations. Multiple Oz sites can connect together and
  automatically behave like a single Oz computation, sharing variables,
  objects, classes and procedures. Sites disconnect automatically when
  references between entities on different sites cease to exist.

  <ITEM>In a distributed environment Oz provides language security. That
  is, all language entities are created and passed explicitly. An
  application cannot forge references nor access references that have
  not been explicitly given to it. The underlying representation of the
  language entities is inaccessible to the programmer. This is a
  consequence of the abstract store and a language with lexical scoping
  and first-class procedures. These are essential to implement a
  capability-based security policy, which is important in open 
  distributed computing.
  
  </LIST>

  <SECTION><TITLE>The Kernel Language</TITLE>
  <P>In this section we are going to give a short and terse
  introduction to the kernel language of Oz. Oz is constructed in two
  steps. The first is the kernel language and thereafter the full
  language. The kernel language represents the essential part of the
  language, whereas the rest may be regarded as syntactic sugar to
  support useful abstractions.

<P><FIGURE ID="CoreLang" CLASS="Figure">
<CAPTION>The Oz kernel language</CAPTION>
	<grammar>
	  <grammar.rule>
	    <grammar.head/<code/?={Statement}//
	    <grammar.alt/<code/?={Statement1} ?={Statement2}//
	    <grammar.alt or/<code/?{X} = ?{f}(?{l1}:?{Y1} ... ?{ln}:?{Yn})//
	    <grammar.alt or/<code/?{X} = ?={number}//
	    <grammar.alt or/<code/?{X} = ?={atom}//
	    <grammar.alt or/<code/?{X} = ?={boolean}//
	    <grammar.alt or/<code/{NewName ?{X}}//
	    <grammar.alt or/<code/?{X} = ?{Y}//
	    <grammar.alt or/<code/local ?{X1} ... ?{Xn} then ?{S1} end//
	    <grammar.alt or/<code/proc {?{X} ?{Y1} ... ?{Yn}} ?{S1} end//
	    <grammar.alt or/<code/{X ?{Y1} ... ?{Yn}}//
	    <grammar.alt or/<code/{NewCell Y X}//
	    <grammar.alt or/<code/{Exchange X Y Z}//
	    <grammar.alt or/<code/{Access X Y}//
	    <grammar.alt or/<code/if ?{B} then ?{S1} else ?{S2} end//
	    <grammar.alt or/<code/thread ?{S1} end//
	    <grammar.alt or/<code/try ?{S1} catch ?{X} then ?{S2} end//
	    <grammar.alt or/<code/raise ?{X} end//
	  </grammar.rule>
	</grammar>
<!--
S ::= ?{S1} ?{S2}
    | ?{X}=?{f}(?{l1}:?{Y1} ... ?{ln}:?{Yn})
    | ?{X}=&lt;number&gt; | ?{X}=&lt;atom&gt; | ?{X==&lt;Boolean&gt; | ...
    | {NewName ?{X}}
    | ?{X}=?{Y}
    | local ?{X1} ... ?{Xn} then ?{S1} end
    | proc {?{X} ?{Y1} ... ?{Yn}} ?{S1} end
    | {X ?{Y1} ... ?{Yn}}
    | {NewCell Y X} | {Exchange X Y Z} | {Access X Y}
    | if ?{B} then ?{S1} else ?{S2} end
    | thread ?{S1} end
    | try ?{S1} catch ?{X} then ?{S2} end | raise ?{X} end
-->
</FIGURE>

<P>The Oz execution model consists of dataflow threads observing a
shared store. Threads contain statement sequences ?{Si} and
communicate through shared references in the store. A thread is
<EM>dataflow</EM> if it only executes its next statement when all the
values the statement needs are available. If the statement needs a
value that is not yet available, then the thread automatically blocks
until it can access that value. As we shall see, data availability in
the Oz model is implemented using logic variables. The shared store is
not physical memory, rather it is an abstract store which only allows
operations that are legal for the entities involved, i.e., there is no
direct way to inspect the internal representations of entities. The
store contains unbound and bound logic variables, cells (named mutable
pointers, i.e., explicit state), and procedures (named lexically
scoped closures that are first-class entities). Variables can
reference the names of procedures and cells. Cells point to
variables. The external reference procedures are variables. When a
variable is bound, it disappears, that is, all threads that reference
it will automatically reference the binding instead. Variables can be
bound to any entity, including other variables. The variable and
procedure stores are monotonic, i.e., information can only be added to
them, not changed or removed.

<P>All Oz execution can be defined in terms of a kernel language
called the Oz Programming Model (OPM) <PTR TO="smolka95">. <PTR TO="CoreLang">
defines the abstract syntax of an OPM statement S. We briefly define
each possible statement. Statement sequences are reduced sequentially
inside a thread. Values (records, numbers, etc.) are introduced
explicitly and can be equated to variables. All variables are logic
variables, declared in an explicit scope defined by the <<local>>
statement. Procedures are defined at run-time with the <<proc>>
statement and referred to by a variable. Procedure applications block
until their first argument refers to a procedure. State is created
explicitly by <EM>NewCell</EM>, which creates a cell, an updateable
pointer into the variable store. Cells are updated by
<EM>Exchange</EM> and read by <EM>Access</EM>. Conditionals use the
keyword <<if>> and block until the condition is <<true>> or <<false>>
in the variable store. Threads are created explicitly with the
<<thread>> statement. Exception handling is dynamically scoped and
uses the <<try>> and <<raise>> statements.

<P>The full Oz language is defined by transforming all its statements
into this kernel language. This will be explained in detail in this
document. Oz supports idioms such as objects, classes, reentrant
locks, and ports <PTR TO="smolka95"><PTR TO="pvr97">. The system
implements them efficiently while respecting their definitions. As an
introduction we will give a brief summary of each idiom's
definition. For clarity, at this stage we have made small conceptual
simplifications. Full definitions are given later in this
document.

<SECTION><TITLE>Classes</TITLE> 
<P>A class is essentially a record that contains the method table and
attribute names. A class is defined through multiple inheritance, and
any conflicts are resolved at definition time when building its method
table.

<SECTION><TITLE>Objects</TITLE> <P>An object is essentially a special
record having a number of components. One component is a one-argument
procedure that references a cell, which is hidden by lexical
scoping. Another component is the object's class. The cell holds the
object's state. Applying an object <<Obj>> to message <<M>> applies
the object's procedure to <<M>>. The argument indexes into the method
table.
<!-- DENYS: this is no longer the correct model -->
A method is a procedure that is given the message and the
object state, and calculates the new state.



<SECTION><TITLE>Reentrant locks</TITLE> 
<P>A reentrant lock is essentially a one-argument procedure <<{Lck P}>> 
used for explicit mutual exclusion, e.g., of method bodies in
objects used concurrently. Reentrant locks use cells and logic
variables to achieve their behavior. <<P>> is a zero-argument
procedure defining the critical section. Reentrant means that the same
thread is allowed to reenter the lock. Calls to the lock may therefore
be nested. The lock is released automatically if the thread in the
body terminates or raises an exception that escapes the lock body.

<SECTION><TITLE>Ports</TITLE> 
<P>A port is an asynchronous channel that supports many-to-one
communication. A port <<P>> encapsulates a stream <<S>>. A stream is a
list with unbound tail. The operation <<{Send P M}>> adds <<M>> to the
end of <<S>>. Successive sends from the same thread appear in the
order they were sent.

<P><FIGURE ID="CompModel" CLASS="Figure">
<CAPTION>The Oz computation model</CAPTION>
<PICTURE.EXTERN TO="image1.gif" TYPE="gif">
</FIGURE>
</CHAPTER>
