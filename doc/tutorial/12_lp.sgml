<CHAPTER ID="chapter.lp">
<TITLE>Logic Programming</TITLE>

<P>Many problems, especially frequent in the field of Artificial
Intelligence, and also found elsewhere, e.g., in operations research,
are currently solvable only by resorting to some form of search and
<EM/constraint/ propagation. Such problems admit very concise
solutions, if the programming language abstracts away the details of
search by providing don't know nondeterminism. Logic
programming and Prolog is considered a suitable
formalism for this class of problems.
In this chapter we will talk about how to express
logic programming and concurrent
constraint programming in Oz.
In logic programming each procedure can be
interpreted as a relation expressed by a logical statement.
We will also discuss the relation between Oz and Prolog, and how
most Prolog programs have a straight forward translation to Oz programs.

For more advanced constraint solving techniques, the reader may
look to the companion tutorial on constraint programming in Oz.


<SECTION><TITLE/Constraint Stores/
<P>Oz threads share a store where variable bindings are stored in the
form of equalities: <MATH>X_1=U_1, \ldots, X_n=U_n</MATH> where
<MATH/X_i/ are variables and <MATH/U_i/ are either Oz entities or
variables. The constraint store
contains the the Oz values corresponding to records, numbers, names or
variables, and the names that uniquely idententifies the procedures, cells
and the various types of chunks (classes, objects, functors, etc.).
Conceptually the  store is modeled as a conjunctive logical
formula:
<MATH>\exist Y_1 \ldots \Y_m : X_1=U_1 \wedge \ldots \wedge X_n=U_n</MATH>,
where the <MATH>X_i</MATH> are the variables and <MATH>U_i</MATH>
are Oz values or variables, and <MATH>Y_i </MATH> are the union of all
variables occuring in <MATH>X_i </MATH> and <MATH>U_i </MATH>.
The store is
said to be a <EM>constraint store</EM>. An Oz <EM> computation store</EM>
consists a constraint store, a procedure store where procedures reside, and
a cell store where cells and object states reside.


<SECTION><TITLE/Computation Spaces/
<P>A computation space consists in general of a computation store and a
a set of executing threads. What we have seen so
far is a single computation space.
When dealing with logic programming a more
elaborate structure will arise with multiple nested computation spaces. The
general rules for the structure of computation spaces are as follows.

<LIST>

<ITEM>There is always a topmost computation space where threads may
interact with the external world. A thread trying to add inconsistent
constraints (bindings) to the store of the top space will raise
failure exception in the thread. The addition of the inconsistent
constraints will be aborted and the constraint store remains always
consistent.

<ITEM>A thread may create a local computation space either directly or
indirectly as will be shown in this section. The new computation space
will be a child space and the current one the parent space. In general
a hierarchy of computation spaces may be created.

<ITEM>A thread belongs always to one computation space. Also,
variables belong to only one computation space.

<ITEM>A thread in a child space sees and may access variables
belonging to its space as well as to all ancestor spaces. The converse
is false. A thread in a parent space cannot see the variables of a
child space, unless the child space is merged with the parent. In such
a case, the child space disappears, and all its content is added to
the parent space. The space merge operation may occur due to an
explicit operation, or indirectly due to a language construct as will
be seen in this section.

<ITEM>A Thread in a child space my add constraints (bindings) on
variables visible to it. This means that it may bind variables
belonging to its space or to its ancestor spaces. The binding will
only be visible in the current space and all its children spaces if
any.

</LIST>


<SECTION><TITLE/Constraint Entailment and Disentailment/ <P>A
condition <MATH/C/ is entailed by the store <MATH/\sigma/ if <MATH/C/,
considered as a logical formula, is logically implied by the store
<MATH/\sigma/, again considered as a logical formula.  Intuitively
entailment of <MATH/C/ means that adding <MATH/C/ to the store does
not increase the information already there. Everything is already there.

<P>A condition <MATH/C/ is disentailed by the store if the negation of
<MATH/C/ is logically implied by the store <MATH/\sigma/. A disentailed
constraint is inconsistent with the information already in the store.

<P> Since a constraint store is a logical formula, we can also talk
of a constraint store being entailed, or disentailed by another constraint
store. A space <MATH/S_0/ is entailed (disentailed) by another space
<MATH/S_1/ if the constraint store of <MATH/S_0/ is entailed (disentailed)
by the constraint store if <MATH/S_1/.

<P> We call a space that is disentailed (normally by a perent space) a
<EM> failed space </EM>.


<SUBSECTION><TITLE/Examples/

<P>Consider the store:
<MATH/\sigma \equiv X = 1 \wedge \ldots \wedge Y = f(X \ Z)/, and
the following conditions.

<LIST>

<ITEM><MATH/X=1/ is entailed.  Since adding this binding
does not increase the information in the store.

<ITEM>There exists a <MATH/U/, such that <MATH/Y=f(1 \ U)/ is also entailed.
Adding this information does not increase our information. There is a
<MATH/Z/ that satisfies the above condition. Notice that we do not know
which value <MATH/Z/ will assume. But whatever value assumed by <MATH/Z/,
the condition would be still satisfied.

<ITEM><MATH/Y=f(1 \ 2)/ is not entailed by the store, since adding
this equality will increase the information there, namely by making
<MATH/Z=2/.

<ITEM><MATH/X=2/ or <MATH/Y=f(3 \ U)/ are both disentailed since they
contradict information already there. They will normally lead to raised
failure exception if the store is of the top space, and to a failed
local space if the store belongs to it.

</LIST>


<SECTION><TITLE/Disjunctions/
<P>Now we are in a position to understand the nondeterminate
constructs of Oz. Oz provides several disjunctive constructs for
<EM>nondeterminate choice</EM>, also known as <EM>don't know
choice</EM> statements.


<SUBSECTION><TITLE/or statement/
<P>In all the disjunctive statements we are going to use the notion of
guard. A guard ?{G} has the following form.

<<<?{X1} ... ?{XN} in ?{S}>>>

<P>The first disjunctive statement has the following form:

<<<
or
   ?{G1} then ?{S1}
[] ?{G2} then ?{S2}
   ...
[] ?{GN} then ?{SN}
end
>>>

<P>An <<or>>-statement has the following semantics. Assume a thread is
executing the statement in space ?{SP}.

<LIST>

<ITEM>The thread is blocked.

<ITEM><MATH/N/ spaces are created <MATH/SP_1, \ldots, SP_N/ with
<MATH/N/ new threads executing the guards <MATH/G_1, \ldots, G_N/.

<ITEM>Execution of the father thread will remain blocked until at most
one of the child spaces is not failed.

<ITEM>If all children spaces are failed, the parent thread raises a
failure condition in its space. This means that if the space of
the parent thread is the top space, a failure exception is raised.
Otherwise the space is local and it becomes a failed space.

<ITEM>If there is one space that is not failed which
corresponds to the disjunct <MATH/G_i/ <<then>> <MATH/S_i/. Assume also that
<MATH/G_i/ has been reduced to the goal <MATH/G'_i/ and the
constraint <MATH/\theta/. In this case, the space is merged
with the parent space. <MATH/\theta/ and the variables of
the store added to that of the parent store.
<MATH/G'_i/ executes in its own thread, and the suspending
thread resumes executing the statement <MATH/S_i/.
This rule of execution is called <EM>unit commit</EM> in Oz because
execution commits to one alternative disjunct.

</LIST>


<SUBSECTION><TITLE/Shorthand Notation/

<P><<<
or
...
[] ?{Gi}
...
end
>>>

<P>Stands for

<<<
or
...
[] ?{Gi} then skip
...
end
>>>

<P> Observe that the <<or>> statement does not introduce any
don't know nondeterminism. A thread executing such a statement waits
until things works out in a determinate course of action.

<SUBSECTION><TITLE/Prolog Comparison/
<P> The <<or>> statement just described does not have a corresponding
construct in Prolog. The Prolog disjunct <<P ; Q>> always creates
a choice point that is subject to backtracking.

<SECTION><TITLE/Determinacy Driven Execution/
<P>The <<or>>-statement of Oz allows a pure logical form of programming
style where computations are synchronized by determinacy
conditions. Consider the following program.

<<<
proc {Ints N Xs}
   or N = 0 Xs = nil
   [] Xr in
      N > 0 = true Xs = N|Xr
      {Inst N-1 Xr}
   end
end
local
   proc {Sum3 Xs N R}
      or Xs = nil R = N
      [] X|Xr = Xs in
         {Sum3 Xr X+N R}
      end
   end
in proc {Sum Xs R} {Sum3 Xs 0 R} end
end
local N S R in
   thread {Ints N S} end
   thread {Sum S {Browse}} end
   N = 1000
end
>>>

<P>The thread executing <<Ints>> will suspend until <<N>> is known,
because it cannot decide on which disjunct to take. Similarly,
<<Sum3>> will wait until the list <<S>> is known. <<S>> will be
defined incrementally and that will lead to the suspension and
resumption of <<Sum3>>. Things will start to take off when the main
thread binds <<N>> to <<1000>>. This shows clearly that determinacy
driven execution gives the synchronization information need to mimic
producer/consumer behavior.


<SECTION><TITLE/Conditionals/
<SUBSECTION><TITLE/Logical Conditional/
<P>A logical conditional is a statement having the following form.

<<<cond ?{X1} ... ?{XN} in ?{S0} then ?{S1} else ?{S2} end>>>

<P>where ?{Xi}  are newly introduced variables,
and ?{Si} are statements.

<P>A <<cond>>-statement has the following semantics. Assume a thread is
executing the statement in space ?{SP}.

<LIST>

<ITEM>The thread is blocked.

<ITEM>A space <MATH/SP_1/ are created,
with a single thread executing the guard <<cond ?{X1} ... ?{XN} in ?{S0}>>.

<ITEM>Execution of the father thread will remain blocked until
the <MATH/SP_1/ is either entailed or disentailed. Notice that
these conditions may never occur, e.g. when some thread is suspended
or running forever in <MATH/SP_1/.

<ITEM>If <MATH/SP_1/ is disentailed, the father thread continues
with ?{S2}.

<ITEM>If  <MATH/SP_1/ is entailed, assume it has been reduced to
the store <MATH/\theta/ and the set of local variables <MATH/\SX/
In this case, the space is merged
with the parent space. <MATH/\theta/ and <MATH/\SX/
added to that of the parent store. And the father thread continues
with the execution of ?{S1}.

</LIST>

<SUBSECTION><TITLE/Prolog Comparison/
<P> The <<cond>> statement just described corresponds roughly to
Prolog's conditional << P -> Q ; R >>. Oz is a bit more careful about
the scope of variables, so local variables <<?{Xi}>> have to be
introduced explicitly. <<cond X in P then Q else R end>> always has
the logical semantics <MATH/\exist X : P \and Q \or (\not \exist X : P) \and R\, given that we stick to the logical part of Oz. This is not always true
in Prolog.

<SUBSECTION><TITLE/Parallel Conditional/
<P>A parallel conditional is of the from

<<<
cond ?{G1} then ?{S1}
[] ?{G2} then ?{S2}
...
else ?{SN} end
>>>

<P>A parallel conditional is executed by evaluating all conditions
<<?{G1} ... ?{G(N-1)}>> in an <EM>arbitrary</EM> order, possibly
concurrently, each in its own space.
If one of the spaces, say ?{Gi}, is entailed,
its corresponding statement ?{Si} is chosen the father thread. If
all spaces are failed, the else statement ?{SN} is
chosen, otherwise the executing thread suspends.

<P> Parallel conditionals
are useful mostly in concurrent programming, e.g. for programming
time-out on certain events. This construct is the basic construct
in concurrent logic programming languages (also known as
committed-choice languages).

<P> As a typical example from concurrent logic programming let us
defined the intereministic binary merge, where the arrival timing of elements
on the two streams <<Xs>> and <<Ys>> determines the order of elements
on the resulting stream <<Zs>>.

<<<
proc {Merge Xs Ys Zs}
   cond
      Xs = nil then Zs = Ys
   [] Ys = nil then Zs = Xr
   [] X Xr in Xs = X|Xr then Zr in
      Zs = X|Zr {Merge Xr Ys Zr}
   [] Y Yr in Ys = Y|Yr then Zr in
      Zs = Y|Zr {Merge Xs Yr Zr}
   end
end
>>>

</CHAPTER>
