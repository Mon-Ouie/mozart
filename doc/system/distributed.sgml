<!--
  - Authors:
  -   Denys Duchier     <duchier@ps.uni-sb.de>
  -   Leif Kornstaedt <kornstae@ps.uni-sb.de>
  -   Christian Schulte <schulte@dfki.de>
  -
  - Copyright:
  -   Denys Duchier, 1998
  -   Leif Kornstaedt, 1998
  -   Christian Schulte, 1998
  -
  - Last change:
  -   $Date$ by $Author$
  -   $Revision$
  -
  - This file is part of Mozart, an implementation
  - of Oz 3
  -    http://mozart.ps.uni-sb.de
  -
  - See the file "LICENSE" or
  -    http://mozart.ps.uni-sb.de/LICENSE.html
  - for information on usage and redistribution
  - of this file, and for a DISCLAIMER OF ALL
  - WARRANTIES.
  -
  -->

<Part id="Part.Distributed">
  <Title/Distributed Programming/

  <Chapter id="Chapter.Connection">
    <Title/Connecting Computations: <<Connection>>/

    <P>
      Oz uses a ticket-based mechanism to establish
      connections between independent Oz processes.
      One process (called <Def/server/) creates a ticket
      with which other sites (called <Def/clients/)
      can establish a connection.
    </P>

    <P>
      A <Def/ticket/ is a character string
      which can be stored and transported through all media that can
      handle text, e.g., phone lines, electronic mail, paper,
      and so forth. Tickets are insecure, in that they can be forged
      (albeit some luck is required, since they offer some security
      against typos). The following is an example ticket encoded as an
      Oz atom: <<<'x-ozticket://134.96.186.115:9000:egbj0:DS/v:s:kn'>>>
    </P>

    <P>
      The ticket identifies both the server and the value to
      which a remote reference will be made. Independent connections
      can be made to different values on the same server. Once an
      initial connection is established by the value exchanged, then
      further connections as desired by applications can be built from
      programming abstractions, like object, classes, ports or
      procedures.
    </P>

    <P>
      Two different types of connections and tickets are supported:
      <List>
        <Entry>
          <Def/One-to-one connections/ and <Def/one-shot tickets/.
        <Item>
          Allow to establish a single connection only.

        <Entry>
          <Def/Many-to-one connections/ and <Def/many-shot tickets/.
        <Item>
          Allow multiple connections with the same ticket to the same
          value. Values for many-to-one connections are offered
          through gates.
       </List>
    </P>

    <P>
      The module <Span class=index/<<Connection>>/ provides procedures
      and classes that support both one-to-one and many-to-one
      connections.
    </P>

    <Section id="Section.Connection.One">
      <Title/One-to-one Connections/

      <P>
        <List>
          <Entry><Span class=index/<<offer>>/
            <Index/<<Connection>><And><<offer>>/
          <Synopsis>
            <<{Connection.offer ?_{X} ?_{TicketA}}>>
          <Item>
            Returns the single-shot ticket ?_{TicketA} (an atom)
            under which the value ?_{X} is offered.
          <P>
            The value ?_{X} is exported immediately. An exception is
            raised, if exportation of ?_{X} fails, because ?_{X}
            refers to sited entities.

          <Entry><Span class=index/<<take>>/
            <Index/<<Connection>><And><<take>>/
          <Synopsis>
            <<{Connection.take ?+{TicketV} ?_{X}}>>
          <Item>
            Returns the value ?_{X} offered under the ticket
            ?_{TicketV} (a virtual string).
          <P>
            Waits until the connection to the offering process is
            established and the ticket has been acknowledged by that
            process.
          <P>
            Raises an exception if the ticket is illegal, or if the
            offering process does not longer exist.
          <P>
            Also works for many-shot tickets, where an exception might
            be raised if the same ticket is used more than once.
        </List>
      </P>
    </Section>

    <Section id="Section.Connection.Many">
      <Title/Many-to-one Connections/

      <P>
        Values for many-to-one connections can be offered through
        <Def/gates/. Values offered through gates can be taken with
        <Span class=index/<<Connection.take>>/ as described for
        one-to-one connections.
      </P>

      <P>
        Gates are provided as instances of the class
        <Span class=index/<<Connection.gate>>/. The methods of
        <<Connection.gate>> are as follows.
      </P>

      <P>
        <List>
          <Entry><Span class=index/<<init>>/
            <Index/<<Connection>><And><<gate>><And><<init>>/
          <Synopsis>
            <code/init(?_{X} ?_{TicketA} <= _)/
          <Item>
            Optionally returns the many-shot ticket ?_{TicketA} (an atom)
            under which the value ?_{X} is offered.
          <P>
            The value ?_{X} is exported immediately. An exception is
            raised, if exportation of ?_{X} fails, because ?_{X} might
            refer to sited entities.

          <Entry><Span class=index/<<getTicket>>/
            <Index/<<Connection>><And><<gate>><And><<getTicket>>/
          <Synopsis>
            <code/getTicket(?_{TicketA})/
          <Item>
            Returns the many-shot ticket ?_{TicketA} (an atom) of the
            gate.

          <Entry><Span class=index/<<close>>/
            <Index/<<Connection>><And><<gate>><And><<close>>/
          <Synopsis>
            <code/close()/
          <Item>
            Closes the gate, which makes further use of the associated
            ticket illegal.

        </List>
      </P>

    </Section>

  </Chapter>


  <Chapter id="Chapter.Remote">
    <Title/Spawning Computations Remotely: <<Remote>>/

    <P>
      The module <<Remote>> provides the class <<Remote.manager>> by
      which new Oz processes can be created. Creating an instance of
      that class does the following two things:
      <List>
        <Item> A new Oz process with a module manager ?_{M} is
               created.
        <Item> The newly created object ?_{O} serves as a proxy to
               ?_{M}, where ?_{O} can be seen as a remote module
               manager. This allows to start applications remotely
               that access remote resources by local system modules.
      </List>
    </P>

    <P>
      The methods of the class <<Remote.manager>> are as follows.
    </P>

    <P>
     The methods of Remote.manager are as follows:
    </P>

    <P>
      <List>
        <Entry><Span class=index/<<init>>/
          <Index/<<Remote>><And><<manager>><And><<init>>/
        <Synopsis>
<code display/init(host:   ?+{HostV}   <= localhost
     fork:   ?+{ForkA}   <= automatic
     detach: ?+{DetachB} <= false)/
        <Item>
          Creates a new Oz process at ?_{HostV} (specified by a virtual
          string), where <<localhost>> is the computer running the
          current Oz process.
        <P>
          ?_{ForkA} (an atom) determines the operating system method
          to fork the remote Oz process. Currently, <<'automatic'>> and
          <<'rsh'>> are supported.  <<'rsh'>> creates
          a shell remotely by using the Unix <<rsh>> command, which in
          turn creates the new Oz engine.
        <P>
          If ?_{HostV} is <<'localhost'>> and ?_{ForkA}? is
          <<'automatic'>> a possibly more efficient way of creating
          new Oz processes is used. As a fallback, the <<'rsh'>>
          method is used.
        <P>
          If ?_{DetachB} is <<false>>, a non-detached process is
          created. A non-detached process terminates as soon as
          the creating process does (think of crashes, there will be
          no orphaned processes). A lifetime of a detached process
          (that is, ?_{DetchB} is <<true>>) is independent of the
          creating process. (I've taken the notion detach from
          standard operating system terminology).

        <Entry><Span class=index/<<link>>/
          <Index/<<Remote>><And><<manager>><And><<link>>/
        <Synopsis>
            <code display/link(url:?+{UrlV} ?_{ModuleR} <= _)/
            <code display/link(name:?+{NameV} ?_{ModuleR} <= _)/
        <Item>
            Links the module identified either by a url ?_{UrlV} (a
            virtual string) or a module name ?_{NameV} (a virtual
            string). Returns the module ?_{ModuleR}, if it has been
            already linked or a future to it.
          <P>
            The argument for the module is optional, if it is omitted
            the module is requested immediately.

          <Entry><Span class=index/<<apply>>/
            <Index/<<Remote>><And><<manager>><And><<apply>>/
          <Synopsis>
            <code display/apply(url:?+{UrlV} ?+{Functor} ?_{ModuleR} <= _)/
            <code display/apply(name:?+{NameV} ?+{Functor} ?_{ModuleR} <= _)/
          <Item>
            Applies the functor ?_{Functor}, where the url ?_{UrlV} (a
            virtual string) or the module name ?_{NameV} (a virtual
            string) serve as base URL for linking the functor's
            import.
          <P>
            The argument for the module is optional.
          <P>
            Please note that the resulting module is <Em/not/ added to
            the module table, the URL argument only serves as base URL
            for the functor's import.

          <Entry><Span class=index/<<enter>>/
            <Index/<<Remote>><And><<manager>><And><<enter>>/
          <Synopsis>
            <code display/enter(url:?+{UrlV} ?_{ModuleR})/
            <code display/enter(name:?+{NameV} ?_{ModuleR})/
          <Item>
            Installs the module ?_{ModuleR} under the url ?_{UrlV} (a
            virtual string) or the module name ?_{NameV} (a virtual
            string).
          <P>
            Raises an exception if the module manager already has a
            module under that particular URL installed.

          <Entry><Span class=index/<<ping>>/
            <Index/<<Remote>><And><<manager>><And><<ping>>/
          <Synopsis>
            <code display/ping()/
          <Item>
           Raises exception if remote process is dead. Blocks until
           executed by remote process.

          <Entry><Span class=index/<<close>>/
            <Index/<<Remote>><And><<manager>><And><<close>>/
          <Synopsis>
            <code display/close()/
          <Item>
            Kills the remote process.

        </List>
       </P>


  </Chapter>


  <Chapter id="Chapter.URL">
    <Title/Referring To Distributed Entities: <<URL>>/
    <p>In the age of the <em/World Wide Web/, resources needed by a
running system don't just reside in files, they reside at URLs.  The
<code/URL/ module provides an interface for creating and manipulating
URLs as data-structures.  It fully conforms to URI syntax as defined
in IETF draft <ref.extern to="ftp://ftp.isi.edu/in-notes/rfc2396.txt"
>Uniform Resource Identifiers (URI): Generic Syntax</ref.extern> by
T.&nbsp;Berners-Lee, R.&nbsp;Fielding, and L.&nbsp;Masinter (June 4,
1998), and passes all 5 test suites published by Roy Fielding.</p>
    <p>The only derogations to said specification were made to
accommodate Windows-style filenames: (1) a prefix of the form
?{C}<samp/:/ where ?{C} is a single character is
interpreted as Windows-style device notation rather than as a uri
scheme -- in practice, this is a compatible extension since there are
no legal single character schemes, (2) path segments may indifferently
be separated by <samp>/</samp> or <samp/\/; this too is compatible
since non-separator forward and backward slashes oughtto be otherwise
<em/escape encoded/.</P>
    <p>There is additionally a further experimental extension: all
urls may be suffixed by a string of the form "{foo=a,bar=b}".  This
adds an <em/info/ record to the parsed representation of the url.
Here, this record would be <code/info(foo:a bar:b)/.  Thus properties
can be attached to urls.  For example, we may indicate that a url
denotes a native functor thus:
<file>file:/foo/bar/baz.so{native}</file>.  Here <code/{native}/ is
equivalent to <code/{native=}/, &ie; the info record is
<code/info(native:'')/.</p>
    <section><title/Examples/
<p>Here are a few examples of conversions from url vstrings to url
records. Return values are displayed following the function call.
<list>
        <entry><code>{URL.make "http://mozart.ps.uni-sb.de/home/share/FD.ozf"}</code></entry>
<item><code display>
url(
   authority:"mozart.ps.uni-sb.de"
   path:abs(
           ["home"#true
            "share"#true
            "FD.ozf"#false])
   scheme:"http")
</code>
The <code/path/ feature contains a record: the <code/abs/ label
indicates that the path began with a slash.  The argument of the
record is a list of pairs; one per component of the path.  The first
element of the pair is the text of the component, and the second
element is a boolean indicating whether it was followed by a slash.
This should be true for all elements except possibly the last one.
The representation may change in the future.</item>
        <entry><code>{URL.make "foo/bar/"}</code>
        <item><code display>url(
   path:rel(["foo"#true "bar"#true nil#false]))</code>
The above illustrates a relative url: the label of the <code/path/
record is <code/rel/.  Note that the trailing slash
results in the empty component <code/nil#false/.
        <entry><code>{URL.make "c:\\foo\\bar"}</code>
        <item><code display>url(
   device:"c"
   path:abs(["foo"#true "bar"#false]))</code>
Here the leading <samp/c:/ was parsed as a Windows-style device
notation and the backslashes as component separators.
        <entry><code>{URL.make "foo.so{native}"}</code>
<item><code display>url(
   info:info(native:'')
   path:rel(["foo.so"#false]))</code>
The <code/{native}/ annotation is entered into the <code/info/
feature.
      </list>
    <section><title/Interface/
<p><list>
        <entry/<code/URL.make//
        <synopsis/<code/{URL.make ?+{VS} ??{Url}}//
        <item>Parses virtual string ?_{VS} as a url, according to the
proposed uri syntax modulo Windows-motivated derigations (see above).
Local filename syntax is a special case of schemeless uri.  The parsed
representation of a url is a non-empty record whose features hold the
various parts of the url, it has the form <code/url(...)/.  We speak
of url records and url vstrings: the former being the parsed
representation of the latter.  A url record must be non-empty to
distinguish it from the url vstring consisting of the atom
<code/url/.  The empty url record can be written &eg;
<code/url(unit)/.  ?_{VS} may also be a url record, in which case it
is simply returned.</item>
      <entry/<code/URL.is//
      <synopsis/<code/{URL.is ?+{X}}//
      <item>Returns <code/true/ iff ?_{X} is a non-empty record
labeled with <code/url/.</item>
      <entry/<code/URL.toVs//
      <synopsis/<code/{URL.toVs ?+{X} ??{VS}}//
      <item>?_{X} may be a url record or vstring.  The corresponding
normalied vstring representation is returned. #?_{FRAGMENT} and
{?_{INFO}} segments are not included (see below).  This is appropriate
for retrieval since fragment and info sections are meant for
client-side usage.</item>
      <entry/<code/URL.toVsExtended//
      <synopsis/<code/{URL.toVsExtended ?+{X} ?+{HOW} ??{VS}}//
      <item>Similar to the above, but ?_{HOW} is a record with
optional boolean features code/full/ and <code/cache/.
<code/full:true/ indicates that #?{FRAGMENT} and {?{INFO}} sections
should be included if present.  <code/cache:true/ requests that
cache-style syntax be used (see <ptr to="Chapter.Resolve">): the
<samp/:/ following the scheme and the <samp>//</samp> preceding the
authority are both replaced by single <samp>/</samp>.</item>
      <entry/<code/URL.toString//
      <synopsis/<code/{URL.toString ?+{X} ??{STR}}//
      <item>Calls <code/URL.toVs/ and transforms the result to a
string.
      <entry/<code/URL.toAtom//
      <synopsis/<code/{URL.toAtom ?+{X} ??{Atom}}//
      <item>Calls <code/URL.toVs/ and transforms the result to a
atom.
      <entry/<code/URL.resolve//
      <synopsis/<code/{URL.resolve ?+{BASE} ?+{REL} ??{Url}}//
      <item>?_{BASE} and {_{REL} are url records or vstrings.  ?_{REL}
is resolved relative to ?_{BASE} and a new url record is returned with
the appropriate fileds filled in.
    </list>
  </Chapter>


  <Chapter id="Chapter.Resolve">
    <Title/Resolving URLs: <<Resolve>>/
  </Chapter>

  <Chapter id="Chapter.Fault">
    <Title/Detecting and Handling Failure: <<Fault>>/
  </Chapter>

</Part>

<!--
Local Variables:
mode: sgml
mode: auto-fill
sgml-default-dtd-file: "part.ced"
sgml-auto-activate-dtd: t
adaptive-fill-mode: nil
End:
-->
