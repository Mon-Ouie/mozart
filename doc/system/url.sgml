<!--
  - Authors:
  -   Denys Duchier     <duchier@ps.uni-sb.de>
  -   Leif Kornstaedt <kornstae@ps.uni-sb.de>
  -   Christian Schulte <schulte@dfki.de>
  -
  - Copyright:
  -   Denys Duchier, 1998
  -   Leif Kornstaedt, 1998
  -   Christian Schulte, 1998
  -
  - Last change:
  -   $Date$ by $Author$
  -   $Revision$
  -
  - This file is part of Mozart, an implementation
  - of Oz 3
  -    http://mozart.ps.uni-sb.de
  -
  - See the file "LICENSE" or
  -    http://mozart.ps.uni-sb.de/LICENSE.html
  - for information on usage and redistribution
  - of this file, and for a DISCLAIMER OF ALL
  - WARRANTIES.
  -
  -->

  <Chapter id="Chapter.URL">
    <Title/Referring To Distributed Entities: <<URL>>/
    <p>In the age of the <em/World Wide Web/, resources needed by a
running system don't just reside in files, they reside at URLs.  The
<code/URL/ module provides an interface for creating and manipulating
URLs as data-structures.  It fully conforms to URI syntax as defined
in IETF draft <ref.extern to="ftp://ftp.isi.edu/in-notes/rfc2396.txt"
>Uniform Resource Identifiers (URI): Generic Syntax</ref.extern> by
T.&nbsp;Berners-Lee, R.&nbsp;Fielding, and L.&nbsp;Masinter (June 4,
1998), and passes all 5 test suites published by Roy Fielding.</p>
    <p>The only derogations to said specification were made to
accommodate Windows-style filenames: (1) a prefix of the form
?{C}<samp/:/ where ?{C} is a single character is
interpreted as Windows-style device notation rather than as a uri
scheme -- in practice, this is a compatible extension since there are
no legal single character schemes, (2) path segments may indifferently
be separated by <samp>/</samp> or <samp/\/; this too is compatible
since non-separator forward and backward slashes oughtto be otherwise
<em/escape encoded/.</P>
    <p>There is additionally a further experimental extension: all
urls may be suffixed by a string of the form "{foo=a,bar=b}".  This
adds an <em/info/ record to the parsed representation of the url.
Here, this record would be <code/info(foo:a bar:b)/.  Thus properties
can be attached to urls.  For example, we may indicate that a url
denotes a native functor thus:
<file>file:/foo/bar/baz.so{native}</file>.  Here <code/{native}/ is
equivalent to <code/{native=}/, &ie; the info record is
<code/info(native:'')/.</p>
    <section><title/Examples/
<p>Here are a few examples of conversions from url vstrings to url
records. Return values are displayed following the function call.
<list>
	<entry><code>{URL.make "http://mozart.ps.uni-sb.de/home/share/FD.ozf"}</code></entry>
<item><code display>
url(
   authority:"mozart.ps.uni-sb.de" 
   path:abs(
           ["home"#true 
            "share"#true 
            "FD.ozf"#false]) 
   scheme:"http")
</code>
The <code/path/ feature contains a record: the <code/abs/ label
indicates that the path began with a slash.  The argument of the
record is a list of pairs; one per component of the path.  The first
element of the pair is the text of the component, and the second
element is a boolean indicating whether it was followed by a slash.
This should be true for all elements except possibly the last one.
The representation may change in the future.</item>
	<entry><code>{URL.make "foo/bar/"}</code>
	<item><code display>url(
   path:rel(["foo"#true "bar"#true nil#false]))</code>
The above illustrates a relative url: the label of the <code/path/
record is <code/rel/.  Note that the trailing slash
results in the empty component <code/nil#false/.
	<entry><code>{URL.make "c:\\foo\\bar"}</code>
	<item><code display>url(
   device:"c" 
   path:abs(["foo"#true "bar"#false]))</code>
Here the leading <samp/c:/ was parsed as a Windows-style device
notation and the backslashes as component separators.
	<entry><code>{URL.make "foo.so{native}"}</code>
<item><code display>url(
   info:info(native:'') 
   path:rel(["foo.so"#false]))</code>
The <code/{native}/ annotation is entered into the <code/info/
feature.
      </list>
    <section><title/Interface/
      <p><list>
	  <entry/<code/URL.make//
	<synopsis/<code/{URL.make ?+{VS} ??{Url}}//
	<item>Parses virtual string ?_{VS} as a url, according to the
proposed uri syntax modulo Windows-motivated derigations (see above).
Local filename syntax is a special case of schemeless uri.  The parsed
representation of a url is a non-empty record whose features hold the
various parts of the url, it has the form <code/url(...)/.  We speak
of url records and url vstrings: the former being the parsed
representation of the latter.  A url record must be non-empty to
distinguish it from the url vstring consisting of the atom
<code/url/.  The empty url record can be written &eg;
<code/url(unit)/.  ?_{VS} may also be a url record, in which case it
is simply returned.</item>
      <entry/<code/URL.is//
      <synopsis/<code/{URL.is ?+{X}}//
      <item>Returns <code/true/ iff ?_{X} is a non-empty record
labeled with <code/url/.</item>
      <entry/<code/URL.toVs//
      <synopsis/<code/{URL.toVs ?+{X} ??{VS}}//
      <item>?_{X} may be a url record or vstring.  The corresponding
normalied vstring representation is returned. #?_{FRAGMENT} and
{?_{INFO}} segments are not included (see below).  This is appropriate
for retrieval since fragment and info sections are meant for
client-side usage.</item>
      <entry/<code/URL.toVsExtended//
      <synopsis/<code/{URL.toVsExtended ?+{X} ?+{HOW} ??{VS}}//
      <item>Similar to the above, but ?_{HOW} is a record with
optional boolean features code/full/ and <code/cache/.
<code/full:true/ indicates that #?{FRAGMENT} and {?{INFO}} sections
should be included if present.  <code/cache:true/ requests that
cache-style syntax be used (see <ptr to="Chapter.Resolve">): the
<samp/:/ following the scheme and the <samp>//</samp> preceding the
authority are both replaced by single <samp>/</samp>.</item>
      <entry/<code/URL.toString//
      <synopsis/<code/{URL.toString ?+{X} ??{STR}}//
      <item>Calls <code/URL.toVs/ and converts the result to a
string.
      <entry/<code/URL.toAtom//
      <synopsis/<code/{URL.toAtom ?+{X} ??{Atom}}//
      <item>Calls <code/URL.toVs/ and converts the result to a
atom.
      <entry/<code/URL.resolve//
      <synopsis/<code/{URL.resolve ?+{BASE} ?+{REL} ??{Url}}//
      <item>?_{BASE} and {_{REL} are url records or vstrings.  ?_{REL}
is resolved relative to ?_{BASE} and a new url record is returned with
the appropriate fileds filled in.
	  <entry/<code/URL.normalizePath//
	  <synopsis/<code/{URL.normalizePath ?+{L1} ??{L2}}//
	  <item>Given a list ?_{L1} of pairs of the form
<code/?{STRING}#?{BOOLEAN}/ (see <code/path/ feature of a url record),
returns a list ?_{L2} that results from normalizing ?_{L1}.
Normalization is the process of eliminating occurrences of path
components <file/./ and <file/../ by interpreting them relative to the
stack of path components.  A leading <file/./ is preserved because
<file>./foo</file> and <file/foo/ should be treated differently: the
first one is an absolute path anchored in the current directory,
whereas the second one is relative.
	  <entry/<code/URL.isAbsolute//
	  <entry/<code/URL.isRelative//
	  <synopsis/<code/{URL.isAbsolute ?+{X} ??{B}}//
	  <synopsis/<code/{URL.isRelative ?+{X} ??{B}}//
	  <item>A url is considered absolute if (1) it has a
<code/scheme/, or (2) it has a <code/device/, or (3) its <code/path/
started with <samp>/</samp>, <samp/~/ (user home directory notation),
<samp/./ (current directory), or <samp/../ (parent directory).  For
example, <file>~rob/foo/baz</file> is abolute.
	  <entry/<code/URL.toBase//
	  <synopsis/<code/{URL.toBase ?+{X} ??{Url}}//
	  <item>Turns a url vstring or record into a url record that
can safely be used as a base for <code/URL.resolve/ without loosing
its last component.  Basically, it makes sure that there is a slash at
the end.
    </list>
  </Chapter>

<!--
Local Variables:
mode: sgml
mode: auto-fill
sgml-default-dtd-file: "part.ced"
sgml-auto-activate-dtd: t
adaptive-fill-mode: nil
End:
-->
