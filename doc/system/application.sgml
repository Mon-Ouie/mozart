<!--
  - Authors:
  -   Denys Duchier     <duchier@ps.uni-sb.de>
  -   Leif Kornstaedt <kornstae@ps.uni-sb.de>
  -   Christian Schulte <schulte@dfki.de>
  -
  - Copyright:
  -   Denys Duchier, 1998
  -   Leif Kornstaedt, 1998
  -   Christian Schulte, 1998
  -
  - Last change:
  -   $Date$ by $Author$
  -   $Revision$
  -
  - This file is part of Mozart, an implementation
  - of Oz 3
  -    http://mozart.ps.uni-sb.de
  -
  - See the file "LICENSE" or
  -    http://mozart.ps.uni-sb.de/LICENSE.html
  - for information on usage and redistribution
  - of this file, and for a DISCLAIMER OF ALL
  - WARRANTIES.
  -
  -->

<Chapter id="Chapter.Application">
  <Title/Application Programming/

  <Section id="Section.Application.Application">
    <Title/Application Support: <<Application>>/
  </Section>

  <Section id="Section.Application.Module">
    <Title/Module Managers: <<Module>>/

    <P>
      Module managers load pickled functors, link the obtained
      functors, and execute them and return modules obtained by
      functor execution. The Mozart virtual machine starts with a
      single module manager that executes the functor to which the
      virtual machine is applied. The module <<Module>> provides a
      class from which new module managers can be created.
    </P>

    <Subsection id="Section.Application.Module.Basic">
      <Title/Module Tables/

      <P>
        A module manager maintains a module table, that maps URLs to
        modules or futures. The URL identifies the functor that has
        been used (or that will be used, in case of a future) to
        compute the module.
      </P>
 
      <P>
        Linking a functor takes a URL ?_{U} as input and returns a
        module ?_{M} (or a future to the module) as output. If the
        module manager already has an entry for 
        ?_{U} in its module table, it just returns this
        entry. Otherwise, it creates a future ?_{MF}, stores this
        future in the module table, and returns that future.
      </P>

      <P>
        As soon as the future's value gets requested, the module
        identified by ?_{U} is <Em/installed/ as follows. The pickled
        functor stored at URL ?_{U} gets loaded and applied to its
        argument modules. The future then is bound to the computed
        modules. 
      </P> 
       
      <P> 
        A module manager is implemented as an instance of the class
        <<Module.manager>>. The class provides methods to link and
        apply functors and to enter first class modules into the
        module manager's module table.
      </P>

      <P>
        The behaviour of a module manager as it comes to loading
        pickled functors can be refined and customized by creating
        classes by inheritance that refine particular methods.
      </P>

    </Subsection>

    <Subsection id="Section.Application.Modules.Names">
      <Title/Module Names and URLs/

      <P>
        As has been explained above, each module is refered to by a
        URL, some of which are Oz specific in that they refer to
        system modules. We just say that the module <Em/has the URL/. 
      </P>

      <P>
        A <Em/module name/ is a shortcut
        for a module URL. System module or extension appended.
      </P>

    </Subsection>

    <Subsection id="Section.Application.Modules.Link">
      <Title/Using Module Managers/

      <P>
        <List>
          <Entry><Span class=index/<<link>>/
	    <Index/<<Module>><And><<manager>><And><<link>>/
          <Synopsis>
	    <<<link(url:?+{UrlV} ?_{ModuleR} <= _)>>>
	    <<<link(name:?+{NameV} ?_{ModuleR} <= _)>>>
          <Item>
            Links the module identified either by a url ?_{UrlV} (a
            virtual string) or a module name ?_{NameV} (a virtual
            string). Returns the module ?_{ModuleR}, if it has been
            already linked or a future to it.
          <P>
            The argument for the module is optional, if it is omitted
            the module is requested immediately.

          <Entry><Span class=index/<<apply>>/
	    <Index/<<Module>><And><<manager>><And><<apply>>/
          <Synopsis>
	    <<<link(url:?+{UrlV} ?+{Functor} ?_{ModuleR} <= _)>>>
	    <<<link(name:?+{NameV} ?+{Functor} ?_{ModuleR} <= _)>>>
          <Item>
            Applies the functor ?_{Functor}, where the url ?_{UrlV} (a
            virtual string) or the module name ?_{NameV} (a virtual
            string) serve as base URL for linking the functor's
            import.
          <P>
            The argument for the module is optional.
          <P>
            Please note that the resulting module is <Em/not/ added to
            the module table, the URL argument only serves as base URL
            for the functor's import.

          <Entry><Span class=index/<<enter>>/
	    <Index/<<Module>><And><<manager>><And><<enter>>/
          <Synopsis>
	    <<<link(url:?+{UrlV} ?_{ModuleR})>>>
	    <<<link(name:?+{NameV} ?_{ModuleR})>>>
          <Item>
            Installs the module ?_{ModuleR} under the url ?_{UrlV} (a
            virtual string) or the module name ?_{NameV} (a virtual
            string).
          <P>
            Raises an exception if the module manager already has a
            module under that particular URL installed.
        </List>
       </P>         
    </Subsection>

    <Subsection id="Section.Application.Modules.Example">
      <Title/An Example/
    </Subsection>

    <Subsection id="Section.Application.Modules.Inherit">
      <Title/Customizing Module Managers/

    </Subsection>

  </Section>

</Chapter>
