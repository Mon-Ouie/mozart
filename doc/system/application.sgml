<!--
  - Authors:
  -   Denys Duchier     <duchier@ps.uni-sb.de>
  -   Leif Kornstaedt <kornstae@ps.uni-sb.de>
  -   Christian Schulte <schulte@dfki.de>
  -
  - Copyright:
  -   Denys Duchier, 1998
  -   Leif Kornstaedt, 1998
  -   Christian Schulte, 1998
  -
  - Last change:
  -   $Date$ by $Author$
  -   $Revision$
  -
  - This file is part of Mozart, an implementation
  - of Oz 3
  -    http://mozart.ps.uni-sb.de
  -
  - See the file "LICENSE" or
  -    http://mozart.ps.uni-sb.de/LICENSE.html
  - for information on usage and redistribution
  - of this file, and for a DISCLAIMER OF ALL
  - WARRANTIES.
  -
  -->

<Chapter id="Chapter.Application">
  <Title/Application Programming/

  <p>Now there is a bloody lot of content.

  <Section id="Section.Application.Application">
    <Title/Application Support: <<Application>>/
  </Section>

  <Section id="Section.Application.Module">
    <Title/Module Managers: <<Module>>/

    <P>
      Module managers allow to link and execute applications composed
      of functors. When an Oz application starts it starts with a module
      mananager that executes the application's functor.
    </P>

    <Subsection id="Section.Application.Module.Basic">
      <Title/Module Tables/

      <P>
        A module manager maintains a module table, that maps URLs to
        modules. A new entry to the managers module table is created
        by linking a functor.
      </P>
 
      <P>
        Linking a functor takes a URL ?_{U} as input and returns a
        module ?_{M} (or a future to the module, as will be discussed
        later) as output. If the module manager has an entry ?_{M} for
        ?_{U} in its module table, it just returns this
        entry. Otherwise, it creates a future ?_{M}, stores this
        future in the module table, and returns that future.
      </P>

      <P>
        As soon as the future's value gets requested, the pickled
        functor stored at URL ?_{U} gets loaded and applied to its
        import modules obtained by linking. The module table ensures
        that a functor is applied at most once.
      </P> 
       
      <P> 
        A module manager is implemented as an instance of the class
        <<Module.manager>>. The class provides methods to link and
        apply functors and to enter first class modules into the
        module manager's module table.
      </P>

      <P>
        The behaviour of a module manager as it comes to loading
        pickled functors can be refined and customized by creating
        classes by inheritance that refine particular methods.
    </Subsection>

    
    <Subsection id="Section.Application.Modules.Link">
      <Title/Using Module Managers/

      <P>
        Module managers are instances of the class <<Module.manager>>
        which provides the following methods.
      </P>

      <P>
        <List>
          <Entry><Span class=index/<<offer>>/
	    <Index/<<Connection>><And><<offer>>/
          <Synopsis>
	    <<{Connection.offer ?_{X} ?_{TicketA}}>>
          <Item>
            Returns the single-shot ticket ?_{TicketA} (an atom)
            under which the value ?_{X} is offered.
          <P>
            The value ?_{X} is exported immediately. An exception is
            raised, if exportation of ?_{X} fails, because ?_{X}
            refers to sited entities.

      </List>
         
    </Subsection>

    <Subsection id="Section.Application.Modules.Inherit">
      <Title/Customizing Module Managers/

    </Subsection>

  </Section>

</Chapter>
