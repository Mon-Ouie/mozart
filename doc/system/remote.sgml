<!--
  - Authors:
  -   Christian Schulte <schulte@ps.uni-sb.de>
  -
  - Copyright:
  -   Christian Schulte, 1998
  -
  - Last change:
  -   $Date$ by $Author$
  -   $Revision$
  -
  - This file is part of Mozart, an implementation
  - of Oz 3
  -    http://mozart.ps.uni-sb.de
  -
  - See the file "LICENSE" or
  -    http://mozart.ps.uni-sb.de/LICENSE.html
  - for information on usage and redistribution
  - of this file, and for a DISCLAIMER OF ALL
  - WARRANTIES.
  -
  -->

  <Chapter id="Chapter.Remote">
    <Title/Spawning Computations Remotely: <<Remote>>/

    <P>
      The module <<Remote>> provides the class <<Remote.manager>> by
      which new Oz processes on arbitrary networked computers that
      also have Mozart installed can be created. Creating an instance of
      that class does the following two things:
      <List>
        <Item> A new Oz process with a module manager ?_{M} is
               created on a networked computer.
        <Item> The newly created object ?_{O} serves as a proxy to
               ?_{M}. ?_{O} is called a <def/remote module
               manager/. This allows to start applications remotely
               that access remote resources by local system modules.
      </List>
    </P>

    <P>
      The methods of the class <<Remote.manager>> are as follows.
    </P>

    <P>
      <List>
        <Entry><Span class=index/<<init>>/
          <Index/<<Remote>><And><<manager>><And><<init>>/
        <Synopsis>
<code display/init(host:   ?+{HostV}   <= localhost
     fork:   ?+{ForkA}   <= automatic
     detach: ?+{DetachB} <= false)/
        <Item>
          Creates a new Oz process at the computer with host name
          ?_{HostV} (specified by a virtual
          string), where <<localhost>> is the computer running the
          current Oz process.

        <P>
          ?_{ForkA} (an atom) determines the operating system method
          to fork the remote Oz process. Currently, <<'automatic'>>,
          <<'sh'>>, and <<'rsh'>> are supported. <<'automatic'>> is
          the default method.

        <p>
          <<'rsh'>> creates
          a shell remotely by using the Unix <code
          proglang=sh>rsh</code> command, which in turn creates the
          new Oz engine.

        <para class=apropos proglang=sh><title/<code proglang=sh/rsh/ configuration/
          Remote managers with method <<rsh>> only work properly, if
          the <<rsh>> command has been set up properly. You can test it for
          the host ?{Host} by executing the following command in the
          operating system shell:
          <<<rsh ?{Host} ozengine x-oz://system/RemoteServer.ozf --test>>>
          If the message
          <code display proglang=fundamental>Remote: Test succeeded...</code>
          is printed, your configuration is okay. This requires
          two things:
          <list enum>
            <item>
               Execution of <<rsh ?{Host}>> must not prompt for a
               password. This is usually achieved by having a special
               file <file/.rhosts/ in your home directory. Each entry
               in that file must be a host name. For those hosts
               having an entry in that file, <<rsh>> does not prompt for a
               password.

              <p>
               Take the following sample <file/.rhosts/ file at the computer <<wallaby.ps.uni-sb.de>>:
<code display proglang=none>
godzilla.ps.uni-sb.de
bamse.sics.se
</code>
               If <<rsh wallaby.ps.uni-sb.de>> is executed on
               <<bamse.sics.se>> or <<godzilla.ps.uni-sb.de>>, then
               <<rsh>> does not prompt for a password.

              <p>
               With other words, all host names that you ever want to
               use with <<Remote.manager>> should be in <file/.rhosts/.

            <item>
               After the login performed by <<rsh>> the
               command <<ozengine>> must be
               executable. This should be always the case, if Mozart
               has been installed properly on your computer. This in
               particular requires that <<$OZHOME/bin>> is in your path of
               executables (<<$OZHOME>> refers to the directory where
               Mozart has been installed).
          </list>

        <para class=apropos proglang=sh><title/<<sh>> configuration/
          <<'sh'>> can only be used, if ?_{HostV} is <<localhost>>. It
          creates a new Oz engine by using the Unix <code
          proglang=sh>sh</code> command. You can test whether this
          method works on your computer by:
          <<<sh -c 'ozengine x-oz://system/RemoteServer.ozf --test'>>>
          This should be always the case, if Mozart
          has been installed properly on your computer. This in
          particular requires that <<$OZHOME/bin>> is in your path of
          executables (<<$OZHOME>> refers to the directory where
          Mozart has been installed).

        <P>
          If ?_{HostV} is <<'localhost'>> and ?_{ForkA} is
          <<'automatic'>> (which is the default), then on some
          platforms the forked and forking processes communicate over
          shared memory instead of Unix sockets, which is more
          efficient. The system property
          <<'distribution.virtualsites'>> carries a boolean telling
          whether this facility, called <def/virtual sites/, is
          supported in the runnung Mozart process; the <<'sh'>> fork
          method is used as a fall-back.

<p class=danger>
          On some platforms (notably on <<solaris-sparc>>) the
          operating system in its default configuration does not allow
          to exploit the virtual sites facility efficiently. Namely,
          the Solaris OS limits the total number of shared memory
          pages per process to 6 and the number of shared memory pages
          system-wide to 100, while each of connected Mozart processes
          requires at least 2 of them for efficient communication.
          Please ask the system administrator to increase those limits
          with respect to your needs.

<p class=danger>
          The Mozart system tries to do its best to reclaim shared
          memory identifiers, even upon process crashes, but it is
          still possible that some shared memory pages become
          unaccounted and thus stay forever in the OS. In these cases
          please use Unix utilities (on Solaris and Linux these are
          <<ipcs>> and <<ipcrm>>) to get rid of them.

        <P>
          If ?_{DetachB} is <<false>>, a non-detached process is
          created. A non-detached process terminates as soon as
          the creating process does (think of crashes, there will be
          no orphaned processes). The lifetime of a detached process
          (that is, ?_{DetachB} is <<true>>) is independent of the
          creating process.

        <Entry><Span class=index/<<link>>/
          <Index/<<Remote>><And><<manager>><And><<link>>/
        <Synopsis>
            <code display/link(url:?+{UrlV} ?_{ModuleR} <= _)/
            <code display/link(name:?+{NameV} ?_{ModuleR} <= _)/
        <Item>
            Links the module identified either by a url ?_{UrlV} (a
            virtual string) or a module name ?_{NameV} (a virtual
            string). Returns a module ?_{ModuleR}.
          <p>
            For explanation see <ptr
            to="chapter.module">.

          <Entry><Span class=index/<<apply>>/
            <Index/<<Remote>><And><<manager>><And><<apply>>/
          <Synopsis>
            <code display/apply(?+{Functor} ?_{ModuleR} <= _)/
            <code display/apply(url:?+{UrlV} ?+{Functor} ?_{ModuleR} <= _)/
            <code display/apply(name:?+{NameV} ?+{Functor} ?_{ModuleR} <= _)/
          <Item>
            Applies the functor ?_{Functor}, where the url ?_{UrlV} (a
            virtual string) or the module name ?_{NameV} (a virtual
            string) serve as base url for resolving the functor's
            import.
          <p>
            For explanation see <ptr
            to="chapter.module">.

          <Entry><Span class=index/<<enter>>/
            <Index/<<Remote>><And><<manager>><And><<enter>>/
          <Synopsis>
            <code display/enter(url:?+{UrlV} ?_{ModuleR})/
            <code display/enter(name:?+{NameV} ?_{ModuleR})/
          <Item>
            Installs the module ?_{ModuleR} under the url ?_{UrlV} (a
            virtual string) or the module name ?_{NameV} (a virtual
            string).
          <p>
            For explanation see <ptr
            to="chapter.module">.

          <Entry><Span class=index/<<ping>>/
            <Index/<<Remote>><And><<manager>><And><<ping>>/
          <Synopsis>
            <code display/ping()/
          <Item>
           Raises exception if remote process is dead. Blocks until
           executed by remote process.

          <Entry><Span class=index/<<close>>/
            <Index/<<Remote>><And><<manager>><And><<close>>/
          <Synopsis>
            <code display/close()/
          <Item>
            Performs a controlled shutdown of all remote processes
            (for a discussion of controlled shutdown see <ptr.extern
to="ozdoc:dstutorial" key="section.distmodel.shutdown">).

        </List>
       </P>


  </Chapter>

<!--
Local Variables:
mode: sgml
mode: auto-fill
sgml-default-dtd-file: "part.ced"
sgml-auto-activate-dtd: t
adaptive-fill-mode: nil
End:
-->
