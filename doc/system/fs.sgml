<!--
  - Authors:
  -  Tobias Müller <tmueller@ps.uni-sb.de>
  -
  - Copyright:
  -  Tobias Müller, 1998
  -
  - Last change:
  -   $Date$ by $Author$
  -   $Revision$
  -
  - This file is part of Mozart, an implementation
  - of Oz 3
  -    http://www.mozart-oz.org
  -
  - See the file "LICENSE" or
  -    http://www.mozart-oz.org/LICENSE.html
  - for information on usage and redistribution
  - of this file, and for a DISCLAIMER OF ALL
  - WARRANTIES.
  -
  -->

<Chapter id="chapter.fs">
  <Title/Finite Set Constraints: <<GFS>>/

<p>
The procedures in this module have the following properties. 

<p>
To get an unified call interface for propagators, all propagator
posting functions take only a record as argument. This record
contains all the parameters needed to call the propagator.

<p>
We use the following notation for operations and relations on sets.  We
write&nbsp;<math/\cup, \cap/, and <math/\backslash/ for set union, intersection, and
difference, <math/\subseteq/ and <math/\|/ for inclusion and disjointness, <math/\#/
for the set cardinality, and <math/\in/ for the element relation.
Furthermore, we write <math/\emptyset/ and <math/\uniset/ for the empty set and the
universal set.
<p>

For every set specification ?{Spec} we write the set ?{M}
specified by ?{Spec} as ?{M} = <math/
~$
\newcommand{\sic}[2]{\mbox{$[#1,#2]$}}
\newcommand{\conv}{{\it set}}
\newcommand{\convinv}{{\it set}^{-1}}
 
~$~
\conv({Spec})/.  For example,
<math/\conv(\mbox{\codeinline{oz}{[1\#3 5 7]}})/ denotes <math/\{1,2,3,5,7\}/. Further, for
every set <<S>> we denote with <math/{D} = \convinv({S})/ a set
description ?{D} such that <math/\conv({\tt D}) = {\tt S}/.

<para><title/Relation symbols/
There are propagator posting procedures that take an argument <<Rt>> to denote 
an arithmetic relation <math/\sim_{Rt}/. The possible values and the associated 
relations are summarized below. 
<table>
<tr><td/<<GFS.rt.'=:'>>/ <td> Equality (<math>=</math>)</td></tr>
<tr><td/<<GFS.rt.'\\=:'>>/ <td> Disequality (<math>\neq</math>)</td></tr>
<tr><td/<<GFS.rt.'<:'>>/ <td> SubSet (<math>\leq</math>)</td></tr>
<tr><td/<<GFS.rt.'>:'>>/ <td> SuperSet (<math><</math>)</td></tr>
<tr><td/<<GFS.rt.'||:'>>/ <td> Disjoin ( <math>\|</math> )</td></tr>
<!--<tr><td/<<GFS.rt.'^:'>>/ <td> Complement (<math>^</math>)</td></tr>-->
<tr><td/<<GFS.rt.'^:'>>/ <td> Complement </td></tr>
</table>

<para><title/Lazy propagation/
When a propagator is posted in a computation space it does not performs any
domain pruning. This behavior allows the implementation of batch recomputation 
enabled search engines (REF paper). Lazy propagation is only acheved in sub-spaces, it is, when on toplevel propagation is performe eagerly. To perform propagation in a sub-space you have to ask the space to do so by calling <<Space.ask>>.

<p>
For more information on the finite set constraint system
see&nbsp;<ptr to=MuellerMueller.WLP.97>.

<!-- ********************************************************************** -->
<section id="section.fs.genral"><title/Finite Set Intervals/
<p>
<list>

<entry>
<index class=module/GFS<and>inf<and>id/
<<inf>>
<synopsis>
<<<GFS.inf
>>>
<item>
An integer constant that denotes the smallest possible element of a
set. Constant value: ~2 147 483 646.

<entry>
<index class=module/GFS<and>sup<and>id/
<<sup>>
<synopsis>
<<<GFS.sup
>>>
<item>
An integer constant that denotes the greatest possible element of a
set. Constant value: ~2 147 483 646.

<entry>
<index class=module/GFS<and>compl<and>id/
<<compl>>
<synopsis>
<<<{GFS.compl $M1 $M2}
>>>
<item>
<math/\codeinline{oz}{M2} = \{\codeinline{oz}{GFS.inf},\ldots,\codeinline{oz}{GFS.sup}\}\setminus \codeinline{oz}{M1}/

<entry>
<index class=module/GFS<and>complIn<and>id/
<<complIn>>
<synopsis>
<<<{GFS.complIn $M1 $M2 $M3}
>>>
<item>
<math/\codeinline{oz}{M3} = \codeinline{oz}{M2} \setminus \codeinline{oz}{M1}/


<entry>
<index class=module/GFS<and>include<and>id/
<<include>>
<synopsis>
<<<{GFS.include +D *M}
>>>
<item>
<math/\codeinline{oz}{D} \in \codeinline{oz}{M} \wedge \codeinline{oz}{GFS.inf} \le \codeinline{oz}{D} \le \codeinline{oz}{GFS.sup}/

<entry>
<index class=module/GFS<and>exclude<and>id/
<<exclude>>
<synopsis>
<<<{GFS.exclude +D *M}
>>>
<item>
<math/\codeinline{oz}{D} \notin \codeinline{oz}{M}/

<entry>
<index class=module/GFS<and>card<and>id/
<<card>>
<synopsis>
<<<{GFS.card *M ?D}
>>>
<item>
<math/\codeinline{oz}{D} = \# {M}/

<entry>
<index class=module/GFS<and>cardRange<and>id/
<<cardRange>>
<synopsis>
<<<{GFS.cardRange +I1 +I2 *M}
>>>
<item>
<math/\codeinline{oz}{I1} \le \# {M} \le {I2}/

<entry>
<index class=module/GFS<and>isIn<and>id/
<<isIn>>
<synopsis>
<<<{GFS.isIn +I *M ?B}
>>>
<item>
<math/(\codeinline{oz}{E} \in \codeinline{oz}{M}) \rightarrow \codeinline{oz}{B}/

<!--<entry>
<index class=module/GFS<and>makeWeights<and>id/
<<makeWeights>>
<synopsis>
<<<{GFS.makeWeights +SpecW ?P}
>>>
<item>
Returns a procedure with signature <<{P +I1 ?I2>>}. This procedure
maps an element to a weight according to the weight description passed
to <<GFS.makeWeights>>. -->

</list>
</section>

<!-- ********************************************************************** -->
<!--
<section id="section.fs.integers"><title/Sets over Integers/
<p>
<list>

<entry>
<index class=module/FS<and>int<and>min/
<<int.min>>
<synopsis>
<<<{FS.int.min *M $D}
>>>
<item>
<<D>> is the minimal element within <<M>>. 
   

<entry>
<index class=module/FS<and>int<and>max/
<<int.max>>
<synopsis>
<<<{FS.int.max *M $D}
>>>
<item>
<<D>> is the maximal element within <<M>>. 
   

<entry>
<index class=module/FS<and>int<and>convex/
<<int.convex>>
<synopsis>
<<<{FS.int.convex *M}
>>>
<item>
Whenever <<I1>> and <<I2>> are elements of <<M>>, then 
every <<I>> between <<I1>> and <<I2>>, <<I1 < I < I2>>, 
is also in <<M>>.

<entry>
<index class=module/FS<and>int<and>match/
<<int.match>>
<synopsis>
<<<{FS.int.match *M *Dv}
>>>
<item>
<<Dv>> is a vector of integer variables that denotes the elements of
<<M>> in ascending order.

<entry>
<index class=module/FS<and>int<and>minN/
<<int.minN>>
<synopsis>
<<<{FS.int.minN *M *Dv}
>>>
<item>
<<Dv>> is a vector of ?{n} integer variables that denotes the ?{n}
minimal elements of <<M>> in ascending order.

<entry>
<index class=module/FS<and>int<and>maxN/
<<int.maxN>>
<synopsis>
<<<{FS.int.maxN *M *Dv}
>>>
<item>
<<Dv>> is a vector of ?{n} integer variables that denotes the ?{n}
maximal 
elements of <<M>> in ascending order.

<entry>
<index class=module/FS<and>int<and>seq/
<<int.seq>>
<synopsis>
<<<{FS.int.seq *Mv}
>>>
<item>
<<Mv>> is a vector of disjoint sets such that for distinct sets
<<M1>> and <<M2>>, where <<M1>> precedes <<M2>> in <<Mv>>, all
elements of <<M1>> are smaller than any element of <<M2>>.
</list>
</section>
-->
<!-- ********************************************************************** -->
<section id="section.fs.standard"><title/Standard Propagators/
<p>
<list>

<entry>
<index class=module/GFS<and>diff<and>id/
<<diff>>
<synopsis>
<<<{GFS.diff $M1 $M2 $M3}
>>>
<item>
<math/\codeinline{oz}{M3} = \codeinline{oz}{M1} \setminus \codeinline{oz}{M2}/

<entry>
<index class=module/GFS<and>intersect<and>id/
<<intersect>>
<synopsis>
<<<{GFS.intersect $M1 $M2 $M3}
>>>
<item>
<math/\codeinline{oz}{M3} = \codeinline{oz}{M1} \cap \codeinline{oz}{M2}/

<entry>
<index class=module/GFS<and>intersectN<and>id/
<<intersectN>>
<synopsis>
<<<{GFS.intersectN *Mv *M}
>>>
<item>
<math/\codeinline{oz}{M} = \bigcap \{ \codeinline{oz}{M'} \mid \codeinline{oz}{M'} \in \codeinline{oz}{Mv}\}/

<entry>
<index class=module/GFS<and>union<and>id/
<<union>>
<synopsis>
<<<{GFS.union $M1 $M2 $M3}
>>>
<item>
<math/\codeinline{oz}{M3} = \codeinline{oz}{M1} \cup \codeinline{oz}{M2}/

<entry>
<index class=module/GFS<and>unionN<and>id/
<<unionN>>
<synopsis>
<<<{GFS.unionN $Mv $M}
>>>
<item>
<math/\codeinline{oz}{M} = \bigcup \{ \codeinline{oz}{S} \mid \codeinline{oz}{S} \in \codeinline{oz}{Mv}\}/

<entry>
<index class=module/GFS<and>subset<and>id/
<<subset>>
<synopsis>
<<<{GFS.subset $M1 $M2}
>>>
<item>
<math/\codeinline{oz}{M1} \subseteq \codeinline{oz}{M2}/

<entry>
<index class=module/GFS<and>disjoint<and>id/
<<disjoint>>
<synopsis>
<<<{GFS.disjoint $M1 $M2}
>>>
<item>
<math/\codeinline{oz}{M1} \| \codeinline{oz}{M2}/

<entry>
<index class=module/GFS<and>disjointN<and>id/
<<disjointN>>
<synopsis>
<<<{GFS.disjointN *Mv}
>>>
<item>
All elements of the vector ?{Mv} are pairwise disjoint. 

<entry>
<index class=module/GFS<and>distinct<and>id/
<<distinct>>
<synopsis>
<<<{GFS.distinct $M1 $M2}
>>>
<item>
<math/\codeinline{oz}{M1} \neq \codeinline{oz}{M2}/

<entry>
<index class=module/GFS<and>distinctN<and>id/
<<distinctN>>
<synopsis>
<<<{GFS.distinctN *MV}
>>>
<item>
All elements of the vector ?{Mv} are pairwise distinct. 

<entry>
<index class=module/GFS<and>partition<and>id/
<<partition>>
<synopsis>
<<<{GFS.partition $MV $M}
>>>
<item>
?{Mv} is a partition of ?{M}; that is, 
?{Mv} contains pairwise disjoint sets such that their 
union yields ?{M}. 
</list>
</section>

<!-- ********************************************************************** -->
<section id="section.fs.vars"><title/Finite Set Interval Variables/
<p>
<list>

<entry>
<index class=module/GFS<and>var<and>is/
<<var.is>>
<synopsis>
<<<{GFS.var.is +M ?B}
>>>
<item>
Tests whether <<M>> is a finite set variable.
</list>
<subsection><title/Declaring a Single Variable/
<p>
<list>

<entry>
<index class=module/GFS<and>var<and>decl/
<<var.decl>>
<synopsis>
<<<{GFS.var.decl ?M}
>>>
<item>
<math/\emptyset \subseteq {\tt M} \subseteq \uniset/

<entry>
<index class=module/GFS<and>var<and>upperBound/
<<var.upperBound>>
<synopsis>
<<<{GFS.var.upperBound +Spec ?M}
>>>
<item>
<math/\emptyset \subseteq \codeinline{oz}{M} \subseteq \conv(\codeinline{oz}{Spec})/

<entry>
<index class=module/GFS<and>var<and>lowerBound/
<<var.lowerBound>>
<synopsis>
<<<{GFS.var.lowerBound +Spec ?M}
>>>
<item>
<math/\conv({\tt Spec}) \subseteq \codeinline{oz}{M} \subseteq \uniset/

<entry>
<index class=module/GFS<and>var<and>bounds/
<<var.bounds>>
<synopsis>
<<<{GFS.var.bounds +Spec1 +Spec2 ?M}
>>>
<item>
<math/\conv({\tt Spec1}) \subseteq {\tt M} \subseteq \conv({\tt Spec2})/
</list>
</subsection>
<subsection><title/Declaring a List of Variables/
<p>
The following functions return a list <<Ms>> of length <<I>>
and all its elements are constrained to finite set interval variables
according to the following specifications.
<list>

<entry>
<index class=module/GFS<and>var<and>list<and>decl/
<<var.list.decl>>
<synopsis>
<<<{GFS.var.list.decl +I ?Ms}
>>>
<item>
For all elements <<M>> of <<Ms>>: 
<math/\emptyset \subseteq \codeinline{oz}{M} \subseteq \uniset/

<entry>
<index class=module/GFS<and>var<and>list<and>upperBound/
<<var.list.upperBound>>
<synopsis>
<<<{GFS.var.list.upperBound +I +Spec ?Ms}
>>>
<item>
For all elements <<M>> of <<Ms>>: 
<math/\emptyset \subseteq \codeinline{oz}{M} \subseteq
\conv({\tt Spec})/

<entry>
<index class=module/GFS<and>var<and>list<and>lowerBound/
<<var.list.lowerBound>>
<synopsis>
<<<{GFS.var.list.lowerBound +I +Spec ?Ms}
>>>
<item>
For all elements <<M>> of <<Ms>>: 
<math/\conv(\codeinline{oz}{Spec}) \subseteq \codeinline{oz}{M}\subseteq \uniset/

<entry>
<index class=module/GFS<and>var<and>list<and>bounds/
<<var.list.bounds>>
<synopsis>
<<<{GFS.var.list.bounds +I +Spec1 +Spec2 ?Ms}
>>>
<item>
For all elements <<M>> of <<Ms>>: 
<math/\conv({\tt Spec1})\subseteq
{\tt M}\subseteq \conv({\tt Spec2})/
</list>
</subsection>

<subsection><title/Declaring a Tuple of Variables/
<p>
The following functions return a tuple <<Mt>> with label <<L>>
and width <<I>> and all its elements are constrained to finite set
interval variables according to the following specifications.
<list>

<entry>
<index class=module/GFS<and>var<and>tuple<and>decl/
<<var.tuple.decl>>
<synopsis>
<<<{GFS.var.tuple.decl +L +I ?Mt}
>>>
<item>
For all elements <<M>> of <<Mt>>: 
<math/\emptyset \subseteq {\tt M} \subseteq
\uniset/

<entry>
<index class=module/GFS<and>var<and>tuple<and>upperBound/
<<var.tuple.upperBound>>
<synopsis>
<<<{GFS.var.tuple.upperBound +L +I +Spec ?Mt}
>>>
<item>
For all elements <<M>> of <<Mt>>: 
<math/\emptyset \subseteq \codeinline{oz}{M} \subseteq
\conv({\tt Spec})/

<entry>
<index class=module/GFS<and>var<and>tuple<and>lowerBound/
<<var.tuple.lowerBound>>
<synopsis>
<<<{GFS.var.tuple.lowerBound +L +I +Spec ?Mt}
>>>
<item>
For all elements <<M>> of <<Mt>>: 
<math/\conv(\codeinline{oz}{Spec}) \subseteq
\codeinline{oz}{M}\subseteq \uniset/

<entry>
<index class=module/GFS<and>var<and>tuple<and>bounds/
<<var.tuple.bounds>>
<synopsis>
<<<{GFS.var.tuple.bounds +L +M +Spec1 +Spec2 ?Mt}
>>>
<item>
For all elements <<M>> of <<Mt>>: <math/\conv({\tt Spec1})\subseteq
{\tt M}\subseteq \conv({\tt Spec2})/
</list>
</subsection>

<subsection><title/Declaring a Record of Variables/
<p>
The following functions return a record <<Mr>> with label <<L>>
and the fields <<Ls>> and all its fields are constrained to finite set
interval variables according to the following specifications.
<list>

<entry>
<index class=module/GFS<and>var<and>record<and>decl/
<<var.record.decl>>
<synopsis>
<<<{GFS.var.record.decl +L +Ls ?Mr}
>>>
<item>
For all elements <<M>> of <<Mr>>: 
<math/\emptyset \subseteq {\tt M} \subseteq
\uniset/

<entry>
<index class=module/GFS<and>var<and>record<and>upperBound/
<<var.record.upperBound>>
<synopsis>
<<<{GFS.var.record.upperBound +L +Ls +Spec ?Mr}
>>>
<item>
For all elements <<M>> of <<Mr>>: 
<math/\emptyset \subseteq \codeinline{oz}{M} \subseteq
\conv({\tt Spec})/

<entry>
<index class=module/GFS<and>var<and>record<and>lowerBound/
<<var.record.lowerBound>>
<synopsis>
<<<{GFS.var.record.lowerBound +L +Ls +Spec ?Mr}
>>>
<item>
For all elements <<M>> of <<Mr>>: 
<math/\conv(\codeinline{oz}{Spec}) \subseteq
\codeinline{oz}{M}\subseteq \uniset/

<entry>
<index class=module/GFS<and>var<and>record<and>bounds/
<<var.record.bounds>>
<synopsis>
<<<{GFS.var.record.bounds +L +Ls +Spec1 +Spec2 ?Mr}
>>>
<item>
For all elements <<M>> of <<Mr>>: <math/{\tt M} \in
\sic{\conv({\tt Spec1})}{\conv({\tt Spec2})}/
</list>
</subsection>
</section>

<!-- ********************************************************************** -->
<section id="section.fs.consts"><title/Finite Set Constants/
<p>
<list>
<!--
<entry>
<index class=module/FS<and>value<and>empty/
<<value.empty>>
<synopsis>
<<<FS.value.empty
>>>
<item>
Denotes <math/\emptyset/.

<entry>
<index class=module/FS<and>value<and>universal/
<<value.universal>>
<synopsis>
<<<FS.value.universal
>>>
<item>
Denotes <math/\uniset/. 

<entry>
<index class=module/FS<and>value<and>singl/
<<value.singl>>
<synopsis>
<<<{FS.value.singl +I ?M}
>>>
<item>
<math/{\tt M} = \{{\tt I}\}/
-->
<entry>
<index class=module/GFS<and>value<and>make/
<<value.make>>
<synopsis>
<<<{GFS.value.make +Spec ?M}
>>>
<item>
<math/{\tt M} = \conv({\tt Spec})/
<!--
<entry>
<index class=module/FS<and>value<and>is/
<<value.is>>
<synopsis>
<<<{FS.value.is +M ?B}
>>>
<item>
Tests whether <<M>> is a finite set value or not.

<entry>
<index class=module/FS<and>value<and>toString/
<<value.toString>>
<synopsis>
<<<{FS.value.toString +M ?S}
>>>
<item>
Converts <<M>> to a string and returns it in <<M>>.
-->
</list>
</section>

<!-- ********************************************************************** -->
<section id="section.fs.dom"><title/Domain constraints/
<p>

<list>
<entry>
<index class=module/GFS<and>dom/
<<dom>>
<synopsis>
<<<
{GFS.dom ?*{PE}}
>>>
<item> Post a domain propagator according to the post especification ?_{PE}. ?_{PE} 
can be of the following forms:

<list class=enum>
<item> <<post(X Rt C)>>: Propagates <math> X \sim_{Rt} C </math>.
<item> <<post(X Rt L U)>>: Propagates <math> X \sim_{Rt} \{L,...,U\} </math>.
<item> <<post(X Rt S)>>: Propagates <math> X \sim_{Rt} S </math>, being <<S>> a domain 
specification.
<item> <<post(X Rt C B)>>:  Post propagator for <math> (X \sim_{Rt} C) \Leftrightarrow B </math>, 
being <<B>> a constraint boolean variable.
<item> <<post(X Rt L U B)>>:  Post propagator for <math> (X \sim_{Rt} \{L,...,U\}) \Leftrightarrow B </math>,
being <<B>> a constraint boolean variable.
<item> <<post(X Rt S B)>>:  Post propagator for <math> (X \sim_{Rt} S) \Leftrightarrow B </math>, 
being <<S>> a domain specification and <<B>> a constraint boolean variable.
<item> <<post(X L U)>>: Post propagator for <math> L\leq X \leq U </math>. 
</list>
</list>
</section>

<!-- ********************************************************************** -->

<section id="section.fs.rel"><title/Relation constraints/
<p>
There are propagator posting procedures that take an argument <<So>> to denote 
an operation/relation on sets. The possible operators are:
<table>
<tr><td/<<GFS.so.'unionOP'>>/ <td> Union </td></tr>
<tr><td/<<GFS.so.'disjointOP'>>/ <td> Disjoint Union </td></tr>
<tr><td/<<GFS.so.'intersectOP'>>/ <td> Intersection </td></tr>
<tr><td/<<GFS.so.'differenceOP'>>/ <td> Difference </td></tr>
</table>
<p>

<list>
<entry>
<index class=module/GFS<and>rel/
<<rel>>
<synopsis>
<<<
{GFS.rel ?*{PE}}
>>>
<item> Post a domain propagator according to the post especification ?_{PE}. ?_{PE} 
can be of the following forms:

<list class=enum>
<item> <<post(X Rt Y)>>: Post propagator for <math> X \sim_{Rt} Y </math>.
<item> <<post(X Rt Y B)>>:  Post propagator for <math> (X \sim_{Rt} Y) \Leftrightarrow B </math>, 
being <<B>> a constraint boolean variable.
<item> <<post(X Rt IV)>>: Post propagator for <math> X \sim_{Rt} IV </math>, 
being <<IV>> a finite domain variable.
<item> <<post(X Rt IV B)>>:  Post propagator for <math> (X \sim_{Rt} IV) \Leftrightarrow B </math>, 
being <<IV>> a finite domain variable and <<B>> a constraint boolean variable.
<item> <<post(X Irt IV)>>:  Post propagator for <math> |X| \geq 1</math> or <math>\forall i\in X : i \sim_{Irt} IV  </math>, 
being <<Irt>> a finite domain relation type and <<IV>> a finite domain variable.
</list>
<p>

<p>

<para><title/Set Operation-Relation Constraints/
<list class=enum>
<item> <<post(X So Y Rt Z)>>: Post propagator for <math> (X \diamond_{So} Y) \sim_{Rt} Z </math>.
<item> <<post(So Lx Y)>>: Post propagator for <math> Y =  \diamond_{So}Lx</math>.
<item> <<post(So Lx S Y)>>: Post propagator for <math> Y =  \diamond_{So}Lx \diamond_{So}S </math>.
<item> <<post(S So X Rt Y)>>: Post propagator for <math> (S \diamond_{So} X) \sim_{Rt} Y </math>.
</list>
-Faltan algunos, pero son la permutacion del anterior, que hacer?-


</list>
</section>

<!-- ********************************************************************** -->
<!--
<section id="section.fs.convex"><title/Convexity constraints/
<p>

<list>
<entry>
<index class=module/GFS<and>convex/
<<convex>>
<synopsis>
<<<
{GFS.convex ?*{PE}}
>>>
<item> Post a domain propagator according to the post especification ?_{PE}. ?_{PE} 
can be of the following forms:

<list class=enum>

</list>
</list>
</section>
-->
<!-- ********************************************************************** -->

<section id="section.fs.sequence"><title/Sequence Constraints/
<p>

<list>
<entry>
<index class=module/GFS<and>sequence/
<<sequence>>
<synopsis>
<<<
{GFS.sequence ?*{PE}}
>>>
<item> Post a domain propagator according to the post especification ?_{PE}. ?_{PE} 
can be of the following forms:

<list class=enum>
<item> <<post(Lx)>>: Post propagator for <math> \forall 0 \leq i \le |Lx| - 1</math>: <math>max(Lxi) \le min(Lxi + 1)</math>.
</list>

<entry>
<index class=module/GFS<and>sequentialUnion/
<<sequentialUnion>>
<synopsis>
<<<
{GFS.sequentialUnion ?*{PE}}
>>>
<item> Post a domain propagator according to the post especification ?_{PE}. ?_{PE} 
can be of the following forms:

<list class=enum>
<item> <<post(Lx Y)>>: Post propagator for <math> \forall 0 \leq i \le |Lx| - 1</math>: <math>max(Lxi) \le min(Lxi + 1)</math>
    and <math> Y = \bigcup_i \in \{0,...,n-1\} Lxi </math>
</list>
</list>
</section>

<!-- ********************************************************************** -->

<section id="section.fs.distinct"><title/Distinct constraints/
<p>

<list>
<entry>
<index class=module/GFS<and>distinct/
<<atmostOne>>
<synopsis>
<<<
{GFS.atmostOne ?*{PE}}
>>>
<item> Post a domain propagator according to the post especification ?_{PE}. ?_{PE} 
can be of the following forms:

<list class=enum>
<item> <<post(Lx C)>>: Post propagator for <math> \forall 0 \leq i \le |Lx| </math>: <math>|Lxi| = C</math> 
and <math> \forall 0 \leq i \le j \le |Lx| </math>: <math>|Lxi \cap Lxj| \leq 1</math>.
</list>
</list>
</section>

<!-- ********************************************************************** -->

<section id="section.fs.connection"><title/Connection constraints to finite domain variables/
<p>

<list>

<entry>
<index class=module/GFS<and>connection/
<<min>>
<synopsis>
<<<
{GFS.min ?*{PE}}
>>>
<item> Post a domain propagator according to the post especification ?_{PE}. ?_{PE} 
can be of the following forms:

<list class=enum>
<item> <<post(X IV)>>: Post propagator that propagates that <<IV>> is the minimal element of <<X>>, and that <<X>> is not empty. 
</list>

<entry>
<index class=module/GFS<and>connection/
<<max>>
<synopsis>
<<<
{GFS.max ?*{PE}}
>>>
<item> Post a domain propagator according to the post especification ?_{PE}. ?_{PE} 
can be of the following forms:

<list class=enum>
<item> <<post(X IV)>>: Post propagator that propagates that <<IV>> is the maximal element of <<X>>, and that <<X>> is not empty. 
</list>

<entry>
<index class=module/GFS<and>connection/
<<match>>
<synopsis>
<<<
{GFS.match ?*{PE}}
>>>
<item> Post a domain propagator according to the post especification ?_{PE}. ?_{PE} 
can be of the following forms:

<list class=enum>
  <item> <<post(X IVs)>>: Post propagator that propagates that <<X>> contains the <math>IVsi</math>, which are sorted in non-descending order. 
</list>

<entry>
<index class=module/GFS<and>connection/
<<channel>>
<synopsis>
<<<
{GFS.channel ?*{PE}}
>>>
<item> Post a domain propagator according to the post especification ?_{PE}. ?_{PE} 
can be of the following forms:

<list class=enum>
  <item> <<post(IVs SVs)>>: Post propagator for <math> IVsi = j \Leftrightarrow i \in SVsi  </math>,
beign <<IVs>> a finite domain constraint variable array and <<SVs>> a set constraint variable array.
  <item> <<post(BVs X)>>: Post propagator for <math> BVsi = 1 \Leftrightarrow i \in X  </math>,
beign <<BVs>> a boolean constraint variable array and <<X>> a set constraint variable.
</list>

<entry>
<index class=module/GFS<and>connection/
<<weights>>
<synopsis>
<<<
{GFS.weights ?*{PE}}
>>>
<item> Post a domain propagator according to the post especification ?_{PE}. ?_{PE} 
can be of the following forms:

<list class=enum>
  <item> <<post(E W S I)>>: Post propagator for <math> I = weights(S)  </math>,
beign <<E>> and <<W>> array of integers. <<S>> a set constraint variable and <<I>> a finite domain constraint variable.
<p>
The weights are given as pairs of elements and their weight: <math> weights(Ei) = Wi  </math>.
The upper bound of <<S>> is constrained to contain only elements from <<E>>. The weight of a set is the sum of the weights of its elements. 
</list>

</list>
</section>

<!-- ********************************************************************** -->

<section id="section.fs.selection"><title/Selection constraints/
<p>

<list>

<entry>
<index class=module/GFS<and>selection/
<<selectUnion>>
<synopsis>
<<<
{GFS.selectUnion ?*{PE}}
>>>
<item> Post a domain propagator according to the post especification ?_{PE}. ?_{PE} 
can be of the following forms:

<list class=enum>
<item> <<post(Lx Y Z)>>: Post propagator for <math> Z = \cap (Lx0,...,Lxn-1)[Y]</math>,
beign <<Lx>> a set constraint variable array, <<Y>> and <<Z>> set constraint variables.
<item> <<post(Lx Y Z)>>: Post propagator for <math> Z = \cap (Lx0,...,Lxn-1)[Y]</math>,
beign <<Lx>> a finite domain constraint variable array, <<Y>> and <<Z>> set constraint variables.
</list>

<entry>
<index class=module/GFS<and>selection/
<<selectUnion>>
<synopsis>
<<<
{GFS.selectUnion ?*{PE}}
>>>
<item> Post a domain propagator according to the post especification ?_{PE}. ?_{PE} 
can be of the following forms:

<list class=enum>
<item> <<post(Lx Y Z)>>: Post propagator for <math> Z = \bigcup (Lx0,...,Lxn-1)[Y]</math>,
beign <<Lx>> a set constraint variable array, <<Y>> and <<Z>> set constraint variables.
<item> <<post(Lx Y Z)>>: Post propagator for <math> Z = \bigcup (Lx0,...,Lxn-1)[Y]</math>,
beign <<Lx>> a finite domain constraint variable array, <<Y>> and <<Z>> set constraint variables.
</list>

<entry>
<index class=module/GFS<and>selection/
<<selectInter>>
<synopsis>
<<<
{GFS.selectInter ?*{PE}}
>>>
<item> Post a domain propagator according to the post especification ?_{PE}. ?_{PE} 
can be of the following forms:

<list class=enum>
<item> <<post(Lx Y Z)>>: Post propagator for <math> Z = \cap (Lx0,...,Lxn-1)[Y]</math>,
beign <<Lx>> a set constraint variable array, <<Y>> and <<Z>> set constraint variables.
<item> <<post(Lx Y Z S)>>: Post propagator for <math> Z = \cap (Lx0,...,Lxn-1)[Y]</math>, using <<S>> as universe,
beign <<Lx>> a set constraint variable array, <<Y>> and <<Z>> set constraint variables and <<S>> a domain specification.
</list>

<entry>
<index class=module/GFS<and>selection/
<<selectDisjoint>>
<synopsis>
<<<
{GFS.selectDisjoint ?*{PE}}
>>>
<item> Post a domain propagator according to the post especification ?_{PE}. ?_{PE} 
can be of the following forms:

<list class=enum>
<item> <<post(Lx Y)>>: Post propagator for <math> \| (Lx0,...,Lxn-1)[Y]</math>,
beign <<Lx>> a set constraint variable array and <<Y>> a set constraint variable.
</list>

<entry>
<index class=module/GFS<and>selection/
<<selectSet>>
<synopsis>
<<<
{GFS.selectSet ?*{PE}}
>>>
<item> Post a domain propagator according to the post especification ?_{PE}. ?_{PE} 
can be of the following forms:

<list class=enum>
<item> <<post(Lx IV Z)>>: Post propagator for <math> Z = (Lx0,...,Lxn-1)[IV]</math>,
beign <<Lx>> a set constraint variable array, <<IV>> a finite domain variable and <<Z>> a set constraint variable.
<item> <<post(Sx IV Z)>>: Post propagator for <math> Z = (Sx0,...,Sxn-1)[IV]</math>,
beign <<Sx>> a domain specification array, <<IV>> a finite domain variable and <<Z>> a set constraint variable.
</list>

</list>
</section>

<!-- ********************************************************************** -->

<section id="section.fs.reified"><title/Reified Propagators/
<p>
<list>
<!--
<entry>
<index class=module/FS<and>reified<and>isIn/
<<reified.isIn>>
<synopsis>
<<<{FS.reified.isIn +I *M $D}
>>>
<item>
<math/\codeinline{oz}{D} \in \{0,1\} \wedge ((\codeinline{oz}{I} \in \codeinline{oz}{M}) \leftrightarrow
\codeinline{oz}{D} = 1)/

<entry>
<index class=module/FS<and>reified<and>areIn/
<<reified.areIn>>
<synopsis>
<<<{FS.reified.areIn +Spec *M $Ds}
>>>
<item>
?{Spec} describes a list of individual elements ?{Is}. ?{Is} and
?{Ds} are lists of the same length such that every element <math/{\tt
D}_i/ of ?{Ds} reifies the presence of the corresponding element
<math/{\tt I}_i/ of ?{Is} in the set ?{M}.
-->
<entry>
<index class=module/GFS<and>reified<and>include/
<<reified.include>>
<synopsis>
<<<{GFS.reified.include +D1 *M $D2}
>>>
<item>
?{D2} reifies the presence of ?{D1} in the set ?{M}. This propagator
detects in contrast to <<GFS.reified.isIn>> earlier if ?{D1} is or is not
contained in ?{M}.
<!--
<entry>
<index class=module/FS<and>reified<and>equal/
<<reified.equal>>
<synopsis>
<<<{FS.reified.equal *M1 *M2 $D}
>>>
<item>
?{D} reifies the equality of ?{M1} and ?{M2}. 

<entry>
<index class=module/FS<and>reified<and>partition/
<<reified.partition>>
<synopsis>
<<<{FS.reified.partition +MVs +Is +MV $Ds}
>>>
<item>
The propagator partitions the set value <<MV>> by selecting elements
from the list of set values <<MVs>>.  The positive integers in <<Is>>
denote the cost resp. benefit of the corresponding set value in
<<MVs>> if it is selected for the partition. Each element of <<Ds>>
is either <<0>> or the corresponding integer value in <<Is>>
depending on whether the corresponding set value in <<MVs>> is part of
the partition or not. Excluding a set value from the partition is done
by constraining the corresponding element of <<Ds>> to <<0>>. An
element in <<Ds>> not equal to <<0>> includes the corresponding set
value in <<MVs>> in the partition. The propagator ensures a valid
partition according to the values of <<Ds>>.
-->
</list>
</section>

<!-- ********************************************************************** -->
<!--
<section id="section.fs.iterating"><title/Iterating and Monitoring/
<p>
<list>

<entry>
<index class=module/FS<and>monitorIn<and>id/
<<monitorIn>>
<synopsis>
<<<{FS.monitorIn *M ?Is}
>>>
<item>
This procedure writes all elements of <<M>> to <<Is>> as soon as
<math/{\tt I} \in {\tt M}/ becomes <Em/known/.  When <<M>> becomes
determined the stream <<Is>> will be closed.

<entry>
<index class=module/FS<and>monitorOut<and>id/
<<monitorOut>>
<synopsis>
<<<{FS.monitorOut *M ?Is}
>>>
<item>
This procedure writes all elements of <<M>> to <<Is>> as soon as
<math/{\tt I} \notin {\tt M}/ becomes <Em/known/.  When <<M>> becomes
determined the stream <<Is>> will be closed.

<entry>
<index class=module/FS<and>forAllIn<and>id/
<<forAllIn>>
<synopsis>
<<<{FS.forAllIn *M +P/1}
>>>
<item>
This procedure applies <<P/1>> to all elements of <<M>>. 
</list>
</section>
-->
<!-- ********************************************************************** -->
<!--
<section id="section.fs.reflection"><title/Reflection/
<p>
The result of a reflective procedure depends on the current state of the
constraint store and is non-deterministic.
<list>

<entry>
<index class=module/FS<and>reflect<and>card/
<<reflect.card>>
<synopsis>
<<<{FS.reflect.card *M ?Spec}
>>>
<item>
returns a description ?{Spec} of the current information on the
cardinality of&nbsp;?{M}. 

<entry>
<index class=module/FS<and>reflect<and>lowerBound/
<<reflect.lowerBound>>
<synopsis>
<<<{FS.reflect.lowerBound *M ?Spec}
>>>
<item>
Returns a specification of the greatest lower bound that is 
currently known about the set ?{M}. 

<entry>
<index class=module/FS<and>reflect<and>upperBound/
<<reflect.upperBound>>
<synopsis>
<<<{FS.reflect.upperBound *M ?Spec}
>>>
<item>
Returns a specification of the least upper bound that is currently
known about the set ?{M}.  

<entry>
<index class=module/FS<and>reflect<and>unknown/
<<reflect.unknown>>
<synopsis>
<<<{FS.reflect.unknown *M ?Spec}
>>>
<item>
Returns a specification of the set of elements that are neither known
to be included in ?{M} nor excluded from ?{M}.

<entry>
<index class=module/FS<and>reflect<and>lowerBoundList/
<<reflect.lowerBoundList>>
<synopsis>
<<<{FS.reflect.lowerBoundList *M ?Spec}
>>>
<item>
Returns an expanded specification (&ie;, every individual element is
represented) of the greatest lower bound that is currently known about
the set ?{M}.

<entry>
<index class=module/FS<and>reflect<and>upperBoundList/
<<reflect.upperBoundList>>
<synopsis>
<<<{FS.reflect.upperBoundList *M ?Spec}
>>>
<item>
Returns an expanded specification (&ie;, every individual element is
represented) of the least upper bound that is currently
known about the set ?{M}.  

<entry>
<index class=module/FS<and>reflect<and>unknownList/
<<reflect.unknownList>>
<synopsis>
<<<{FS.reflect.unknownList *M ?Spec}
>>>
<item>
Returns an expanded specification (&ie;, every individual element is
represented) of the set of elements that are neither known to be
included in ?{M} nor excluded from ?{M}.

<entry>
<index class=module/FS<and>reflect<and>cardOf<and>lowerBound/
<<reflect.cardOf.lowerBound>>
<synopsis>
<<<{FS.reflect.cardOf.lowerBound *M ?I}
>>>
<item>
Returns the cardinality of the current greatest lower bound for ?{M}. 

<entry>
<index class=module/FS<and>reflect<and>cardOf<and>upperBound/
<<reflect.cardOf.upperBound>>
<synopsis>
<<<{FS.reflect.cardOf.upperBound *M ?I}
>>>
<item>
Returns the cardinality of the current greatest lower bound for ?{M}. 

<entry>
<index class=module/FS<and>reflect<and>cardOf<and>unknown/
<<reflect.cardOf.unknown>>
<synopsis>
<<<{FS.reflect.cardOf.unknown *M ?I}
>>>
<item>
Returns the number of elements that are currently not known to be
included or excluded from ?{M}.

</list>
</section>
-->
<!-- ********************************************************************** -->
<!--
<section id="section.fs.distribution"><title/Distribution/
<p>
Given a set ?{M}, let <math/{\it lowerBound}({\tt M})/ and <math/{\it
upperBound}({\tt M})/ denote the greatest lower bound and the least upper
bound currently known for ?{M}.  Also define <math/{\it unknown}({\tt M}) =
{\it upperBound}({\tt M}) \backslash {\it lowerBound}({\tt M})/.
<list>  

<entry>
<index class=module/FS<and>distribute<and>id/
<<distribute>>
<synopsis>
<<<{FS.distribute +Dist *Ms}
>>>
<item>
The vector <<Ms>> is distributed according to the specification
<<Dist>>. The following values for <<Dist>> are supported:
<list>
<item> <<naive>> is equivalent to <<generic>>, &ie; the default
      settings apply.
<item>
<<<
generic(order:    +Order   &lt;= order
        filter:   +Filter  &lt;= true
        select:   +Select  &lt;= id
        element:  +Element &lt;= element
        rrobin:   +RRobin  &lt;= false
        weights:  +Weights &lt;= {FS.makeWeights nil}
        procedure:+Proc    &lt;= proc {$} skip end)
>>>
<list>
<item> <<Order>>
<list>
<item> <<naive>> selects the left-most variable.
<item>
<<<
order(sel:  +Sel  &lt;= min
      cost: +Cost &lt;= card 
      comp: +Comp &lt;= unknown)
>>>
<list>
<item> <<Sel = min>> selects the left-most variable <<S>> from <<Ss>> with
the <em/minimal/ cost according to <<Cost>>.
<item> <<Sel = max>> selects the left-most variable <<S>> from <<Ss>>
  with the <em/maximal/ cost according to <<Cost>>.
<item> <<Cost = card>>: The cost is the cardinality of the 
set determined by <<Comp>>.
<item> <<Cost = weightSum>>: The cost is the <em/sum/
of the weights associated with the elements 
of the set determined by <<Comp>>.
<item> <<Cost = weightMin>>: The cost is the <em/minimal/ weight
 determined by <<Comp>>.
<item> <<Cost = weightMax>>: The cost is the <em/maximal/ weight
  associated with an element of the set determined by
  <<Comp>>.
<item> <<Comp = unknown>> selects <math/{\it unknown}({\tt S})/. 
<item> <<Comp = lowerBound>> selects <math/{\it lowerBound}({\tt S})/. 
<item> <<Comp = upperBound>> selects <math/{\it upperBound}({\tt S})/. 
</list>
<item>  
<<<
fun {Order +Ss} ... end
>>>
</list>
<item> <<Filter>> determines if an element <<S>> of <<Ss>> is
choosen for distribution. That is the case if <<{IsDet S>>} <em/and/
the filter yields <<true>>.
<list>
<item> <<true>> skips values in <<Ss>>.
<item> 
<<<
fun {Filter +E} ... end
>>>
</list>
<item> <<Select>> is used to access the actual finite set
      variable. Self-defined functions resp. procedures have to apply
      an appropriate selection function by themselves.
<list>
<item> <<id>> is the identity function. 
<item> 
<<<
fun {Select +E} ... end
>>>
</list>
<item> <<Element>>
<list>
<item> 
<<<
element(sel: +Sel &lt;= min
        wrt: +Wrt &lt;= unknown) 
>>>
<list>
<item> <<Sel = min>> selects the <em/minimal/ element with
respect to <<Wrt>>.  
<item> <<Sel = max>> selects the <em/maximal/ element
  with respect to <<Wrt>>.
  
<item> <<Wrt = unknown>> chooses an element from <math/{\it unknown}(S)/.
  and interprets it as an integer.
<item> <<Wrt = weight>> chooses an element from <math/{\it unknown}(S)/
  and takes its weight as selection criterion.
</list>
<item> 
<<<
fun {Element +E} ... end
>>>
</list>
<item> <<RRobin>>
<list>
<item> <<true>> causes the distribution to step through the variable
      list in a round-robin fashion.
<item> <<false>> causes the distribution to completely enumerate the
      head of the variable list and then proceeds with the head of the
      tail of the variable list.
</list>
<item> <<Weights>> must be a list of the form <<[E#W ...]>>. The
      variable <<E>> denotes an element and <<W>> the element's
      weight. An list element of the form <<default#W>> assigns to all
      not explicitely mentioned elements the weight <<W>>. If there is
      no element <<default#W>> then 
        <<default#0>> is implicitely
      added.
<item> <<Proc>> is applied when stability is reached. Since this
      application may cause instability, distribution is continued when
      stability is reached again.
</list>
</list>
</list>
</section>
-->
</Chapter>
