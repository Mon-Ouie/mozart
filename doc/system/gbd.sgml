<!--
  - Authors:
  -   Denys Duchier     <duchier@ps.uni-sb.de>
  -   Leif Kornstaedt <kornstae@ps.uni-sb.de>
  -   Christian Schulte <schulte@ps.uni-sb.de>
  -   Tobias Mueller <tmueller@ps.uni-sb.de>
  -
  - Copyright:
  -   Denys Duchier, 1998
  -   Leif Kornstaedt, 1998
  -   Christian Schulte, 1998
  -   Tobias Mueller, 1998
  -
  - Last change:
  -   $Date: 2009-06-12 11:15:54 -0500 (Fri, 12 Jun 2009) $ by $Author: ggutierrez $
  -   $Revision: 17239 $
  -
  - This file is part of Mozart, an implementation
  - of Oz 3
  -    http://www.mozart-oz.org
  -
  - See the file "LICENSE" or
  -    http://www.mozart-oz.org/LICENSE.html
  - for information on usage and redistribution
  - of this file, and for a DISCLAIMER OF ALL
  - WARRANTIES.
  -
  -->

<Chapter id="Chapter.GBD">
  <Title/Boolean Domain Constraints: <<GBD>>/

<p>
The procedures in this module have the following properties. 

<!-- <p>
Each of their applications creates a new thread except for basic
constraints which may block.
-->
<p>
To get an unified call interface for propagators, all propagator
posting functions take only a record as argument. This record
contains all the parameters needed to call the propagator and one
optional field: <<cl>>. <<cl>> is for specifying which
consistency level should be used by the propagator, options include
domain consistency, bounds consistency, etc. 
This field are completely optional as default value are
internally choosen when it are not provided by user.

<!-- <p>
Most of the propagators perform interval propagation. Only some
do domain propagation (&ie; cut holes into domains). 
-->

<p>
Equality between variables is exploited, except for some non-linear
propagators.  For example, <<A+A=:B>> is equivalent to <<2*A=:B>> (for
notation see&nbsp;sec.infix-ps).
<p>
The constraint store is amplified with constraints <<X::Spec>>  and
equality between variables, &eg;, <<X=:Y>> is equivalent to <<X=Y>>.

<para><title/Relation symbols/
There are propagator posting procedures that take an argument <<Rt>> to denote 
an arithmetic relation <math/\sim_{Rt}/. The possible values and the associated 
relations are summarized below. 
<table>
<tr><td/<<'=:'>>/ <td> Equality (<math>=</math>)</td></tr>
<tr><td/<<'\\=:'>>/ <td> Disequality (<math>\neq</math>)</td></tr>
<tr><td/<<'=<:'>>/ <td> Less or equal (<math>\leq</math>)</td></tr>
<tr><td/<<'<:'>>/ <td> Less (<math><</math>)</td></tr>
<tr><td/<<'>=:'>>/ <td> Greater or equal (<math>\geq</math>)</td></tr>
<tr><td/<<'>:'>>/ <td> Greater (<math>></math>)</td></tr>
</table>

<para><title/Lazy propagation/
When a propagator is posted in a computation space it does not performs any
domain pruning. This behavior allows the implementation of batch recomputation 
enabled search engines (REF paper). Lazy propagation is only acheved in sub-spaces, it is, when on toplevel propagation is performe eagerly. To perform propagation in a sub-space you have to ask the space to do so by calling <<Space.ask>>.

<p>
A propagator ceases to exist at least if all the variables it is posted
on are determined. In the following
sections, only exceptions from this rule are mentioned, &ie; if the
propagator ceases to exist earlier. For example, {<<X =<: Y>>} ceases to
exist if the current upper bound of <<X>> is smaller than or equal to the
current lower bound of <<Y>>.

<section id="section.gbd.general"><title/Boolean Domains/
<p>
<index scope="section.gbd.general"/Boolean Domains/

<list>
<entry>
<index class=module/GBD<and>sup/
<<sup>>
<synopsis>
<<<
GBD.sup
>>>
<item>
Upper bound allowed integer. Constant value: 1

<entry>
<index class=module/GBD<and>inf/
<<inf>>
<synopsis>
<<<
GBD.inf
>>>
<item>
Lower bound allowed integer. Constant value: 0



<entry>
<index class=module/GBD<and>is/
<<is>>
<synopsis>
<<<
{GBD.is ?*{V} ??{B}}  
>>>
<item>
tests whether ?_{V} is a boolean domain variable. 

</list>
</section>

<!-- ********************************************************************** -->
<section id="section.gbd.telling"><title/Telling Domains/
<p>

<p>
<list>
<entry>
<index class=module/GBD<and>int/
<<::>>
<synopsis>
<<<
??{B}::?+{Spec}
{GBD.int ?+{Spec} ??{B}}  
>>>
<item>
tells the constraint store that ?_{B} is a boolean in ?_{Spec}. 

<entry>
<index class=module/GBD<and>dom/
<<:::>>
<synopsis>
<<<
?_{Bv}:::?+{Spec}
{GBD.dom ?+{Spec} ??{Bv}}
>>>
<item>
tells the constraint store that ?_{Bv} is a vector of booleans in
?_{Spec}. Waits until ?_{Bv} is constrained to a vector. 

<entry>
<index class=module/GBD<and>list/
<<list>>
<synopsis>
<<<
{GBD.list ?+{U} ?+{Spec} ??{Bl}}  
>>>
<item>
tells the constraint store that
?_{Bl} is a list of booleans in ?_{Spec} of length ?_{U}.

<entry>
<index class=module/GBD<and>tuple/
<<tuple>>
<synopsis>
<<<
{GBD.tuple ?+{L} ?+{U} ?+{Spec} ??{Bt}}  
>>>
<item>
tells the constraint store that
?_{Bt} is a tuple of booleans in ?_{Spec} of width ?_{U}
and label ?_{L}. 

<entry id="GBD.record">
<index class=module/GBD<and>record/
<<record>>
<synopsis>
<<<
{GBD.record ?+{L} ?+{Ls} ?+{Spec} ??{Br}}  
>>>
<item>
tells the constraint store that
?_{Br} is a record of booleans in ?_{Spec} with features
?_{Ls} and 
label ?_{L}. 

<entry>
<index class=module/GBD<and>decl/
<<decl>>
<synopsis>
<<<
{GBD.decl ??{B}}  
>>>
<item>
Abbreviates <<{GBD.bool GBD.inf#GBD.sup ?_{B}}>>.
</list>
</section>



<!-- ********************************************************************** -->

<section id="section.gbd.bool"><title>0/1 Propagators</title>
<p>
Using the mapping from <<0>> and <<1>> to the truth values <def/false/ and
<def/true/, respectively,  logical connectives between finite
domain integers are defined.
If at most  one argument is a free variable, it will be
constrained to a finite domain integer in <math/\{0,1\}/.
Such a finite domain
integer is also called a 0/1-integer.
The propagators exploit equality and  may also post
equality between variables.
<p>
The operational semantics is detailed only for <<GBD.conj>>. For the
remaining propagators, the operational semantics is defined accordingly,
exploiting as much information as possible (including coreferences).
<list>
<entry>
<index class=module/GBD<and>conj/
<<conj>>
<synopsis>
<<<
{GBD.conj ?@{B1} ?@{B2} ?@{B3}}
>>>
<item>
?_{B3} is the conjunction of ?_{B1} and ?_{B2}.
The operational semantics can be described by the following code
<<<
[B1 B2 B3] ::: 0#1
cond B1=0  then B3=0
[]   B1=1  then B2=B3
[]   B2=0  then B3=0
[]   B2=1  then B1=B3
[]   B3=1  then B1=1 B2=1
[]   B1=D2 then B1=B3
end
>>>

<entry>
<index class=module/GBD<and>disj/
<<disj>>
<synopsis>
<<<
{GBD.disj ?@{B1} ?@{B2} ?@{B3}}
>>>
<item>
?_{B3} is the disjunction of ?_{B1} and ?_{B2}.

<entry>
<index class=module/GBD<and>exor/
<<exor>>
<synopsis>
<<<
{GBD.exor ?@{B1} ?@{B2} ?@{B3}}
>>>
<item>
?_{B3} is the exclusive disjunction of ?_{B1} and ?_{B2}.

<entry>
<index class=module/GBD<and>nega/
<<nega>>
<synopsis>
<<<
{GBD.nega ?@{B1} ?@{B2}}
>>>
<item>
?_{D2} is the negation of ?_{D1}.

<entry>
<index class=module/GBD<and>impl/
<<impl>>
<synopsis>
<<<
{GBD.impl ?@{B1} ?@{B2} ?@{B3}}
>>>
<item>
?_{B3} is the implication of ?_{B2} by ?_{B1}
(<Q/<math/{\tt B1}\rightarrow{\tt B2}//).

<entry>
<index class=module/GBD<and>equi/
<<equi>>
<synopsis>
<<<
{GBD.equi ?@{B1} ?@{B2} ?@{B3}}
>>>
<item>
?_{B3} is the equivalence of ?_{B1} by ?_{B2}
(<Q/<math/{\tt D1}\leftrightarrow{\tt B2}//).
</list></section>

<!-- ********************************************************************** -->
<section id="section.gbd.rel"><title/Simple relation constraints over Boolean variables/

<p>
<para><title/Relation Boolean symbols/
There are propagator posting procedures that take an argument <<Bot>> to denote 
a boolean relation. The possible values and the associated 
relations are summarized below. 
<table>
<tr><td/<<'AND'>>/ <td> Equality (<math>=</math>)</td></tr>
<tr><td/<<'OR'>>/ <td> Disequality (<math>\neq</math>)</td></tr>
<tr><td/<<'IMP'>>/ <td> Less or equal (<math>\leq</math>)</td></tr>
<tr><td/<<'EQV'>>/ <td> Less (<math><</math>)</td></tr>
<tr><td/<<'XOR'>>/ <td> Greater or equal (<math>\geq</math>)</td></tr>
</table>

<list>
<entry>
<index class=module/GBD<and>relP/
<<relP>>
<synopsis>
<<<
{GBD.relP ?*{PE}}
>>>
<item> Post a relation propagator over booleans according to the post especification ?_{PE}. ?_{PE} 
can be of the following forms:

<list class=enum>
<item> <<post(B1 Rt B2)>>: Post propagator for <math> B1 \sim_{Rt} B2</math>. 
<item> <<post(B1 Rt B2 B3)>>: Post propagator for <math> (B1 \sim_{Rt} B2)\Leftrightarrow B3</math>.
<item> <<post(Bv Rt B1)>>: Post propagator for <math> Bv_i \sim_{Rt} B1 </math> for all <math>0\leq i<|Bv|</math>.
<item> <<post(B1 Rt U)>>: Post propagator for <math> B1 \sim_{Rt} U</math>. 
<item> <<post(B1 Rt U B2)>>: Post propagator for <math> (B1 \sim_{Rt} U)\Leftrightarrow B2 </math>. 
<item> <<post(B1 Bot B2 B3)>>: Post propagator for Boolean operation on B1 and B2. 
<item> <<post(B1 Bot B2 U)>>: Post propagator for Boolean operation on B1 and B2. 
<item> <<post(Bot Bv B)>>: Post propagator for Boolean operation on B. 
<item> <<post(Bot Bv U)>>: Post propagator for Boolean operation on U. 
</list>
</list>
</section>


<!--
**********************************************************************
--> <section id="section.gbd.distribution"><title/Distribution/
<p>
In this section it is shown how Oz supports distribution with
constraints.  The following procedure creates branching descriptions that
define a search tree. Decisions are made by commiting a branching description
to a computation space to create another node in the search tree. Assume  <<Dv>> 
to be a vector of boolean domain integers. The distribution differs in the 
order of the branchings and in the constraint with which is distributed.

 Essentially, it works as follows
<list class=enum>
<item> Select an element <<D>> of <<Dv>> which is not determined.
<item> Select a value or a domain specification <<Spec>> in the current
domain of <<D>>. 
<item> Create a branching description for this space as <<[X::Spec X::compl(Spec)]>>. 
<item> If not all elements of <<Dv>> are determined, go to step 1.
</list>

The order of <<Dv>> is preserved. 

<list>
<entry>
<index class=module/GBD<and>distribute/
<<distribute>>
<synopsis>
<<<
{GBD.distribute ?+{Dist} ?+{Xv}}
>>>
<item>
The vector ?_{Xv} is distributed according to the specification 
?_{Dist}. 
 ?_{Dist} may be either
the atom <<naive>>, <<ff>> (for first-fail), <<split>> or a record with label <<generic>>:

<list>
<item> <<naive>>:
?_{Xv} must be a vector of boolean domain integers.
Considers only non-determined elements of ?_{Xv}. Chooses the leftmost
variable <<X>> in ?_{Xv}.
Creates a branching description for <<X=L>> and <<X\=:L>>, where <<L>> is the lower
bound of the domain of <<X>>.

<item> <<ff>>:
?_{Xv} must be a vector of boolean domain integers.
Considers only non-determined elements of ?_{Xv}. Chooses the leftmost
variable <<X>> in ?_{Xv}, whose domain size is minimal. 
Creates a branching description for <<X=L>> and <<X\=:L>>, where <<L>> is the lower
bound of the domain of <<X>>. 

<item> <<split>>:
?_{Xv} must be a vector of boolean domain integers.
Considers only non-determined elements of ?_{Xv}. Chooses the leftmost
variable <<X>> in ?_{Xv}, whose domain size is minimal. 
Creates a branching description for <<X=<:M>> and <<X>:M>>, where <<M>> is the
middle of the domain of <<X>> (see <<GBF.reflect.mid>>). 

<item> 
<<<
generic(order:     ?+{Order}  <= size
        filter:    ?+{Filter} <= undet
        select:    ?+{Select} <= id
        value:     ?+{Value}  <= min
        procedure: ?+{Proc}   <= proc {$} skip end)
>>>
Considers only those elements in ?_{Xv}, for which ?_{Filter} is
true. Chooses the leftmost element, which is minimal with respect to ?_{Order}
and selects the 
corresponding variable <<D>> by ?_{Select}. Creates a branching description for
<<D::Spec>> and <<D::compl(Spec)>>, where <<Spec>> is selected by
<<Value>>. 
<p>
The values under the respective features must be as follows:
<p>
<list>
<item> ?_{Order}:
<list>
        <item> Binary boolean function <<P>>: Selects the leftmost element
                         in ?_{Xv} which is minimal with respect  to
                         the order relation <<P>>.
	<item> <<naive>>: Selects the leftmost variable. 
        <item> <<size>>: Selects the leftmost variable, whose domain is
                         minimal.
        <item> <<min>>: Selects the leftmost variable, whose lower bound is
                         minimal.
        <item> <<max>>: Selects the leftmost variable, whose upper bound
                         is maximal.
        <item> <<nbSusps>>: Selects the variable with the
                         largest number of suspensions. If 
several variables suspend on the maximal number of constraints, 
the leftmost variable whose domain is minimal is selected.
	<item> <<nbProps>>: Selects the variable with the largest number of 
                            associated propagators.
</list>
<item> ?_{Filter}: 
<list>
        <item> Unary boolean function <<P>>: Considers only the elements
        <<X>> in ?_{Xv}, for which <<{P X}>> yields <<true>>. 
        <item> <<undet>>: Considers only undetermined variables.
</list>
<item> ?_{Select}:
<list>
        <item> Unary function <<P>>: Selects the variable to enumerate
        from the selected element by ?_{Order} and ?_{Filter}.
        <item> <<id>>: The variable to enumerate is the selected element.
</list>
<item> ?_{Value}:
<list>
        <item> Binary procedure <<P>>: Takes a variable as first argument,
	and binds its second argument to a domain descriptor <<D>> to serve
	as the restriction on said variable to be used in a binary distribution
	step (<<D>> in one branch, <<compl(D)>> in the other).
        <item> <<min>>: Selects the lower bound of the domain. 
        <item> <<max>>: Selects the upper bound of the domain.
        <item> <<mid>>: Selects the element, which is closest to the 
		middle of the domain (the arithmetical means between 
		the lower and upper bound of the domain). In case of ties, the smaller
	        element	is selected.
        <item> <<splitMin>>: Selects the interval from the lower bound to the
        middle of the domain (see <<mid>>). 
        <item> <<splitMax>>: Selects the interval from the element
        following the middle to the upper bound  of the domain (see <<mid>>). 
</list>
<item> ?_{Proc}: Is applied when stability is reached. Since this
      application may cause instability, distribution is continued when
      stability is reached again.

</list>
Note, that in case ?_{Det} is <<det>> or in case ?_{Order} is <<size>>,
<<lower>>, <<upper>>, or <<nbSusps>>, the elements of ?_{Xv} must be
finite domain integers. 
<p>
For example, <<{GBD.distribute ff Dv}>> can be expressed as 
<<<
{GBD.distribute generic Dv},
>>>
<<{GBD.distribute split Dv}>> as 
<<<
{GBD.distribute generic(value: splitMin) Dv},
>>>
and <<{GBD.distribute naive Dv}>> as
<<<
{GBD.distribute generic(order: naive) Dv}
>>>
</list>
The naive distribution can also be defined as follows using the <<value>>
feature.
<<<
{GBD.distribute 
generic(value: fun {$ D}
		  {GBD.reflect.min D}
	       end) Ds}
>>>

</list>
</section>
<!--**********************************************************************-->


<section id="section.gbd.assignment"><title/Assigning Values/
<p>
Special support is available for assigning particular values to
vectors of variables. 
</p>
<p>The selection of variables and the selection of values is as
with distribution <ptr to="section.gbd.distribution">.
</p>
<p>
<list>
<entry>
<index class=module/GBD<and>assign/
<<assign>>
<synopsis>
<<<
{GBD.assign ?+{ValA} ?+{Xv}}
>>>
<item>
The vector ?_{Xv} is assigned according to the specification 
?_{ValA}. 
 ?_{ValA} may be either
the atom <<min>>, <<mid>>, or <<max>>. That is, the smallest,
medium, or largest element is assigned to each variable. 
<p>
Is equivalent to (for a list of variables <<Xs>>):
<p>
<<<proc {GBD.assign ValA Xs}
   for X in Xs do 
	X = {GBD.reflect.ValA X}
   end
end>>>
</list>
</p>
</section>


</chapter>

