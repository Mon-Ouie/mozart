<!--
  - Authors:
  -   Denys Duchier     <duchier@ps.uni-sb.de>
  -   Leif Kornstaedt <kornstae@ps.uni-sb.de>
  -   Christian Schulte <schulte@dfki.de>
  -
  - Copyright:
  -   Denys Duchier, 1998
  -   Leif Kornstaedt, 1998
  -   Christian Schulte, 1998
  -
  - Last change:
  -   $Date$ by $Author$
  -   $Revision$
  -
  - This file is part of Mozart, an implementation
  - of Oz 3
  -    http://mozart.ps.uni-sb.de
  -
  - See the file "LICENSE" or
  -    http://mozart.ps.uni-sb.de/LICENSE.html
  - for information on usage and redistribution
  - of this file, and for a DISCLAIMER OF ALL
  - WARRANTIES.
  -
  -->

<part id=part.foreign.extensions proglang=cc>
  <title/Foreign Extensions/
  <chapter id=chapter.counter.global>
    <title/Global Counter Library/

    <p>Oz can be very simply extended with new functionality and
datatypes implemented in C or C++.  This capability is often used to
interface Oz to existing libraries: for example, the <name
type="library"/regex/ and <name type="library"/gdbm/ modules are
implemented in this fashion.</p>

    <p>Every extension is presented to the system in the form of a
<def/native functor/<index/functor<and>native/, &ie; a functor which
happens to be implemented in C or C++ rather than in Oz.</p>

    <p>In this chapter, we define a native functor that exports a
<code/<span class=ignore/ /next/
function which returns the next value of a global counter each time it
is called.</p>
    <section>
      <title/Implementation/
<p><code.extern display to="counter.cc">
<code/OZ_BI_define(counter_next,0,1)/ indicates that we are defining a
procedure <code/<span class=ignore/ /counter_next/ that implements a new builtin which
takes 0 input arguments and returns 1 output value. <code/OZ_BI_end/
is required to finish this definition.</p>

<p><code/<span class=ignore/ /OZ_RETURN_INT(?{d})/ is a macro that causes
the builtin to return integer ?{d} as an Oz integer.  This should only
be used when the builtin has one unique output value.</p>

<p>Finally <code/extern "C" { ... }/ defines the native functor.  It
must contain the definition of procedure
<code/<span class=ignore/ /oz_init_module/ whose purpose is to perform
arbitrary initializations and then return a table of builtins.  Each
entry in this table consists of (1) the name of the export, (2) the
input arity, (3) the output arity, (4) the procedure implementing the
builtin.  The table must be terminated by an entry whose fields are
all zero.</p>
      </section>

    <section>
      <title/Compilation/
      <p>We must now make this native module available as a
<em/shared object library/.  First we must compile it and create
<file/counter.o/:
<code display proglang=sh>oztool c++ -I${OZHOME}/include -c counter.cc</code>
Then we must produce a platform specific shared object library:
<code display proglang=sh>oztool ld counter.o -o counter.so-`ozplatform`</code>
You may find it useful to create a <file/Makefile/ of the form:
<code.extern display proglang=makefile to="mkfile.xmp">
</p>
        <p><code proglang=sh/oztool/<index/<code proglang=sh/oztool//
is a script that invokes
the facility named as its first argument with appropriate options.
For example, it is essential to invoke the same C++ compiler and with
the same &eg; code generation options as were used for building the Oz
emulator; otherwise it will not be possible to dynamically link your
library into a running Oz process.  Normally, the Oz emulator is
compiled without <em/run time information/ (option <code
proglang=sh/-fno-rtti/ for g++) and without support for C++ exceptions
(option <code proglang=sh/-fno-exceptions/ for g++).
<code proglang=sh/oztool c++/ automatically invokes the right
compiler with the right options.</p>
        <p>Even more complicated is how to create a DLL from a
compiled object file: it varies depending on the system, compiler and
linker used.  Under Windows, the sequence of necessary incantations is
so arcane and highly magical, it could well endanger your sanity.
Fortunately <code proglang=sh/oztool ld/ automatically takes
care of the details.</p>
      </section>
    <section>
      <title/Deployment/
<p>Normally, you will then place the resulting shared object file, e.g.
<file/counter.so-linux-i486/ on a Linux system, in an installation
directory; let's call it ?{install}.  If your site has several
platforms sharing one file system, then you can place all platform
specific shared object libraries that you create from
<file/counter.cc/ in the same ?{install} directory.  They all have
distinct names since the platform name is appended.</p>
        <p>In an Oz functor, you then write an import of the form:
<code display proglang=oz>Cnt at '?{install}/counter.so{native}'</code>
The <code/<span class=ignore/'/{native}<span class=ignore/'// suffix
indicates to the system that this denotes a native functor whose
platform independent basename is <file>?{install}/counter.so</file>.
The module manager dynamically links the appropriate platform specific
shared object library (by appending the platform specific extension to
the basename) and makes available the module it defines as the
value of <code proglang=oz/Cnt/.  The body of your functor can invoke
<code proglang=oz/{Cnt.next}/ to get the next value of the global
counter.</p>
        <p>In the emacs OPI, you can try this out immediately:
<code display proglang=oz
>declare [M] = {Module.link ['?{install}/counter.so{native}']}</code>
</p>
    </section>
  </chapter>

  <chapter id=chapter.counter.object>
    <title/Native Counter Objects/
    <p>In this chapter, we are going to generalize the counter idea:
instead of having just one global counter, we are going to have
counter objects implemented as extensions.  Of course, this is
intended purely as a didactic exercise: such counters could much more
easily be defined as Oz objects directly.</p>
    <section proglang=cc>
      <title/Counter Class/
      <p>We derive a new <code/&cc.class;Counter/ class from the base class
<code/&cc.class;OZ_Extension/.
<code display>
#include "mozart.h"

class Counter : public OZ_Extension {
public:
  long * n;
  Counter();
  Counter(long*);
  static int id;
  virtual int getIdV();
  virtual OZ_Term typeV();
  virtual OZ_Extension* gcV();
  virtual OZ_Term printV(int depth = 10);
};
</code>
A <code/&cc.class;Counter/ object contains a pointer to a malloced
<code/long/. Why not simply have a <code/long/ member: simply because
we want to illustrate an application of finalization; malloced memory
is a resource that needs to be freed when no longer needed.</p>
      <p>The <code/&cc.class;Counter/ class provides implementations for a
number of virtual member functions introduced by class
<code/&cc.class;Oz_Extension/. We are now going to explain each of them and
provide the necessary code.</p>
    </section>

    <section>
      <title/Counter Creation/
      <p>For this we need the <code/Counter()/ constructor and the new
builtin <code/counter_new/.  The constructor allocates a new
<code/long/, sets <code/n/ to its address and initializes it
with&nbsp;1.  The builtin creates a new instance of the
<code/&cc.class;Counter/
class, boxes it as an Oz value by invoking <code/OZ_extension/ and
returns the result.
<code display>
Counter::Counter() { n = new long[1]; n[0]=1; }

OZ_BI_define(counter_new,0,1)
{
  OZ_RETURN(OZ_extension(new Counter));
}
OZ_BI_end
</code>
</p>
    </section>

    <section>
      <title/Type Testing/
      <p>Every extension class should be uniquely identified.  This is
the purpose of virtual function <code/getIdV/.  Here we illustrate the
usual way of doing so: the class is equipped with a static <code/id/
member and <code/getIdV()/ returns it.  This static member is
initialized by <code/oz_init_module()/ (see later).
<code display>
int Counter::id;
int Counter::getIdV() { return id; }
</code>
Your code will also need to test whether some <code/OZ_Term/ is in
fact a boxed <code/&cc.class;Counter/.
<code display>
inline OZ_Boolean OZ_isCounter(OZ_Term t)
{
  t = OZ_deref(t);
  return OZ_isExtension(t) &&
    OZ_getExtension(t)->getIdV()==Counter::id;
}
</code>
Additionally, you should probably provide a builtin to perform this
test in Oz code:
<code display>
OZ_BI_define(counter_is,1,1)
{
  OZ_declareDetTerm(0,t);
  OZ_RETURN_BOOL(OZ_isCounter(t));
}
OZ_BI_end
</code>
Finally, it would be nice if <code proglang=oz/{Value.type C}/ would
return the atom <code proglang=oz/counter/ when <code proglang=oz/C/
is a counter object.
<code display>
OZ_Term Counter::typeV() { return OZ_atom("counter"); }
</code>
</p>
    </section>

    <section>
      <title/Expecting <code/&cc.class;Counter/ Arguments in Builtins/
      <p>Obviously we need a way to unbox counter objects.
<code display>
inline Counter* OZ_CounterToC(OZ_Term t)
{
  return (Counter*) OZ_getExtension(OZ_deref(t));
}
</code>
Now we can define a convenient macro that we can use in the
implementation of a builtin to wait until argument <code/ARG/ is
determined, check that it is a boxed <code/&cc.class;Counter/, and
declare a variable <code/VAR/ to hold a pointer to its unboxed value.
<code display>
#define OZ_declareCounter(ARG,VAR) \
OZ_declareType(ARG,VAR,Counter*,"counter",OZ_isCounter,OZ_CounterToC)
</code>
Next, we illustrate how to use this macro.</p>
    </section>

    <section>
      <title/Operations on Counters/
      <p>The first operation obtains the current value of the counter
object, but does not change it.  We use our new macro to state that
the first argument (&ie; argument number&nbsp;0) should be a
determined boxed counter and that <code/c/ should be set to point to
its unboxed value.
<code display>
OZ_BI_define(counter_get,1,1)
{
  OZ_declareCounter(0,c);
  OZ_RETURN_INT(*c->n);
}
OZ_BI_end
</code>
Thanks to our macro, if the argument is not determined, the builtin
will automatically suspend, and if it is determined but is not a
counter object, it will raise an error exception.</p>
      <p>We can similarly define a builtin for setting the value of
the counter.  It takes 2 arguments: a counter object and an integer.
<code display>
OZ_BI_define(counter_set,2,0)
{
  OZ_declareCounter(0,c);
  OZ_declareInt(1,i);
  *c->n=i;
  return PROCEED;
}
OZ_BI_end
</code></p>
      <p>Finally, we can define a builtin to obtain the current value
of a counter object and post increment the counter by 1.
<code display>
OZ_BI_define(counter_next,1,1)
{
  OZ_declareCounter(0,c);
  long i = *c->n;
  *c->n = i+1;
  OZ_RETURN_INT(i);
}
OZ_BI_end
</code></p>
    </section>

    <section>
      <title/Printing Support/
      <p>Of course, it would be nice if <code/{Show C}/, when <code/C/
is a counter object, would display <samp/&lt;counter /?{n}<samp/&gt/
where ?{n} is the current value of the counter.  This is easily
achieved by defining virtual function <code/printV/ to return an
appropriate virtual string.
<code display>
OZ_Term Counter::printV(int depth = 10)
{
  return OZ_mkTupleC("#",3,
                     OZ_atom("&lt;counter "),
                     OZ_int(*n),
                     OZ_atom("&gt;"));
}
</code></p>
    </section>

    <section>
      <title/Garbage Collection/
      <p>An instance of an <code/&cc.class;OZ_Extension/ class lives
on the heap and must be properly copied at each garbage collection.
This is realized simply by creating a new instance (automatically
allocated on the <em/to/ heap) and initializing it with the
appropriate info.  In the case of a counter object, we must copy the
<code/n/ pointer.  For this purpose we define a one argument
constructor.
<code display>
Counter::Counter(long*p):n(p){}
OZ_Extension* Counter::gcV() { return new Counter(n); }
</code></p>
    </section>

    <section>
      <title/Finalization/
      <p>When all references to a counter object disappear, we would
like the malloced <code/long/ to be freed.  We cannot easily register
a counter object for finalization from the C++ code (this will have to
be delegated to Oz code), but we can provide the implementation of the
finalization handler.
<code display>
OZ_BI_define(counter_free,1,0)
{
  OZ_declareCounter(0,c);
  free(c->n);
  return PROCEED;
}
OZ_BI_end
</code></p>
    </section>

    <section>
      <title/Native Functor/
      <p>We must now package this library as a native functor. This is
done by providing the function <code/oz_init_module()/ which returns a
table of builtins.  Here, it must also initialize the static member
<code/Counter::id/.
<code display>extern "C"
{
  OZ_C_proc_interface * oz_init_module(void)
  {
    static OZ_C_proc_interface table[] = {
      {"new",0,1,counter_new},
      {"get",1,1,counter_get},
      {"set",2,0,counter_set},
      {"next",1,1,counter_next},
      {"free",1,0,counter_free},
      {0,0,0,0}
    };
    Counter::id = OZ_getUniqueId();
    return table;
  }
}
</code></p>
    </section>

    <section>
      <title/Oz Module/
      <p>The counter object native library will now be wrapped in an
Oz module that registers every new counter object for finalization.
<code display proglang=oz>
functor
import
   CNT(NEW Get Set Next Free) at 'counter-obj.so{native}'
   Finalize(Register)
export
   New Get Set Next
define
   proc {New I C}
      {NEW I C}
      {Register C Free}
   end
end
</code></p>
    </section>
  </chapter>

</PART>

<!--
Local Variables:
mode: sgml
mode: auto-fill
sgml-default-dtd-file: "part.ced"
sgml-auto-activate-dtd: t
adaptive-fill-mode: nil
End:
-->
