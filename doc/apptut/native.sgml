<!--
  - Authors:
  -   Denys Duchier     <duchier@ps.uni-sb.de>
  -   Leif Kornstaedt <kornstae@ps.uni-sb.de>
  -   Christian Schulte <schulte@dfki.de>
  -
  - Copyright:
  -   Denys Duchier, 1998
  -   Leif Kornstaedt, 1998
  -   Christian Schulte, 1998
  -
  - Last change:
  -   $Date$ by $Author$
  -   $Revision$
  -
  - This file is part of Mozart, an implementation
  - of Oz 3
  -    http://mozart.ps.uni-sb.de
  -
  - See the file "LICENSE" or
  -    http://mozart.ps.uni-sb.de/LICENSE.html
  - for information on usage and redistribution
  - of this file, and for a DISCLAIMER OF ALL
  - WARRANTIES.
  -
  -->

<part id=part.foreign.extensions proglang=cc>
  <title/Foreign Extensions/
  <chapter id=chapter.counter.global>
    <title/Global Counter Library/

    <p>Oz can be very simply extended with new functionality and
datatypes implemented in C or C++.  This capability is often used to
interface Oz to existing libraries: for example, the <name
type="library"/regex/ and <name type="library"/gdbm/ modules are
implemented in this fashion.</p>

    <p>Every extension is presented to the system in the form of a
<def/native functor/<index/functor<and>native/, &ie; a functor which
happens to be implemented in C or C++ rather than in Oz.</p>

    <p>In this chapter, we define a native functor that exports a
<code/<span class=ignore/ /next/
function which returns the next value of a global counter each time it
is called.</p>
    <section>
      <title/Implementation/
<p><code.extern display to="counter.cc">
<code/OZ_BI_define(counter_next,0,1)/ indicates that we are defining a
procedure <code/<span class=ignore/ /counter_next/ that implements a new builtin which
takes 0 input arguments and returns 1 output value. <code/OZ_BI_end/
is required to finish this definition.</p>

<p><code/<span class=ignore/ /OZ_RETURN_INT(?{d})/ is a macro that causes
the builtin to return integer ?{d} as an Oz integer.  This should only
be used when the builtin has one unique output value.</p>

<p>Finally <code/extern "C" { ... }/ defines the native functor.  It
must contain the definition of procedure
<code/<span class=ignore/ /oz_init_module/ whose purpose is to perform
arbitrary initializations and then return a table of builtins.  Each
entry in this table consists of (1) the name of the export, (2) the
input arity, (3) the output arity, (4) the procedure implementing the
builtin.  The table must be terminated by an entry whose fields are
all zero.</p>
      </section>

    <section>
      <title/Compilation/
      <p>We must now make this native module available as a
<em/shared object library/.  First we must compile it and create
<file/counter.o/:
<code display proglang=sh>oztool c++ -I${OZHOME}/include -c counter.cc</code>
Then we must produce a platform specific shared object library:
<code display proglang=sh>oztool ld counter.o -o counter.so-`ozplatform`</code>
You may find it useful to create a <file/Makefile/ of the form:
<code.extern display proglang=makefile to="mkfile.xmp">
</p>
        <p><code proglang=sh/oztool/<index/<code proglang=sh/oztool//
is a script that invokes
the facility named as its first argument with appropriate options.
For example, it is essential to invoke the same C++ compiler and with
the same &eg; code generation options as were used for building the Oz
emulator; otherwise it will not be possible to dynamically link your
library into a running Oz process.  Normally, the Oz emulator is
compiled without <em/run time information/ (option <code
proglang=sh/-fno-rtti/ for g++) and without support for C++ exceptions
(option <code proglang=sh/-fno-exceptions/ for g++).
<code proglang=sh/oztool c++/ automatically invokes the right
compiler with the right options.</p>
        <p>Even more complicated is how to create a DLL from a
compiled object file: it varies depending on the system, compiler and
linker used.  Under Windows, the sequence of necessary incantations is
so arcane and highly magical, it could well endanger your sanity.
Fortunately <code proglang=sh/oztool ld/ automatically takes
care of the details.</p>
      </section>
    <section>
      <title/Deployment/
<p>Normally, you will then place the resulting shared object file, e.g.
<file/counter.so-linux-i486/ on a Linux system, in an installation
directory; let's call it ?{install}.  If your site has several
platforms sharing one file system, then you can place all platform
specific shared object libraries that you create from
<file/counter.cc/ in the same ?{install} directory.  They all have
distinct names since the platform name is appended.</p>
        <p>In an Oz functor, you then write an import of the form:
<code display proglang=oz>Cnt at '?{install}/counter.so{native}'</code>
The <code/<span class=ignore/'/{native}<span class=ignore/'// suffix
indicates to the system that this denotes a native functor whose
platform independent basename is <file>?{install}/counter.so</file>.
The module manager dynamically links the appropriate platform specific
shared object library (by appending the platform specific extension to
the basename) and makes available the module it defines as the
value of <code proglang=oz/Cnt/.  The body of your functor can invoke
<code proglang=oz/{Cnt.next}/ to get the next value of the global
counter.</p>
        <p>In the emacs OPI, you can try this out immediately:
<code display proglang=oz
>declare [M] = {Module.link ['?{install}/counter.so{native}']}</code>
</p>
    </section>
  </chapter>

  <chapter id=chapter.counter.object>
    <title/Native Counter Objects/
    <p>In this chapter, we are going to generalize the counter idea:
instead of having just one global counter, we are going to have
counter objects implemented as extensions.  Of course, this is
intended purely as a didactic exercise: such counters could much more
easily be defined as Oz objects directly.</p>
    <section>
      <title/Counter Class/
  </chapter>

</PART>

<!--
Local Variables:
mode: sgml
mode: auto-fill
sgml-default-dtd-file: "part.ced"
sgml-auto-activate-dtd: t
adaptive-fill-mode: nil
End:
-->