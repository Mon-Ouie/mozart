<!--
  - Authors:
  -   Christian Schulte <schulte@dfki.de>
  -
  - Copyright:
  -   Christian Schulte, 1998
  -
  - Last change:
  -   $Date$ by $Author$
  -   $Revision$
  -
  - This file is part of Mozart, an implementation
  - of Oz 3
  -    http://mozart.ps.uni-sb.de
  -
  - See the file "LICENSE" or
  -    http://mozart.ps.uni-sb.de/LICENSE.html
  - for information on usage and redistribution
  - of this file, and for a DISCLAIMER OF ALL
  - WARRANTIES.
  -
  -->

<chapter id="chapter.modman">
  <Title/Module Managers/

  <p>
    So far we only dicussed how functor definitions can be developed
    in a modular fashion. This chapter explains how modular
    applications are executed.

  <section id="section.modman.overview">
    <title/Overview/


  <section id="section.modman.import">
    <title/Import Specifications/

    <p>
      First some names. The entire import part of a functor is called
      <def/import specification/. Each import specification consists
      of several <def/import clauses/. Each import clause consists of
      a mandatory <def/module name/ and an optional <def/module url/
      that must be preceded by an <<at>> keyword.

    <p>
      For example, in the import specification
<<<
import
   DB
   MyForm at 'Form.ozf'
>>> 
      the first import clause is <<DB>> which just consists of the
      module name <<DB>> and does not provide a module url. The second
      import clause is <<Form at 'Form.ozf'>> which consists of the
      module name <<MyForm>> and the module url <<'Form.ozf'>>.

    <p>
      The first step in linking a functor is that the module manager
      computes for each import clause the <def/full module url/. This
      is done according to the following rules:
      <list enum>
        <item>
          If the import clause features a module url ?{U}, the full
          module name is ?_{U}.
        <item>
          If the import clause consists of a module name ?{M} only,
          where ?{M} is the name of a system module, the full url is
          <<x-oz://system/?{M}>>, that is the module name prefixed by
          <<x-oz://system/>>.
        <item>
          If the import clause consists of a module name ?{M} only and
          ?{M} is not the name of system module, the full url is
          <<?{M}.ozf>>, that is the module name suffixed by <<.ozf>>.
      </list>
     
    <p>
      All currently defined system module are listed in <ptr
      to="table.modman.system">.

  <figure class=table id="table.modman.system">
    <caption/System modules./
    <table>
      <tr/<th/Module Name/ <th/Description/ <th/Documentation//
      <tr/<th colspan=3/Application Programming//
      <tr/<td/<<Application>>/
          <td/Command processing and application termination/
          <td/<ptr.extern to="ozdoc:system" key="chapter.application">//
      <tr/<td/<<Module>>/
          <td/Module managers/
          <td/<ptr.extern to="ozdoc:system" key="chapter.module">//
      <tr/<th colspan=3/Constraint Programming//
      <tr/<td/<<Search>>/
          <td/Search engines/
          <td/<ptr.extern to="ozdoc:system" key="chapter.search">//
      <tr/<td/<<FD>>/
          <td/Finite domain propagators and distributors/
          <td/<ptr.extern to="ozdoc:system" key="chapter.fd">//
      <tr/<td/<<FS>>/
          <td/Finite set propagators and distributors/
          <td/<ptr.extern to="ozdoc:system" key="chapter.fs">//
      <tr/<td/<<Schedule>>/
          <td/Scheduling propagators and distributors/
          <td/<ptr.extern to="ozdoc:system" key="chapter.schedule">//
      <tr/<th colspan=3/Distributed Programming//
      <tr/<td/<<Connection>>/
          <td/Connecting to running Oz processes/
          <td/<ptr.extern to="ozdoc:system" key="chapter.connection">//
      <tr/<td/<<Remote>>/
          <td/Remote module managers/
          <td/<ptr.extern to="ozdoc:system" key="chapter.remote">//
      <tr/<td/<<URL>>/
          <td/URL parsing and resolution routines/
          <td/<ptr.extern to="ozdoc:system" key="chapter.url">//
      <tr/<td/<<Resolve>>/
          <td/URL resolving/
          <td/<ptr.extern to="ozdoc:system" key="chapter.resolve">//
      <tr/<td/<<Fault>>/
          <td/Handling faults in distributed programs/
          <td/<ptr.extern to="ozdoc:system" key="chapter.fault">//
      <tr/<th colspan=3/Open Programming//
      <tr/<td/<<Open>>/
          <td/Support for files, sockets, and pipes/
          <td/<ptr.extern to="ozdoc:system" key="chapter.open">//
      <tr/<td/<<OS>>/
          <td/POSIX compliant operating system support/
          <td/<ptr.extern to="ozdoc:system" key="chapter.os">//
      <tr/<th colspan=3/System Programming//
      <tr/<td/<<Pickle>>/
          <td/Saving and loading of persistant values/
          <td/<ptr.extern to="ozdoc:system" key="chapter.pickle">//
      <tr/<td/<<Property>>/
          <td/Querying and configuring engine properties/
          <td/<ptr.extern to="ozdoc:system" key="chapter.property">//
      <tr/<td/<<Error>>/
          <td/Error handling routines/
          <td/<ptr.extern to="ozdoc:system" key="chapter.error">//
      <tr/<td/<<ErrorRegistry>>/
          <td/Registration of error handlers/
          <td/<ptr.extern to="ozdoc:system" key="chapter.errorregistry">//
      <tr/<td/<<Finalize>>/
          <td/Automatic garbage collection for native entities/
          <td/<ptr.extern to="ozdoc:system" key="chapter.finalize">//
      <tr/<td/<<System>>/
          <td/Miscellaneous system related procedures (printing)/
          <td/<ptr.extern to="ozdoc:system" key="chapter.system">//
      <tr/<th colspan=3/Window Programming//
      <tr/<td/<<Tk>>/
          <td/Classes and procedures for window programming/
          <td/<ptr.extern to="ozdoc:system" key="chapter.tk">//
      <tr/<td/<<TkTools>>/
          <td/Predefined abstractions to handle menus, dialogs, and so on/
          <td/<ptr.extern to="ozdoc:system" key="chapter.tktools">//
      <tr/<th colspan=3/Graphical Tools//
      <tr/<td/<<Browser>>/
          <td/Incremental display of Oz values/
          <td/<ptr.extern to="ozdoc:browser">//
      <tr/<td/<<Panel>>/
          <td/Monitor and configure the running engine/
          <td/<ptr.extern to="ozdoc:panel">//
      <tr/<td/<<Explorer>>/
          <td/Visual constraint programming tool/
          <td/<ptr.extern to="ozdoc:explorer">//
      <tr/<td/<<Ozcar>>/
          <td/Interactive debugger/
          <td/<ptr.extern to="ozdoc:ozcar">//
      <tr/<td/<<Profiler>>/
          <td/Profiling of Oz programs/
          <td/<ptr.extern to="ozdoc:profiler">//
      <tr/<th colspan=3/Miscellaneous//
      <tr/<td/<<ObjectSupport>>/
          <td/Generic classes for object oriented applications/
          <td/<ptr.extern to="ozdoc:system" key="chapter.objectsupport">//
    </table>
  </figure>

  </section>
  
  <section id="section.modman.resolve">
    <title/Url Resolution/

    <p>
      Given the full url names for each import clause, the module
      manager determines the urls from which functors are to be
      loaded by <def/url resolution/. Url resolution takes two urls
      (one is called the <def/base url/ and the other is called the
      <def/local url/) as
      input and computes a new <def/resolved url/. The process of
      url resolution you already know from organizing your html-pages:
      a url for a href-link in the document is a local url which
      gets resolved with respect to the url of the containing
      document (the base url).

    <p>
      A module manager does exactly the same as a www-browser. If it
      installs a module that has been loaded from the url ?{U}, the
      its full import urls are resolved with respect to ?{U}.
      <ptr to="figure.modman.resolve"> shows two small examples.

    <figure id="figure.modman.resolve">
      <caption/Examples for resolving urls./
      <p> Gaga
    </figure>
     

  </section>

  <section id="section.modman.link">
    <title/Linking/

  </section>

  <section id="section.modman.user">
    <title/User-defined Module Managers/

    <p>
      When the engine starts it has the root module manager that
      executes the root functor and subsequently links imported
      functors. However, in many cases it is desirable that
      applications can create private module managers that just link
      particular functors.

    <p>
      As an example, suppose we want to use more than a single data
      base as implemented by the functor <file/DB.ozf/ as shown in
      <ptr to="section.development.db">

    

</Chapter>

