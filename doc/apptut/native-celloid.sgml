<!--
  - Authors:
  -   Denys Duchier     <duchier@ps.uni-sb.de>
  -
  - Copyright:
  -   Denys Duchier, 1998
  -
  - Last change:
  -   $Date$ by $Author$
  -   $Revision$
  -
  - This file is part of Mozart, an implementation
  - of Oz 3
  -    http://mozart.ps.uni-sb.de
  -
  - See the file "LICENSE" or
  -    http://mozart.ps.uni-sb.de/LICENSE.html
  - for information on usage and redistribution
  - of this file, and for a DISCLAIMER OF ALL
  - WARRANTIES.
  -
  -->
<chapter id=chapter.celloid proglang=cc>
  <title/Situated Cell-Like Objects/
  <p>In this chapter, we implement <code/&cc.class;Celloid/s: an
extension class for objects that behave essentially like cells; they
have content which can be accessed (read) and assigned (written).  The
new challenge here is twofold: (1) since the content may be any Oz
value, a <code/&cc.class;Celloid/ must be <em/situated/, (2) during
garbage collection the content of a <code/&cc.class;Celloid/ must also
be copied.</p>
  <p>What does <def/situated/ mean?  Simply that the object resides in
one specific constraint store, aka a space.  If
<code/&cc.class;Celloid/ <code/C/ resides in space S1, and S2 is a
subspace of S1 (&ie; is subordinated to S1), it is meaningful for a
thread in S2 to <em/access/ <code/C/ since any constraint (therefore
value) from S1 are visible in S2, but it is generally not meaningful
for a thread in S2 to <em/assign/ <code/C/ since constraints
(therefore values) specific to S2 are not visible from S1.  Our
implementation will enforce the appropriate restrictions.</p>

  <section>
    <title/Celloid Class/
    <p>Here we need to subclass <code/&cc.class;OZ_SituatedExtension/
which has the same interface as before but equips its instances with a
home space.
<code display>
#include "mozart.h"

class Celloid : public OZ_SituatedExtension {
public:
  OZ_Term content;
  Celloid(OZ_Term t):content(t){}
  static int id;
  virtual int getIdV() { return id; }
  virtual OZ_Term typeV() { return OZ_atom("celloid"); }
  virtual OZ_Extension* gcV();
  virtual void gcRecurseV();
  virtual OZ_Term printV(int depth = 10);
};
</code></p>
  </section>

  <section>
    <title/Celloid Creation/
    <p>The <code/celloid_new/ builtin takes one input argument
<code/t/, creates a new celloid whose content is initialized to
<code/t/, boxes it and returns the result.
<code display>
OZ_BI_define(celloid_new,1,1)
{
  OZ_declareTerm(0,t);
  OZ_RETURN(OZ_extension(new Celloid(t)));
}
OZ_BI_end
</code></p>
  </section>

  <section>
    <title/Type Testing/
    <p>The definitions here are similar to the ones presented earlier
for the <code/&cc.class;Counter/ class.
<code display>
int Celloid::id;

inline OZ_Boolean OZ_isCelloid(OZ_Term t)
{
  t = OZ_deref(t);
  return OZ_isExtension(t) &&
    OZ_getExtension(t)->getIdV()==Celloid::id;
}

OZ_BI_define(celloid_is,1,1)
{
  OZ_declareDetTerm(0,t);
  OZ_RETURN_BOOL(OZ_isCelloid(t));
}
OZ_BI_end
</code></p>
  </section>

  <section>
    <title/Expecting Celloid Arguments in Builtins/
    <p>Again this is similar to the <code/&cc.class;Counter/ class: we
define an unboxing function and a convenience macro.
<code display>
inline Celloid* OZ_CelloidToC(OZ_Term t)
{
  return (Celloid*) OZ_getExtension(OZ_deref(t));
}

#define OZ_declareCelloid(ARG,VAR) \
OZ_declareType(ARG,VAR,Celloid*,"celloid",OZ_isCelloid,OZ_CelloidToC)
</code></p>
  </section>

  <section>
    <title/Operations on Celloids/
    <p>First, we provide an <em/access/ builtin that retrieves the content
of the celloid.
<code display>
OZ_BI_define(celloid_access,1,1)
{
  OZ_declareCelloid(0,c);
  OZ_RETURN(c->content);
}
OZ_BI_end
</code>
Second, we provide an <em/assign/ builtin that sets the content of
the celloid.  This operation should only be allowed for a thread
executing in the home space of the celloid.  For a thread executing in
a subordinated space, an exception will be raised.
<code display>
OZ_BI_define(celloid_assign,2,0)
{
  OZ_declareCelloid(0,c);
  OZ_declareTerm(1,t);
  if (c->isLocalV()) { content = t; return PROCEED; }
  else return OZ_raiseErrorC("celloid",3,OZ_atom("nonLocal"),
                             OZ_in(0),OZ_in(1));
}
OZ_BI_end
</code>
virtual member function <code/isLocalV()/ indicates whether the
current space is the home space of the celloid.  If yes, we set the
content to the given argument; if no, we raise an
error. <code/OZ_in(?{n})/ refers to the ?{n}th input argument of the
builtin.</p>
  </section>

  <section>
    <title/Printing Support/
    <p>We provide here only minimal printing support.
<code display>
OZ_Term Celloid::printV(int depth = 10)
{
  return OZ_atom("&lt;celloid&gt;");
}
</code></p>
  </section>

  <section>
    <title/Garbage Collection/
    <p>The first part of garbage collection is as before: we create a
new instance of <code/&cc.class;Celloid/ initialized with the current
content of the celloid that is being copied by gc.
<code display>
OZ_Extension* Celloid::gcV() { return new Celloid(content); }
</code>
The second part involves recursively copying the content of the
celloid.  This is implemented in a different virtual function:
<code display>
void Celloid::gcRecurseV() {
  OZ_collectHeapTerm(content,content);
}
</code>
The procedure <code/OZ_collectHeapTerm(OZ_Term&amp;,OZ_Term&amp;)/
performs the gc copy of its 1st argument into its 2nd argument.  Here
they are identical (this is the usual case).</p>
    <p>You may wonder: why not perform the recursive copy of the
content in <code/gcV()/ itself.  Under no circumstances should you do
this!  It would break essential invariants in the garbage collector.
GC copy must proceed in these 2 phases:
<list enum>
        <item><code/gcV()/ creates a new instance (on the <em/to/
heap) and initializes it with the current contents of the object being
gced.
        <item><code/gcRecurseV()/ is at some subsequent point invoked
on the new instance and should perform the gc copy and update of its
contents.
</list></p>
  </section>

  <section>
    <title/Native Functor/
    <p>Again, we proceed as before:
<code display>
extern "C"
{
  OZ_C_proc_interface * oz_init_module(void)
  {
    static OZ_C_proc_interface table[] = {
      {"new",1,1,celloid_new},
      {"is",1,1,celloid_is},
      {"access",1,1,celloid_access},
      {"assign",2,0,celloid_assign},
      {0,0,0,0}
    };
    Celloid::id = OZ_getUniqueId();
    return table;
  }
}
</code>
Assuming the code above is put in file <file/native-celloid.cc/, we
first compile and then create a DLL as follows
<code display proglang=sh>
oztool c++ -I/usr/local/oz/include -c native-celloid.cc
oztool ld native-celloid.o -o native-celloid.so-`oztool platform`
</code></p>
  </section>

  <section>
    <title/Oz Wrapper Module/
    <p>Here, we hardly need an Oz wrapper module.  Unlike for counter
objects, we don't need to register celloid for finalization: there are
no resources off the heap.  However, we can provide a nice error print
formatter for the case when an access is attempted from without the
celloid's home space.
<code.extern display to="celloid.oz" proglang=oz></p>
  </section>
</chapter>

<!--
Local Variables:
mode: sgml
mode: auto-fill
sgml-default-dtd-file: "chapter.ced"
sgml-auto-activate-dtd: t
adaptive-fill-mode: nil
End:
-->
