<!--
  - Authors:
  -   Christian Schulte <schulte@dfki.de>
  -
  - Copyright:
  -   Christian Schulte, 1998
  -
  - Last change:
  -   $Date$ by $Author$
  -   $Revision$
  -
  - This file is part of Mozart, an implementation
  - of Oz 3
  -    http://mozart.ps.uni-sb.de
  -
  - See the file "LICENSE" or
  -    http://mozart.ps.uni-sb.de/LICENSE.html
  - for information on usage and redistribution
  - of this file, and for a DISCLAIMER OF ALL
  - WARRANTIES.
  -
  -->

<Chapter id="Chapter.Development">
  <Title/Application Development/

  <p>
    The last chapter (<ptr to="chapter.hello">) used a rather simple
    application as example. This chapter shows how to use functors for
    the modular development of larger applications.

  <section id="section.development.functors">
    <title/Functors for Modular Applications/

    <p>
      Larger applications are usually decomposed in several
      modules. Oz supports modular programs by applications that are
      implemented by multiple functor definitions. 

    <p>
      A functor is a function computing with modules: It takes modules
      as input and computes a new module as output. As we have seen
      already, the <<import>> part of a functor defines its inputs by
      a list of module names. In addition, functors also allow for an
      <<export>> part. The <<export>> part of functor is basically a
      list of feature value pairs that describe the module computed by
      the functor.

    <p>
      As we have already seen in <ptr to="section.hello.exec"> an
      application is run by executing the root functor. In
      our particular example, the root functor restricted itself by
      only importing system modules. However, larger applications will
      import modules computed by other functors.

    <p>
      The module names internet wide

      dynamic linking


  <section id="section.devel.lmf">
    <title/Example: Last Minute Flights/

    <p>
      In the following we will build a mickey mouse flight booking
      system. The booking system features three components: 

    <p>
      <list enum>
        <item> 
          A data base server: It maintains a data base that contains
          available flights, where each flight as a unique id by which
          it can be identified. In the beginning, the data base will
          be not even persistent, but as this documents goes along,
          the data base evolves into a persistent and distributed data
          base server. 

        <item>
          A graphical flight booking form, where a travel-minded user
          can choose a flight, enter her name, her E-mail address and
          so on. Later we will show how to build a web-based interface
          serving the same purpose.

        <item>
          The main component of our application that manages user
          requests to the data base and sets up the application. 

      </list>

    <p>
      All components are programmed as functors.


  <section id="section.development.db">
    <title/The Data Base/

    <p>
      Let us start with the data base, which is the most
      straightforward part of our application. The data will be held
      in a dictionary that uses integers as keys, and arbitrary data
      structures as entries. The toplevel structure of the functor is
      as follows:

    <p>     
<chunk><title/DB.oz/
functor
  <chunk.ref/Export specification for DB.oz/
  <chunk.ref/Body for DB.oz/
end
</chunk>

    <p>
      The functor has no import specification, the export
      specification of <file/DB.oz/ is as follows:

    <p>
<chunk><title/Export specification for DB.oz/
export
   add:    Add
   get:    Get
   getAll: GetAll
   remove: Remove
</chunk>

    <p>
      The specification determines that the functor's module provides the
      features <<add>>, <<get>>, <<getAll>>, and <<remove>>, where the
      fields at that features are given by the respective variables
      following the feature after the colons. The values for the
      fields are then computed by the functors body.

    <p>
      Using syntactics sugar, we can write the export specification as
      follows: 

    <p>
<chunk><title/Export specification for DB.oz (with syntactic sugar)/
export
   Add
   Get
   GetAll
   Remove
</chunk>

    <p>
      The shortcut to just use an variable identifier starting with a
      capital letter, defines both the variable identifier as well as
      the feature. The feature is the variable identifier with its
      first character changed to lowercase.

    <p>
      The functor body is of less importance to us here, however, you
      can find it in <ptr to="section.code.development">. One
      advantage of modular programs is that during design of an
      application one is concerned first with finding the right
      interfaces, and only then provide implementations.

    <p>
      Even though the functor does not import any module, it uses
      predefined procedures (for example, <<Dictionary.new>> to
      create a new dictionary). The compiler provides a set
      of variable identifiers, that refer to the basic operations on
      data structures Oz provides. This set of identifiers is referred
      to as the <def/base environment/. The base environment is
      documented in detail in <ptr.extern to="ozdoc:base">. 

    <p>
      When a functor definition is compiled all free variable
      identifiers must be bound by the base environment. Pickling the
      functor created by compilation then includes all values referred
      to by the free identifiers. We are going to discuss the issue of
      pickling in more detail in ????.

  <section id="section.development.form">
    <title/The Graphical Input Form/

    <p>
      The functor that implements the graphical form to book flights
      has the following structure:

    <p>
<chunk><title/Form.oz/
functor
import
   Tk
export
   Book
define
   proc {Book Fs ?Get}
      %% Takes a list of flights and returns the booked flight
      %% and information on the booking user
      <chunk.ref/Implementation of Book/
   end
end

</chunk>
     

  <section id="section.development.root">
    <title/The Root Functor/

    <p>
      The root functor for our last minute flights application uses
      the previously defined functors that maintain the data base and
      that provide the user form.

    <p>
<chunk><title/LMF.oz/
functor
import
   DB Form            % User defined
   System Application % System
define
   %% Enter some flights
   {ForAll <chunk.ref/Sample flights/ DB.add}
   %% Book until all flights sold out
   proc {Book}
      case {DB.getAll}
      of nil then
	 {System.showInfo 'All flights sold.'}
      [] Fs then
	 O={Form.book Fs}
      in
	 {System.showInfo ('Booked: '#O.key#' for: '#O.first#' '#O.last#
			   ' ('#O.email#')')}
	 {DB.remove O.key}
	 {Book}
      end
   end
   {Book}
   {Application.exit 0}
end
       
</chunk>
    
  <Section id="Section.Development.OPI">
    <Title/Exploration: The Oz Programming Interface/

  </Section>



  <Section id="Section.Development.SystemFunctors">
    <Title/System Functors/

  </Section>

  <Section id="Section.Development.Multiple">
    <Title/Organizing with Multiple Functors/

  </Section>

  <Section id="Section.Development.URL">
    <Title/Using URLs/

  </Section>

  <section id="section.development.system">
    <title/System Modules/

    <p>
      Mozart provides the following system modules:

    <table>
      <tr/<th/Module Name/ <th/Description/ <th/Documentation//
      <tr/<th colspan=3/Application Programming//
      <tr/<td/<<Application>>/
          <td/Command processing and application termination/
          <td/<ptr.extern to="ozdoc:system" key="chapter.application">//
      <tr/<td/<<Module>>/
          <td/Module managers/
          <td/<ptr.extern to="ozdoc:system" key="chapter.module">//
      <tr/<th colspan=3/Constraint Programming//
      <tr/<td/<<Search>>/
          <td/Search engines/
          <td/<ptr.extern to="ozdoc:system" key="chapter.search">//
      <tr/<td/<<FD>>/
          <td/Finite domain propagators and distributors/
          <td/<ptr.extern to="ozdoc:system" key="chapter.fd">//
      <tr/<td/<<FS>>/
          <td/Finite set propagators and distributors/
          <td/<ptr.extern to="ozdoc:system" key="chapter.fs">//
      <tr/<td/<<Schedule>>/
          <td/Scheduling propagators and distributors/
          <td/<ptr.extern to="ozdoc:system" key="chapter.schedule">//
      <tr/<th colspan=3/Distributed Programming//
      <tr/<td/<<Connection>>/
          <td/Connecting to running Oz processes/
          <td/<ptr.extern to="ozdoc:system" key="chapter.connection">//
      <tr/<td/<<Remote>>/
          <td/Remote module managers/
          <td/<ptr.extern to="ozdoc:system" key="chapter.remote">//
      <tr/<td/<<URL>>/
          <td/URL parsing and resolution routines/
          <td/<ptr.extern to="ozdoc:system" key="chapter.url">//
      <tr/<td/<<Resolve>>/
          <td/URL resolving/
          <td/<ptr.extern to="ozdoc:system" key="chapter.resolve">//
      <tr/<td/<<Fault>>/
          <td/Handling faults in distributed programs/
          <td/<ptr.extern to="ozdoc:system" key="chapter.fault">//
      <tr/<th colspan=3/Open Programming//
      <tr/<td/<<Open>>/
          <td/Support for files, sockets, and pipes/
          <td/<ptr.extern to="ozdoc:system" key="chapter.open">//
      <tr/<td/<<OS>>/
          <td/POSIX compliant operating system support/
          <td/<ptr.extern to="ozdoc:system" key="chapter.os">//
      <tr/<th colspan=3/System Programming//
      <tr/<td/<<Pickle>>/
          <td/Saving and loading of persistant values/
          <td/<ptr.extern to="ozdoc:system" key="chapter.pickle">//
      <tr/<td/<<Property>>/
          <td/Querying and configuring engine properties/
          <td/<ptr.extern to="ozdoc:system" key="chapter.property">//
      <tr/<td/<<Error>>/
          <td/Error handling routines/
          <td/<ptr.extern to="ozdoc:system" key="chapter.error">//
      <tr/<td/<<ErrorRegistry>>/
          <td/Registration of error handlers/
          <td/<ptr.extern to="ozdoc:system" key="chapter.errorregistry">//
      <tr/<td/<<Finalize>>/
          <td/Automatic garbage collection for native entities/
          <td/<ptr.extern to="ozdoc:system" key="chapter.finalize">//
      <tr/<td/<<System>>/
          <td/Miscellaneous system related procedures (printing)/
          <td/<ptr.extern to="ozdoc:system" key="chapter.system">//
      <tr/<th colspan=3/Window Programming//
      <tr/<td/<<Tk>>/
          <td/Classes and procedures for window programming/
          <td/<ptr.extern to="ozdoc:system" key="chapter.tk">//
      <tr/<td/<<TkTools>>/
          <td/Predefined abstractions to handle menus, dialogs, and so on/
          <td/<ptr.extern to="ozdoc:system" key="chapter.tktools">//
      <tr/<th colspan=3/Graphical Tools//
      <tr/<td/<<Browser>>/
          <td/Incremental display of Oz values/
          <td/<ptr.extern to="ozdoc:browser">//
      <tr/<td/<<Panel>>/
          <td/Monitor and configure the running engine/
          <td/<ptr.extern to="ozdoc:panel">//
      <tr/<td/<<Explorer>>/
          <td/Visual constraint programming tool/
          <td/<ptr.extern to="ozdoc:explorer">//
      <tr/<td/<<Ozcar>>/
          <td/Interactive debugger/
          <td/<ptr.extern to="ozdoc:ozcar">//
      <tr/<td/<<Profiler>>/
          <td/Profiling of Oz programs/
          <td/<ptr.extern to="ozdoc:profiler">//
      <tr/<th colspan=3/Miscellaneous//
      <tr/<td/<<ObjectSupport>>/
          <td/Generic classes for object oriented applications/
          <td/<ptr.extern to="ozdoc:system" key="chapter.objectsupport">//
    </table>
  </section>

<!--
- compilation unit

-->

</Chapter>

