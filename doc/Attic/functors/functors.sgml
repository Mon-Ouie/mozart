<!DOCTYPE Book SYSTEM "ozdoc.dtd" [

<!-- Extension to the DTD -->
<!ENTITY % p.mix.local "|Em">
<!ELEMENT Em - - (#PCDATA)>
<!ENTITY % proglang.values.local "|sh">

<!-- Processing Instructions -->
<!ENTITY nbsp PI "nbsp">
<!ENTITY ie PI "ie">
<!ENTITY eg PI "eg">

]>

<Book proglang=oz>
  <Front>
    <!-- Splitting the document into different HTML nodes -->
    <Meta name="html.split" value="chapter.syntaxspecification">
    <Meta name="html.split" value="chapter.example">

    <Meta name=ozversion value="3.0">
    <Meta name=status value=revised>
    <Title/The Syntax of Functors in Oz/
    <Author.Extern to="author.db" key="Leif.Kornstaedt">
    <Abstract>
      This document describes the syntax of functors in Oz.
    </Abstract>
  <Body>
    <Chapter id="chapter.syntaxspecification">
      <Title/Syntax Specification/
      <Section>
	<Title/Functor Definitions/
	<P>
	  Functors can be defined either at file level or as embedded
	  functors.  For functors defined at file level the bracketing
	  keywords <<functor>> and <<end>> may be omitted.
	  <Grammar.Rule>?={file}
	    <Grammar.Alt type=add>{ ?={functor descriptor} }+</Grammar.Alt>
	<P>
	  Embedded functors at statement or expression position are always
	  introduced by the <<functor>> keyword.  The expression following it
	  is a pattern position (&ie;, if it is a variable, it is introduced
	  implicitly).  At expression position, the nesting marker may be
	  omitted (as is the case with class definitions).  Execution of a
	  functor definition produces a chunk.
	  <Grammar.Rule>?={statement}
	    <Grammar.Alt type=add><<functor>> ?={expression}</Grammar.Alt>
	    <Grammar.Alt>{ ?={functor descriptor} }</Grammar.Alt>
	    <Grammar.Alt><<end>></Grammar.Alt>
	  <Grammar.Rule>?={expression}
	    <Grammar.Alt type=add><<functor>> [ <Q class=terminal
	      /$/ ]</Grammar.Alt>
	    <Grammar.Alt>{ ?={functor descriptor} }</Grammar.Alt>
	    <Grammar.Alt><<end>></Grammar.Alt>
      <Section>
	<Title/Import Declarations/
	<P>
	  <Grammar.Rule>?={functor descriptor}
	    <Grammar.Alt type=add
	      ><<import>> { ?={import declaration} }+</Grammar.Alt>
	<P>
	  Each module to be linked to the functor currently being defined
	  is given by its name as a variable.  This is a binding occurrence,
	  with scope limited to the import declarations, export declarations
	  and body.  All the imported modules' names must be dinstinct.
	  The other parts of an import declaration are detailed below.
	  <Grammar.Rule>?={import declaration}
	    <Grammar.Alt type=def>?={naked variable}</Grammar.Alt>
	    <Grammar.Alt>[ ?={import at} ]</Grammar.Alt>
	    <Grammar.Alt type=or
	      >?={variable label} ?={import features}</Grammar.Alt>
	    <Grammar.Alt>[ ?={import at} ]</Grammar.Alt>
	<Para class=apropos><Title/Restricting the Import/
	  Access to an imported module may be restricted to a given set of
	  features.  In the presence of such a restriction, the module name
	  may only be used in a record selection (with the dot operator), where
	  the given feature must be a manifest constant and a valid feature
	  (&ie;, the module may no longer be used first-class).  This
	  restriction is enforced at compile time.
	  <Grammar.Rule>?={import features}
	    <Grammar.Alt type=def
	      ><Q class=terminal
	      /<<(>>/ { ?={import feature} ?={import alias} }+ <Q
	      class=terminal/<<)>>/</Grammar.Alt>
	  <Grammar.Rule>?={import feature}
	    <Grammar.Alt type=def>?={atom} | ?={int}</Grammar.Alt>
	<Para class=apropos><Title/Import Aliases/
	  For convenience, aliases may be introduced for the values of the
	  imported module's subtrees.
	  <Grammar.Rule>?={import alias}
	    <Grammar.Alt type=def
	      >[ <Q class=terminal/<<:>>/ ?={naked variable} ]</Grammar.Alt>
	<Para class=apropos><Title/Specifying URLs/
	  The aditional <<at>> clause allows to specify a URL indicating where
	  to look for the pickled functor (which should carry the extension
	  <File/.ozf/).
	  <Grammar.Rule>?={import at}
	    <Grammar.Alt type=def><<at>> ?={atom}</Grammar.Alt>
	<P>
	  The URL may be relative, in which case it is resolved with respect
	  to the absolute URL associated with the functor in which it appears.
	  If the URL is omitted, then either
	  <List>
	    <Item>
	      the specified module name is the name of a system module, or
	    <Item>
	      a relative URL is implied by appending <File/.ozf/ to the
	      module name (as an atom).
	  </List>
	  Several special URLs are recognized by the link loader:
	  <List>
	    <Entry><<'x-oz://boot/?{module}'>>
	    <Item>
	      designates a boot module, &ie;, a module consisting of
	      builtins (constructed by the emulator).
	    <Entry><<'x-oz://system/?{module}'>>
	    <Item>
	      explicitly imports a system module.
	  </List>
      <Section>
	<Title/Export Declarations/
	<P>
	  The export descriptor specifies how the module record created by
	  an application of this functor will look like.
	  <Grammar.Rule>?={functor descriptor}
	    <Grammar.Alt type=add
	      ><<export>> { ?={export declaration} }+</Grammar.Alt>
	<Para class=apropos><Title/Export Features/
	  The value of the given variable is made available under the given
	  feature.  If the feature is omitted, then the feature is computed
	  from the variable's print name by changing its initial capital
	  letter into a lower-case letter (unless it's a backquote variable,
	  in which case the print name is taken as-is).
	  <Grammar.Rule>?={export declaration}
	    <Grammar.Alt type=def>[ ?={module feature} <Q class=terminal
	      /<<:>>/ ] ?={naked variable}</Grammar.Alt>
	<P>
	  Note that the variables mentioned in the export are not binding
	  but referring occurrences.
      <Section>
	<Title/Functor Bodies/
	<P>
	  The statement in the body (usually a sequence of definitions) is
	  a pattern position.  Note that the semantics of the abbreviated
	  <<local>> construct differ from the usual semantics in, &eg;,
	  procedure bodies:  It is the second statement after the <<in>>
	  keyword that's optional, not the first one.
	  <Grammar.Rule>?={functor descriptor}
	    <Grammar.Alt type=add
	      ><<define>> ?={statement} [ <<in>> ?={statement} ]</Grammar.Alt>
	<P>
	  Variables introduced in the body are visible in the body
	  <Em/and/ the export declaration.  By this it is possible to
	  include an arbitrary number of definitions in the body but to
	  export only a subset of them, without having to reorder the
	  <<local>> declarations.  This allows for a very natural formulation
	  of functors.
      <Section>
	<Title/Computed Functors/
	<P>
	  A functor that contains one of the following additional functor
	  descriptors is called a <Def/computed functor/.
	  <Grammar.Rule>?={functor descriptor}
	    <Grammar.Alt type=add
	      ><<require>> { ?={import declaration} }</Grammar.Alt>
	    <Grammar.Alt type=or><<prepare>> { ?={statement} }</Grammar.Alt>
	<P>
	  A computed functor such as in <Ptr to="program.computedfunctor.lhs">
	  (in which the variables <<Rs>>, <<Ps>>, <<Is>>, <<Es>>
	  and&nbsp;<<Ds>> are meta variables) is rewritten to two
	  nested non-computed functors as illustrated by
	  <Ptr to="program.computedfunctor.rhs">, where <<F>> stands for
	  a fresh variable otherwise not occurring in the program and
	  <<N>> for the name of the file in which the functor resides
	  (as a virtual string).  The procedure <<`ApplyFunctor`>> is
	  defined in <Ptr to="program.applyFunctor">.
	  <Figure float id="program.computedfunctor.lhs" class=program>
	    <Caption/A computed functor./
	    <P>
	      <Code.Extern display to="Computed1.oz">
	  </Figure>
	  <Figure float id="program.computedfunctor.rhs" class=program>
	    <Caption/The rewritten computed functor./
	    <P>
	      <Code.Extern display to="Computed2.oz">
	  </Figure>
	  <Figure float id="program.applyFunctor" class=program>
	    <Caption/The run-time library procedure <<`ApplyFunctor`.>>/
	    <P>
	      <Code.Extern display to="ApplyFunctor.oz">
	  </Figure>
    <Chapter id="chapter.example">
      <Title/Example/
      <Section>
	<Title/Defining a Functor/
	<P>
	  <Ptr to="program.functor.fileoperations"> defines an example functor
	  importing two features from <<Open>>.  It defines a class and two
	  procedures and exports one of them on its default feature.  Assuming
	  the functor resides on a file named <File/FileOperations.oz/, it
	  may be compiled and pickled by the following command:
	  <Code display proglang=sh
	  /ozc -c FileOperations.oz -o FileOperations.ozf/
	  <Figure float id="program.functor.fileoperations" class=program>
	    <Caption/An example functor./
	    <P>
	      <Code.Extern display to="FileOperations.oz">
	  </Figure>
      <Section>
	<Title/Using the Functor from Another Functor/
	<P>
	  <Ptr to="program.functor.test"> defines a functor that imports the
	  <<System.show>> procedure and the module that may be obtained by the
	  functor defined above.  The export is empty; this functor will only
	  be linked for its side-effects.  After compiling it with the command
	  <Code display proglang=sh/ozc -c Test.oz -o Test.ozf/
	  this can be done by issuing (&eg;, from the OPI):
	  <!--** Module.load -> Module.manager -->
	  <<<{Wait {Module.load '' 'Test.ozf'}}>>>
	  <Figure float id="program.functor.test" class=program>
	    <Caption/An example functor using the previous functor./
	    <P>
	      <Code.Extern display to="Test.oz">
	  </Figure>
      <Section>
	<Title/Creating a Syslet/
	<P>
	   <Ptr to="program.syslet.wc"> defines a functor from which a syslet
	   is built by the following command:
	   <Code display proglang=sh/ozc -x Syslet.oz -o wc/
	   Since syslets are described elsewhere, we will not go into further
	   detail here.
	   <Figure float id="program.syslet.wc" class=program>
	     <Caption/An example functor using the previous functor./
	     <P>
	       <Code.Extern display to="Syslet.oz">
	   </Figure>
</Book>
