<!DOCTYPE Book SYSTEM "ozdoc.dtd" [

<!-- Extension to the DTD -->
<!ENTITY % proglang.values.local "|sh">

<!-- Abbreviations -->
<!ENTITY amp "&">
<!ENTITY OPI "OPI">

<!-- Processing Instructions -->
<!ENTITY ellipsis PI "ellipsis">
<!ENTITY slash PI "slash">
<!ENTITY nbsp PI "nbsp">
<!ENTITY eg PI "eg">
<!ENTITY ie PI "ie">
<!ENTITY wrt PI "wrt">
<!ENTITY resp PI "resp">
<!ENTITY etc PI "etc">

]>

<Book proglang=elisp>
  <Front>
    <Title/The Oz Programming Interface/
    <Author.Extern to="author.db" key="Andreas.Sundstroem">
    <Abstract>
This small tutorial will help you getting started interacting with the Mozart
development system. It shows you the most fundamental functions of the Oz 
Programming Interface (OPI) which is the primary tool for this purpose. For 
more detailed information about the OPI you should read the reference 
documentation for it&nbsp;<Ptr to="Mozart-OPI">.
    </Abstract>
  <Body>

<Chapter>
  <Title/Starting OPI/
    <P>
Firstly we should start the OPI. If you are using Unix type <<oz>> at the 
shell prompt. If you are using Windows the installation procedure have 
provided you with a Mozart system program group. Click on the Mozart item 
in this group. After starting the OPI you will get a window. 
<P>
The OPI is built around the Emacs editor. To edit text you would need to be a 
bit familiar with the general editing commands of Emacs. This document will 
also use some standard Emacs terminology. To get acquainted with Emacs you can 
use the Emacs on-line tutorial&nbsp;<Ptr to="stallman91">, available from the 
Help menu of the OPI (or from any Emacs).
<P>
When the interface has just been started the Emacs window is split in to two
text buffers. The upper text buffer called <Def/Oz/ is a space where you can 
write small pieces of Oz code and then feed them to the system. The lower text 
buffer will give you feedback from the system. This buffer is called 
<Def/*Oz Compiler*/. When using the system you will however toggle between 
looking at this buffer and the buffer called <Def/*Oz Emulator*/.

<P>
</CHAPTER>
<Chapter>
  <Title/One first example/
    <P>
Let us start with an example. Write:

<<<{Show 'Tinman'}>>>

in the Oz buffer. Then feed this newly written Oz code to the compiler.
This can be done by using the key command <Key/M-RET/ or by choosing Feed 
Buffer from the Oz menu. In the <Def/*Oz Compiler*/ buffer you now can see the 
following:

<P>
<Code proglang=cc>
Mozart Compiler 3.0.10 of Nov 24 1998 (14:19:01) playing Oz 3

{Show 'Tinman'}
% -------------------- accepted
</Code>
<P>

This means that the code <<{Show 'Tinman'}>> has been feed to the compiler and
the compiler has compiled the code and accepted it as correct Oz code. After 
the compilation the program is fed to the emulator and run. If you give the 
command <Key/C-c C-e/ (or by choosing Show/Hide Emulator from the Oz menu) you will see 
the <Def/*Oz Emulator*/ buffer instead of the <Def/*Oz Compiler*/ buffer. In 
this buffer you can now see the following:

<P>
<Code proglang=cc>
Mozart Engine 3.0.10 of Nov 23 1998 (16:53:55) playing Oz 3

'Tinman'
</Code>
<P>

Printing <<'Tinman'>> is the result of the program. To get back to the 
<Def/*Oz Compiler*/ buffer use the command <Key/C-c C-c/.

</CHAPTER>
<Chapter>
  <Title/The different text buffers/
    <P>

The <Def/Oz/ buffer is used to feed small Oz code examples to the compiler. 
If you don't want to feed the whole buffer to the compiler you can feed parts 
of the buffer. More about this later. When making bigger Oz programs you would 
probably use an other buffer associated with a file where the program is saved.
If you load a file with the extension <Code proglang=cc>.oz</Code> to a buffer,
the buffer will automatically be in <<oz-mode>> which will enable you to feed 
the program to the compiler.
<P>
The <Def/*Oz Compiler*/ buffer gives you feedback from the compiler. It will
for example give you information of what code or files that have been fed, 
weather the code contains error or not and give you help finding errors (if
there are any). 
<P>
The <Def/*Oz Emulator*/ buffer gives you, as you may have guessed, feedback 
from the emulator. That can be output from the program (using for example the 
Show procedure) or reports of runtime errors.

</CHAPTER>
<Chapter>
  <Title/Feeding code to the compiler/
<P>
	  The commands that sends regions of the current buffer to the Oz
	  Compiler for compilation come in four flavors:
	  <List>
	    <Item>
	      Feeding the whole buffer.
	    <Item>
	      Feeding the currently marked region. Marking a region can be 
	      done by sweeping over the code with the mouse holding down 
	      the left button. For more informations about regions use Emacs 
	      documentation.
	    <Item>
	      Feeding the line where the cursor currently is.
	    <Item>
	      Feeding the paragraph where the cursor currently is. A paragraph 
	      is a region of text delimited by empty lines, &ie;, lines not 
	      even containing whitespace.  
	  </List>
<P>
These commands can be found under the Oz menu or you can use the key commands
<Key/M-RET/, <Key/M-r/, <Key/M-l/, or <Key/C-c C-p/ respectively.
</CHAPTER>

<Chapter>
  <Title/A non correct example/
    <P>
Try feeding this code:

<<<local A B in
   A = 3
   proc {B}
      {Show A + 'Tinman'}
   end
   {B 7}
end>>>

The <Def/*Oz Compiler*/ buffer prints two error messages. Type <Key/C-x '/ to 
see the first error message. Now the <Def/*Oz Compiler*/ buffer will scroll so 
that the first error message is visible. In the buffer where the code is, the 
cursor have now moved. The cursor point out where the bug may be located. Type
<Key/C-x '/ once more and you will see the next error message.
</CHAPTER>

<Chapter>
  <Title/Closing OPI/
    <P>
If you would like to leave the OPI type <Key/C-x C-c/ or choose 
<Def/Exit Emacs/ from the <Def/Files/ meny.
</CHAPTER>

  <Back>
    <Bib.Extern id="Mozart-OPI" to="mozart.bib" key="Mozart-OPI">
    <Bib.Extern id="stallman91" to="opi.bib" key="stallman91">
</Book>
