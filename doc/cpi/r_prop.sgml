<section id="r_prop">
<title/The class <<OZ_Propagator>>/

<p>
This class is the base class of all propagators to be implemented. Since
this class is a virtual base class, it is not possible to create an
instance of that class.
<p>
<!--
<subsection id="r_prop.misc">
<title/Miscellaneous/

<para class=apropos><title/<<operator &lt;&lt >>/
<em/operator/<p>
<<
ostream &amp; operator &lt;&lt (ostream &amp; ofile,
                      const OZ_Propagator &amp; p);
>>
<p>
This operator outputs a textual representation of the propagator
<<p>> to the stream <<ofile>>.
<p>
-->

<subsection id="r_prop.constr">
<title/Constructor and Destructor Member Functions/
<p>

<para class=apropos><title/<<OZ_Propagator>>/
<em/default constructor/<p>
<<
OZ_Propagator(void);
>>
<p>
This constructor is to be called whenever an instance of a class derived
from <<OZ_Propagator>> is created.
<p>

<para class=apropos><title/<<~OZ_Propagator>>/
<em/virtual destructor/<p>
<<
virtual ~OZ_Propagator();
>>
<p>
This destructor is defined to be virtual to force the destructors in the
derived classes to be virtual. This ensure that destroying a derived
class results in calling the destructor of the derived class.
<p>

<subsection id="r_prop.operator">
<title/Operator Member Functions/
<p>


<para class=apropos><title/<<operator new>>/
<em/static operator member function/<p>
<<
static void * operator new(size_t);
>>
<p>
This operator allocates the appropriate amount of heap memory when a
propagator is created.
<p>

<para class=apropos><title/<<operator delete>>/
<em/static operator member function/<p>
<<
static void operator delete(void *, size_t);
>>
<p>
This operator deallocates the heap memory occupied by a propagator when
it is destroyed.
<p>

<subsection id="r_prop.provided">
<title/Provided Member Functions/
<p>

<para class=apropos><title/<<mayBeEqualVars>>/
<em/member function/<p>
<<
OZ_Boolean mayBeEqualVars(void);
>>
<p>
This member function returns <<OZ_TRUE>> if at least one variable the
propagator was imposed on has been unified. Otherwise it returns
<<OZ_FALSE>>. See <ptr to="u_advanced.detect"> for details.
<p>

<para class=apropos><title/<<replaceBy>>/
<em/overloaded member function/<p>
<<
OZ_Return replaceBy(OZ_Propagator * p);
>>
<p>
This member function replaces the current propagator (&ie <<*this>>)
by the propagator <<p>>.
<p>
<<
OZ_Return replaceBy(OZ_Term a, OZ_Term b);
>>
<p>
This member function replaces the current propagator (&ie <<*this>>)
by the equality constraint between <<a>> and <<b>>.
<p>
Caution: before <<replaceBy>> can be called, for all
<<x>> of type <<OZ_FDIntVar>> the member function <<x.leave()>> has
to be called.
<p>

<para class=apropos><title/<<replaceByInt>>/
<em/member function/<p>
<<
OZ_Return replaceByInt(OZ_Term v, int i);
>>
<p>
This member function replaces the current propagator (&ie <<*this>>)
by the equality constraint between <<v>> and <<i>>.
<p>

<para class=apropos><title/<<postpone>>/
<em/member function/<p>
<<
OZ_Return postpone(void);
>>
<p>
This member function (usually in conjunction with the <<return>>
statement) causes the execution of the propagator to be postponed,
&ie the propagator is immediately switched to <<runnable>> and put at
the end of the thread queue.
<p>

<para class=apropos><title/<<imposeOn>>/
<em/member function/<p>
<<
OZ_Boolean imposeOn(OZ_Term t);
>>
<p>
This member function imposes the current propagator (&ie <<*this>>})
on <<t>>. If the imposition was successful, &ie <<t>> refers to a
variable, <<OZ_TRUE>> is returned, otherwise <<OZ_FALSE>>.
<p>

<para class=apropos><title/<<addImpose>>/
<em/member function/<p>
<<
void addImpose(OZ_FDPropState s, OZ_Term v);
void addImpose(OZ_FSetPropState s, OZ_Term v);
>>
<p>
This member function adds <<v>> to the parameters of the propagator
to be imposed with next invocation of <<OZ_Propagator::impose>>. In
case <<v>> does not denote a variable nothing happens. The value of
<<s>> determines the event when the propagator is to be resumed.
<p>

<para class=apropos><title/<<impose>>/
<em/member function/<p>
<<
void impose(OZ_Propagator * p,
            int prio = OZ_getMediumPrio());
>>
<p>
This member function imposes the propagator <<p>> with the priority
<<prio>> on the parameters collected by <<addImpose>>. An
admissible value for <<prio>> can be obtained by the functions
<<OZ_getLowPrio()>>, <<OZ_getMediumPrio()>>, and
<<OZ_getHighPrio()>>. The propagator is immediately switched to
<em/runnable/, but not initially run.
<p>

<subsection id="r_prop.todefine">
<title/Member Functions to be Defined by the Programmer/
<p>
The member functions in this section are purely virtual, &ie a class
inheriting from <<OZ_Propagator>> <em/must/ define these
functions, otherwise it is not possible to create instances of such a
class. These pure virtual member functions make <<OZ_Propagator>> to
an abstract base class.
<p>

<para class=apropos><title/<<sizeOf>>/
<em/pure virtual member function/<p>
<<
virtual size_t sizeOf(void) = 0;
>>
<p>
The implementation of this pure virtual function in a derived class
<<P>> is supposed to return the size of an instance of <<P>>.
<p>

<para class=apropos><title/<<updateHeapRefs>>/
<em/pure virtual member function/<p>
<<
virtual void updateHeapRefs(OZ_Boolean duplicate) = 0;
>>
<p>
The implementation of this pure virtual function in a derived class
<<P>> is supposed to apply to each data member of type <<OZ_Term>>
the function <<OZ_updateHeapTerm>> (see <ptr to="r_aux">)
and possibly, copy dynamically allocated extensions of the object's
state. The value of <<duplicate>> determines whether the propagator
is being duplicated (for example, as part of copy-based search) or only
an update of heap references is required (as for instance in case of
garbage collection). Further details on that issue can be found in
<ptr to="u_advanced.redundant">.
<p>

<para class=apropos><title/<<propagate>>/
<em/pure virtual member function/<p>
<<
virtual OZ_Return propagate(void) = 0;
>>
<p>
The implementation of this pure virtual function in a derived class
<<P>> is supposed to implement the operational semantics of the
propagator. The return value indicates the result of the computation to
the emulator.
<p>

<para class=apropos><title/<<getParameters>>/
<em/pure virtual member function/<p>
<<
virtual OZ_Term getParameters(void) const = 0;
>>
<p>
The implementation of this pure virtual function in a derived class
<<P>> is supposed to return the list (as Oz data structure) of
<<P>>'s parameters. Nested parameter structures are to be represented
as nested lists.
<p>

<para class=apropos><title/<<getProfile>>/
<em/pure virtual member function/<p>
<<
virtual OZ_PropagatorProfile getProfile(void) const = 0;
>>
<p>
The implementation of this pure virtual function in a derived class
<<P>> is supposed to return the static profile member function used to
get information about the state of a propagator class (for instance,
the number of total invocations).
<p>
