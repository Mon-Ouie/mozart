<Section id="u_getting_started">
<Title/Getting Started/

<p>
This section makes the reader familiar with the &cpi by implementing a
propagator for the constraint <Math/x+y=z/ and explains the steps to be taken
to get it running.

<SubSection id="u_getting_started.prerequisites">
<Title/Prerequisites/
<p>
The implementation of new propagators via the &cpi requires a correctly
installed Oz system. The following points should be obeyed.

<List>
<Entry> Environment Variables.
<Item>
A summary on environment variables relevant for the Oz system can be
found in Section 11.5 of <ptr to="system">.  Here we are
particularly interested in the variables <<OZHOME>> and <<OZPATH>>.
The variable <<OZHOME>> is used to determine the location
of the include file <<mozart_cpi.hh>>. The variable <<OZPATH>>
defines the search path for object files (&ie <<*.o>> files) to be
linked to a running Oz system. In case the environment variable
<<OZLINKPATH>> is defined, it overrides <<OZPATH>> and object files are
searched only in the directories specified by <<OZLINKPATH>>. To
define <<OZLINKPATH>> simply add the following line to your
<<.cshrc>> file or enter it at the shell prompt:
<p>
<<  setenv OZLINKPATH $HOME/&lt;your_directory&gt >>

<Entry> Include File.
<Item>
To obtain the functionality provided by the &cpi it is required to
include the file <<$OZHOME/include/mozart_cpi.hh>> in the appropriate
<<C/C++>> source files.

<Entry> Naming Conventions.
<Item>
Identifiers starting with <<OZ_>> are provided by the &cpi and must
not be defined by the programmer.
</List>

<SubSection id="u_getting_started.building">
<Title/Building a Propagator/
<p>
This section explains by means of an example the constraint propagator
interface of Oz. We implement the propagator for the constraint
<Math/x+y=z/. For the sake of clarity we use a rather straightforward
algorithm here. The operational semantics will provide as much
pruning/propagation as possible. This is in contrast to the constraint
<Math/x+y=z/ supplied by the finite domain library (see Section 16
of <ptr to="modules">, which reasons only over bounds of
domains.

<SubSubSection id="u_getting_started.building.def">
<Title/A Propagator's Class Definition/

<para class=apropos><title/&cpi class <<OZ_Propagator>>/
The emulator requires a
uniform way to refer to all instances of propagators. This is realised
by providing the class <<OZ_Propagator>>, which is
the class all propagators have to be inherited from. Therefore, the
emulator can refer to any propagator by a pointer of type
<<(OZ_Propagator *)>> The class <<OZ_Propagator>> is in terms of <<C++>>
a so-called <Em/abstract base class/, &ie no object of such a class
can be created (since for at least one member function intentionally no
implementation is provided, indicated by an appended
<<=0>>. Instead, it defines the minimal functionality required of
all classes inherited from it. The following code depicts a fragment of
the definition of the class <<OZ_Propagator>> defined by the &cpi
(in the file <<mozart_cpi.hh>>). It shows all member functions which have to
be defined in a derived class.

<Code.Extern display proglang=cc to="programs/ozpropdef.hh" class=linenumbers>

<p>
There are basically three groups of member functions dealing with
reflection, memory management, and constraint propagation.
<p>

<para class=apropos><title/<<getProfile()>>/
For each propagator class, one instance of class <<OZ_PropagatorProfile>>
is allocated. This class is intended to give the Oz
Profiler access to some information about this class, for instance a
count of the number of invocations of propagators belonging to this
class. This function must return a pointer to this instance, but
otherwise the programmer needs not to be concerned about it. Note that
for the profile function to be shared for all instances, it has to be
declared <<static>>.
<p>

<!--
Member functions concerned with reflection allow to obtain information
about a certain instance of a propagator. For example, this is used to
generate a message in case of a top-level failure.

<para class=apropos><title/<<getHeaderFunc()>>/
<em/fixme: getHeaderFunc is obsolete. Replace with description of getProfile/
To identify the
propagators implementing a certain constraint, a pointer to the <<C/C++>>
function which imposed it (see <ptr to="u_getting_started.creating">)
is provided
by the member function <<getHeaderFunc()>>. This <<C/C++>>
function is called <Em/header function/. By <Em/imposing a propagator/
is meant to create a new instance of a <<C++>> class implementing a
propagator, adding suspension entries to the parameter's suspension
lists, and introducing a reference to this instance to the runtime
system. The type <<OZ_CFun>> denotes a pointer to a <<C/C++>> function
compatible with Oz's calling conventions.
-->


<para class=apropos><title/<<getParameters()>>/
The arguments of a propagator
are returned by <<getParameters()>> as a list
represented as an Oz heap data structure. This is denoted by the return
type <<OZ_Term>>.
<p>

<para class=apropos><title/<<sizeOf()>>/
Memory management of Oz requires to know the size of a propagator. The
member function <<sizeOf()>> implements this
functionality. Its return type is defined in the standard header
<<&lt;stddef.h&gt>>.

<para class=apropos><title/<<updateHeapRefs()>>/
Further, on garbage collection references into heap
which is held in the state of the propagator (or somehow reachable by a
propagator) have to be updated, since items stored on the heap are
occasionally moved to a new location. The member function
<<updateHeapRefs()>> is provided for that purpose. For
the time being the argument can be safely ignored.

<para class=apropos><title/<<propagate()>>/
The most important member function is <<propagate()>>.
It is responsible for the actual
constraint propagation and is called by the emulator when the
propagator's execution state is switched to <<running>>.  The returned
value of type <<OZ_Return>> indicates the runtime system the outcome
of the propagation performed by <<propagate()>>.
<p>
The implementation of the addition propagator starts with the definition
of the class <<AddProp>>. The definition of the member function
<<propagate()>> is explained in <ptr to="u_getting_started.propagation">.

<Code.Extern display proglang=cc to="programs/ex_a.1.cc" class=linenumbers>
<Code.Extern display proglang=cc to="programs/ex_a.2.cc" class=linenumbers>


The propagator stores in its state, &ie in its data members, references
to the variables it is imposed on (namely <<_x>>, <<_y>> and <<_z>> of
type <<OZ_Term>>. The constructor of the
class <<AddProp>>, which is invoked by the header function, initialises the
data members with the arguments of the corresponding Oz application.

The member function <<sizeOf()>> returns the number of bytes occupied
by the addition propagator using <<C/C++>>'s <<sizeof>> operator.
The &cpi provides for the function <<updateHeapTerm()>>, which is used
for implementing the member function <<updateHeapRefs()>>, which
applies <<updateHeapTerm()>> to all data members of type
<<OZ_Term>>. The construction of lists is supported by the &sci
abstractions <<OZ_cons()>> and <<OZ_nil()>> (see Section 10
in <ptr to="system">. The function <<getParameters()>>
straightforwardly composes a list containing the references to the
arguments hold in the propagator's state.
<p>

<!--
<em/fixme replace with PropagatorProfile description/
A propagator's class has to have a unique name which identifies the
constraint it implements. The &cpi uses as unique name for a
propagator the pointer to the header function which imposed the
propagator . Therefore, all instances, &ie objects, of the class
<<AddProp>> share the data member <<header>> holding a pointer to
the header function which imposed them. The definition of this <<C/C++>>
function comes in <ptr to="u_getting_started.creating">.
Note that for this case to
achieve sharing of a data member between all objects of a class it
has to be declared <<static>>.
-->

<SubSubSection id="u_getting_started.propagation">
<Title/The Propagation Part of a Propagator/
<p>
The member function <<propagate()>> implements the algorithm which
defines the operational semantics of the propagator, &ie the amount of
constraint propagation achieved at each invocation.
<p>
The algorithm used here rebuilds the domains of the variables always
from scratch. Therefore, auxiliary domains for each variable are
introduced which are initially empty. For all values of the domains of
<Math/x/ and <Math/y/ it is checked if there is a consistent value in
the domain
of <Math/z/. If so, the values are added to the corresponding auxiliary
domains. Finally, the domains of the variables are constrained,
&ie intersected, with the corresponding auxiliary
domains. Consequently, the core of the program code consists of two
nested loops iterating over all values of the domains of <Math/x/ and
<Math/y/.

<Code.Extern display proglang=cc to="programs/ex_a.3b.cc" class=linenumbers>
<Code.Extern display proglang=cc to="programs/ex_a.3a.cc" class=linenumbers>
<Code.Extern display proglang=cc to="programs/ex_a.3.cc" class=linenumbers>

<para class=apropos><title/&cpi class <<OZ_FDIntVar>>/
A propagator needs direct
access to the variables it is imposed on. The interface class
<<OZ_FDIntVar>> provides member functions to access variables in the
constraint store. The constructor dereferences a variable in the store
and stores the dereferenced information in the state of the newly
created object. The operators <<*>> and <<-&gt>> are overloaded to
provide direct access to the finite domain of a variable in the
store or to invoke member functions of the class <<OZ_FiniteDomain>>
(see below).
<p>

<para class=apropos><title/&cpi class <<OZ_FiniteDomain>>/
The finite domain of a variable is represented by an instance of the
class <<OZ_FiniteDomain>>, modifying their value is immediately
visible in
the constraint store. Calling the constructor with the value
<<fd_empty>> creates an empty finite domain, as used for the
auxiliary variables here. The operator <<+=>> adds a value to a
domain. The operator <<&=>> intersects two domains, modifies the
domain on the left hand side and returns the size of the intersected
domain. The member function <<getMinElem()>> returns the smallest value
of the domain and <<getNextLargerElem(i)>> returns the smallest value
of the domain larger than <<i>> (both return <<-1>> when they reach
their respective end of the domain). Testing whether a value is contained
in a domain or not can be done by the member function <<isIn()>>.


<para class=apropos><title/The implementation/
The implementation of the constraint
<Math/x+y=z/ proceeds as follows. First the variables in the store are
retrieved and stored in the local <<C/C++>> variables <<x>>, <<y>> and
<<z>>. The corresponding auxiliary domains are held in the
variables <<x_aux>>,  <<y_aux>> and <<z_aux>>,
which are
initialised to empty domains. Two nested for-loops enumerate all
possible pairs <Math/(v_x,v_y)/ of values of the domains of <Math/x/
and <Math/y/. Each
loop starts from the smallest value of the domain and proceeds until
<Math/-1/
is returned, indicating that there is no larger value. If there is a
value <Math/v_z/ in the domain of <Math/z/ satisfying the relation
<Math/v_x + v_y = v_z/,
these values are added to the appropriate auxiliary
domains. After completing the nested loops, the domains of the variables
are constrained by intersecting them with the auxiliary domains.

<para class=apropos><title/<<FailOnEmpty()>>/
The
macro <<FailOnEmpty()>> branches to the label
<<failure>> if its argument results in the value <Math/0/. Thereby,
constraining the domain of a variable to an empty domain causes the
execution to branch to label <<failure>> and eventually to return
<<OZ_FAILED>> to the emulator. The return value of the member function
<<leave()>> of class <<OZ_FDIntVar>>  is used to decide whether the
propagator returns <<OZ_SLEEP>> or <<OZ_ENTAILED>>.
The return value
<<OZ_ENTAILED>> indicates entailment and is returned if all variable's
domains are singletons. Otherwise, <<OZ_SLEEP>> is returned and the
propagator is resumed when at least one of its variables is
constrained again.

<p>
Before leaving <<propagate()>>, the member function <<leave()>> has to
be called. If the variable's domain has been constrained by the
propagator, it causes the scheduler to switch all propagators waiting
for further constraints on that variable to become <<runnable>>. The
return value of <<leave>> is <Math/0/ if the domain became a singleton,
otherwise <Math/1/. This information is used to decide whether a propagator
is entailed or not. In case the propagator encounters an empty domain or
any other inconsistency, the member function <<fail()>> has to be
called to do some cleanups before <<propagate()>> is left.

<SubSubSection id="u_getting_started.creating">
<Title/Creating a Propagator/

<para class=apropos><title/The header function/
<!--
this should still be o.k.
-->
Before a propagator can be created and
introduced to the emulator, its variables must be sufficiently
constrained, e.g. the variables must be constrained to finite
domains. In case, only a subset of variables is sufficiently
constrained, the computation will suspend and resume again when more
constraints become available. This is checked by the header
function, which is called by the runtime system, when an appropriately
connected Oz abstraction is applied (for details see
<ptr to="u_getting_started.connect">.
For our example, this function is called
<<fd_add>>.

<para class=apropos><title/Determining when to resume a propagator/
Further, when a propagator is imposed on a variable, it
has to be
determined which changes to the domain resume the propagator again. The
alternatives are to resume a propagator if the variable's domain becomes
a singleton, the bounds are narrowed or some value is removed from the
domain.

<p>
The macros <<OZ_C_proc_begin>> and <<OZ_C_proc_end>> are provided
by the &sci to allow the implementation of <<C/C++>> functions which are
compliant with the calling conventions of Oz's emulator.

<p>
The first argument of the macro <<OZ_C_proc_begin>> defines the name
of the function and the second argument the number of arguments of type
<<OZ_Term>>. The macro <<OZ_args>> provides access to the actual
argument. The name of the function has to obey certain rules to be
compatible with the module <<Foreign>> which enables linking object
files to a running Oz runtime system. Details are given in
<ptr to="u_getting_started.connect">.
The definition of the macro
<<OZ_EXPECTED_TYPE>> is explained in <ptr to="expect.macros">.

<p>
<Code.Extern display proglang=cc to="programs/ex_a.4.cc" class=linenumbers>

<para class=apropos><title/Using <<OZ_EXPECT>>/
The macro <<OZ_EXPECT>> ensures
that incompatible constraints on the propagator's parameters lead to
failure and insufficient constraints cause the execution to be suspended
until more constraints become known. An object of class <<OZ_Expect>>
collects in its state all variables the propagator is to be imposed
on. Such an object is at the first argument position of
<<OZ_EXPECT>>. The second argument of <<OZ_EXPECT>>
determines
which argument of <<fd_add>> shall be checked. The member function
<<expectIntVar()>> of class <<OZ_Expect>> expects a variable to be
already constrained to a finite domain. If a variable is sufficiently
constrained, it is stored in the state of the object <<pe>>. The
second argument of <<expectIntVar>> is used to determine what kind of
domain pruning causes a propagator to be resumed. Its default value is
<<fd_prop_any>>, &ie a propagator is resumed on any pruning of the
domain.  For further details see <ptr to="u_nesting">.

<para class=apropos><title/Creation of a propagator/
Finally, the actual propagator is
created by calling its constructor via the application of the <<new>>
operator. The reference to the newly created propagator is passed as
argument to <<impose()>>, a member function of <<OZ_Expect>>,
which
executes the <<propagate()>> method and introduces the propagator to the
emulator.

<SubSubsection id="u_getting_started.connect">
<Title/Connecting Propagators and Oz Code/

<p>
If you have defined new functions, they need to be introduced to the
emulator upon loading. When a module is loaded, a function
<<oz_init_module>> is executed...
<p>
To load an externally compiled module into a running <<Oz>> system,
you can proceed as follows:

<< FIXME >>
<p>
DFKI Oz provides the module <<Foreign>> for linking <<C/C++>>
modules to a running Oz system. The following procedures are available:

<List>
<Entry> <<{Foreign.load +OL +R ?M}>>
<Item> loads the object files
      &resp libraries specified in the list <<OL>> and creates
      according to the specification <<R>> the module <<M>>. The
      module <<M>> is a record where the subtrees are procedures of
      the module.

<Entry> <<Foreign.reload +OL +R ?M}>>
<Item> is similar to
       <<Foreign.load>> except that it unloads already loaded object
       files before it loads the object files specified in <<OL>>.

<Entry> <<Foreign.isLoaded +OL ?B}>>
<Item> binds <<B>> to <<true>> in
      case one of the object files in <<OL>> is already
      loaded. Otherwise it binds <<B>> to <<false>>.

</List>

<para class=apropos><title>Naming conventions for <<C/C++>> modules</title>
The name of a <<C/C++>>
function to be linked by the module <<Foreign>> has to consist of two
parts separated by an underscore <<'_'>>. The first part
corresponds to the module name, &ie the label of the created Oz
record. The second part is the name of the actual abstraction.
<p>
For example, <<OZ_C_proc_begin(fd_add, 3)>> on the <<C/C++>> side
corresponds to <<fd(add: 3)>> on the Oz side. Further details of the
<<SCI>> can be found in
Section 10
in [fixme cite ozdoc:system].
<p>
Before a <<C/C++>> module can be loaded via the module <<Foreign>>, the
<<C/C++>> source code has to be compiled to an object file. Supposing the
<<C/C++>> code is stored in the file <<ex_a.cc>>, then the following
line creates the object file  <<ex_a.o>>.
<p>

<<  gcc -c -I$OZHOME/include ex_a.cc>>

<p>
Before starting the Oz system make sure that the environment variable
<<OZLINKPATH>> is set properly according to
<ptr to="u_getting_started.prerequisites">.
Further, a function <<fd_init>> is expected to be contained in
<<ex_a.o>>. This function will be useful for troubleshooting or
for initialization in general, but for the time being let it be defined
as the following dummy function.

<p>
<<OZ_C_proc_begin(fd_init, 0) {
  return PROCEED;
}
OZ_C_proc_end>>

<p>
The Oz code below loads the object file <<ex_a.o>> and makes the Oz
abstractions <<FD_PROP.init>> and <<FD_PROP.add>>
available. The
first one does not take any arguments and is intended to initialise the
new module. Therefore, it is called immediately after loading. The
procedure <<FD_PROP.add>> takes 3 arguments and imposes the addition
propagator implemented in the sections before.

<Code.Extern display to="programs/ex_a.1.oz" class=linenumbers>

After feeding in the above Oz code the addition propagator is available
and can be used. To do so feed the following code in line by line. The
results are shown in the Oz browser (shown in comments appended to
lines).

<Code.Extern display to="programs/ex_a.2.oz" class=linenumbers>

<SubSection id="u_getting_started.trouble">
<Title/Troubleshooting/
<p>
This section gives some hints on debugging propagators, which caused the
system to crash with, &eg segmentation fault or bus error.
<p>
The OPI (Oz Programming Interface) (see
Section 2
of <ptr to="system"> is started from a shell by entering the
following line.

<p>
<<  % oz>>

<p>
It provides means to run the Oz runtime system under control of the
debugger <Em/gdb/ <ptr to="gdb">. The following commands are
available in <<oz-mode>> windows:

<List>
<Entry> <<C-c m>>
<Item>
selects an emulator to be run under control of
  <Em/gdb/. The environment variables <<OZHOME>> and <<OZPLATFORM>> can
  be used to generate the complete path to the emulator. Enter the
  following when the emacs prompts to choose an emulator:

<<  $OZHOME/platform/$OZPLATFORM/emulator.exe>>

<Entry> <<C-c d>>
<Item> enables &resp disables <Em/gdb/ for an emulator specified
  by <<C-c m>>.

<Entry> <<C-c e>>
<Item> opens and closes the emulator window.
</List>

To utilize a debugger like <Em/gdb/ it is necessary to find out where the
code of a module was loaded. For that purpose the <<init()>> function
comes quite handy. The <<C/C++>> code presented so far in this section
has to be wrapped with the following code:

<p>
<Code.Extern display proglang=cc to="programs/ex_a.1a.cc" class=linenumbers>
<<// here goes the code presented so far in this section>>
<Code.Extern display proglang=cc to="programs/ex_a.5.cc" class=linenumbers>
<p>
The function <<fd_start>> is used to figure out the start address
of
the text of the module. It has always to be defined first. When loading
the module, for example, the following output is produced:

<p>
<<fd_start = 0xef6dc020>>

<p>
The hexadecimal number designates the start address of the text of
the module. To enable decent debugging the symbol table of the module
has to be loaded. To interrupt the execution of Oz hit <<C-c C-c>>.
Then the symbol table of the module can be introduced to <Em/gdb/
and for example, a breakpoint can be set.

<p>
<<
  (gdb) add-symbol-file ex_a.o 0xef6dc020
  add symbol table from file "ex_a.o"
  at text_addr = 0xef6dc020?
  (y or n) y
  (gdb) b fd_add
  Breakpoint 1 at 0xef6dc3b8: file ex_a.cc, line 68.
  (gdb) c
>>

<p>
In case <Em/ gdb/ does not find the object file the complete path to the
object file has to be given.
