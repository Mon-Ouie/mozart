<Chapter id="Chapter.Linker" proglang=sh>
  <Title/The Oz Linker: <Kbd/ozl//

    <P>
      Application development can be considerably eased by splitting
      the application in a large number of orthogonal and reusable
      functors. However, deployment of an application gets harder in
      the presence of a large number of functors:
    </P>

    <P>
      <List>
        <Item>Installing the application requires correct installation
        of a large number of functors.
        <Item>Execution might be slow due to frequent file- or even
        network accesses.
      </List>
    </P>

    <P>
      The commandline tool <Kbd/ozl/ eases deployment by creating a
      new functor that includes imported functors in a prelinked
      fashion: it is possible to collapse a hierarchy of functors into
      a single equivalent one. The model that should be kept in mind,
      is that the newly created functor employs an internal, private
      module manager (see also ???) that excutes the toplevel
      application functor together with all included functors.
    </P>

    <P>
      A short introduction by means of examples can be found ???.
    </P>

  <Section id="Section.Linker.Basic">
    <Title/Basic Usage/

    <P>
      The linker can be invoked on the input functor <Var/In/ in order
      to create an output functor <Var/Out/ as follows:
      <<<% ozl <Var/In/ -o <Var/Out/>>>
    </P>

    <P>
      Consider for example the pickled functors <File/A.ozf/,
      <File/B.ozf/, and <File>subdir/C.ozf</File>, where <File/A.ozf/
      has been created from the following functor definition:
<Code display proglang=oz>functor
import B
       C at 'subdir/C.ozf'
       Application
end</Code>
      and the other functors have empty imports.
      By executing
      <<<% ozl A.ozf -o D.ozf>>>
      a new pickled functor <File/D.ozf/ is created that contains
      both the functors contained in <File/B.ozf/ and
      <File>subdir/C.ozf</File> but not the system functor <Code
      proglang=oz/Application/.
    </P>

    <P>
      If the linker is invoked in verbose mode as
      <<<% ozl --verbose A.ozf -o D.ozf>>>
      or
      <<<% ozl -v A.ozf -o D.ozf>>>
      for short, it prints the following information on which functors
      are in fact included and which are still imported by the newly
      created functor.
<Code display proglang=fundamental>
Include:
   A.ozf, B.ozf, subdir/C.ozf.
Import:
   x-oz://system/Application.
Scheduling:
   B.ozf, subdir/C.ozf, A.ozf.
</Code>
     </P>

     <P>
       If we now invoke the linker on the newly created pickled
       functor <File/D.ozf/ in verbose mode as follows:
       <<<% ozl -v D.ozf>>>
       it only prints the following information without creating a new
       functor:
<Code display proglang=fundamental>
Include:
   D.ozf.
Import:
   x-oz://system/Application.
Scheduling:
   D.ozf.
</Code>
     </P>

     <P>
       By default, the linker includes (or links) all functors that
       are refered to by relative URLs as in our previous example. How
       to chnage this behaviour is discussed in <Ptr
       to="Section.Linker.Include">.
     </P>

  </Section>

  <Section id="Section.Linker.Include">
    <Title/Including and Excluding Functors/
  </Section>

  <Section id="Section.Linker.Pickling">
    <Title/Pickling Options/
  </Section>

  <Section id="Section.Linker.Misc">
    <Title/Miscellaneous Options/
  </Section>

</Chapter>
