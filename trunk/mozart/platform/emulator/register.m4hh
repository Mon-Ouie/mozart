/* This may look like C code, but it is really -*- C++ -*-

  Hydra Project, DFKI Saarbruecken,
  Stuhlsatzenhausweg 3, D-66123 Saarbruecken, Phone (+49) 681 302-5312
  Author: popow,mehl,scheidhr
  Last modified: $Date$ from $Author$
  Version: $Revision$
  State: $State$

  ------------------------------------------------------------------------

  ****** Register Instructions: use m4 to minimize duplication

  */


/* 
 * m4 macros to simplfy defining instructions,
 * that use registers
 */

changequote(XXX,XXX)

changequote(``,'')


define(CaseOneReg,``''
       Case($1X):
       ``define(``Reg1'',Xreg(``$''1))''{$2}

       Case($1Y):
       ``define(``Reg1'',Yreg(``$''1))''{$2}

       Case($1G):
       ``define(``Reg1'',Greg(``$''1))''{$2}

       ``undefine(``Reg1'')''
      )


define(CaseTwoRegs,``''
       Case($1XX):
       ``define(``Reg1'',Xreg(``$''1))'' ``define(``Reg2'',Xreg(``$''1))''{$2}
       Case($1XY):
       ``define(``Reg1'',Xreg(``$''1))'' ``define(``Reg2'',Yreg(``$''1))''{$2}
       Case($1XG):
       ``define(``Reg1'',Xreg(``$''1))'' ``define(``Reg2'',Greg(``$''1))''{$2}

       Case($1YX):
       ``define(``Reg1'',Yreg(``$''1))'' ``define(``Reg2'',Xreg(``$''1))''{$2}
       Case($1YY):
       ``define(``Reg1'',Yreg(``$''1))'' ``define(``Reg2'',Yreg(``$''1))''{$2}
       Case($1YG):
       ``define(``Reg1'',Yreg(``$''1))'' ``define(``Reg2'',Greg(``$''1))''{$2}

       Case($1GX):
       ``define(``Reg1'',Greg(``$''1))'' ``define(``Reg2'',Xreg(``$''1))''{$2}
       Case($1GY):
       ``define(``Reg1'',Greg(``$''1))'' ``define(``Reg2'',Yreg(``$''1))''{$2}
       Case($1GG):
       ``define(``Reg1'',Greg(``$''1))'' ``define(``Reg2'',Greg(``$''1))''{$2}

       ``undefine(``Reg1'')''
       ``undefine(``Reg2'')''
      )


// -------------------------------------------------------------------------
// CLASS: TERM: MOVE/UNIFY/CREATEVAR/...
// -------------------------------------------------------------------------

  CaseTwoRegs( MOVE,
		``
		  Reg2(getRegArg(PC+2)) = Reg1(getRegArg(PC+1));
		  DISPATCH(3);
		''
		)


  // move X[i] --> Y[j], X[k] --> Y[l]
  Case(MOVEMOVEXYXY):
    {
      Yreg(getRegArg(PC+2)) = Xreg(getRegArg(PC+1));
      Yreg(getRegArg(PC+4)) = Xreg(getRegArg(PC+3));
      DISPATCH(5);
    }

  // move Y[i] --> X[j], Y[k] --> X[l]
  Case(MOVEMOVEYXYX):
    {
      Xreg(getRegArg(PC+2)) = Yreg(getRegArg(PC+1));
      Xreg(getRegArg(PC+4)) = Yreg(getRegArg(PC+3));      
      DISPATCH(5);
    }

  // move Y[i] --> X[j], X[k] --> Y[l]
  Case(MOVEMOVEYXXY):
    {
      Xreg(getRegArg(PC+2)) = Yreg(getRegArg(PC+1));
      Yreg(getRegArg(PC+4)) = Xreg(getRegArg(PC+3));      
      DISPATCH(5);
    }

  // move X[i] --> Y[j], Y[k] --> X[l]
  Case(MOVEMOVEXYYX):
    {
      Yreg(getRegArg(PC+2)) = Xreg(getRegArg(PC+1));
      Xreg(getRegArg(PC+4)) = Yreg(getRegArg(PC+3));      
      DISPATCH(5);
    }

  CaseOneReg(CREATENAMEDVARIABLE, 
    ``
    {
      int regIndex = getRegArg(PC+1);
      TaggedRef name   = getLiteralArg(PC+2);
      Assert(&Reg1(0)== &(e->toplevelVars[0]));
      TaggedRef newVar = e->createNamedVariable(regIndex,name);
      Y = e->toplevelVars;
      Reg1(regIndex) = newVar;
    }
    ''
    DISPATCH(3);
    )


#define MakeVar makeTaggedRef(newTaggedUVar(e->currentUVarPrototype))

Case(CREATEVARIABLEX):
   {
     Xreg(getRegArg(PC+1)) = MakeVar;
     DISPATCH(2);
   }
Case(CREATEVARIABLEY):
   {
     Yreg(getRegArg(PC+1)) = MakeVar;
     DISPATCH(2);
   }
Case(CREATEVARIABLEG):
   {
     error("CREATEVARIABLEG: impossible");
     DISPATCH(2);
   }

Case(CREATEVARIABLEMOVEX):
   {
     Xreg(getRegArg(PC+1)) = Xreg(getRegArg(PC+2)) = MakeVar;
     DISPATCH(3);
   }
Case(CREATEVARIABLEMOVEY):
   {
     Yreg(getRegArg(PC+1)) = Xreg(getRegArg(PC+2)) = MakeVar;
     DISPATCH(3);
   }
Case(CREATEVARIABLEMOVEG):
   {
     error("CREATEVARIABLEMOVEG: impossible");
     DISPATCH(3);
   }

#undef MakeVar

  
  CaseTwoRegs(UNIFY,
	       ``{
		 if ( !e->fastUnify(Reg1(getRegArg(PC+1)),
				    Reg2(getRegArg(PC+2)),
				    NOFLATGUARD())) {
		   SHALLOWFAIL;
		   HF_UNIFY("%s = %s failed\n",  Reg1(getRegArg(PC+1)), Reg2(getRegArg(PC+2)),  "In instruction UNIFY\n" );
		 }
	       }''
	       DISPATCH(3);
		 )
  
  
  CaseOneReg( PUTSTRUCTURE,
	       ``
		 STuple *stuple =
		   STuple::newSTuple(getLiteralArg(PC+1),getPosIntArg(PC+2));
		 TaggedRef term = makeTaggedSTuple(stuple);

		 Reg1(getRegArg(PC+3)) = term;
		 sPointer = stuple->getRef();
		 
		 DISPATCH(4);''
	       )


  Case(PUTRECORDX): ONREG(PutRecord,X);
  Case(PUTRECORDY): ONREG(PutRecord,Y);
  Case(PUTRECORDG): ONREG(PutRecord,G);
         PutRecord:
          {
            TaggedRef label = getLiteralArg(PC+1);
            Arity *ff = (Arity *) getAdressArg(PC+2);
            SRecord *srecord = SRecord::newSRecord(label,ff);
		 
            RegAccess(HelpReg,getRegArg(PC+3)) = makeTaggedSRecord(srecord);
	    sPointer = srecord->getRef();

	    DISPATCH(4);
          }

  Case(PUTCONSTANTX):
  Case(PUTINTX):
     Xreg(getRegArg(PC+2)) = getTaggedArg(PC+1); DISPATCH(3);

  Case(PUTCONSTANTY):
  Case(PUTINTY):
     Yreg(getRegArg(PC+2)) = getTaggedArg(PC+1); DISPATCH(3);

  Case(PUTCONSTANTG):
  Case(PUTINTG):
     Greg(getRegArg(PC+2)) = getTaggedArg(PC+1); DISPATCH(3);

  CaseOneReg( PUTLIST,
	       ``{
		 LTuple *term = new LTuple();
		 Reg1(getRegArg(PC+1)) = makeTaggedLTuple(term);
		 sPointer = term->getRef();

	       }''
	       DISPATCH(2);
	       )


  CaseOneReg( SETVARIABLE,
	       ``{
		 Reg reg = getRegArg(PC+1);
		 *sPointer = e->currentUVarPrototype;
		 Reg1(reg) = makeTaggedRef(sPointer++);
		 DISPATCH(2);
	       }''
	       )

  CaseOneReg( SETVALUE,
	       ``{
		 *sPointer++ = Reg1(getRegArg(PC+1));
		 DISPATCH(2);
	       }''
	       )


Case(SETCONSTANT):
  Case(SETINT):
    {
      *sPointer++ = getTaggedArg(PC+1);
      DISPATCH(2);
    }


Case(SETVOID):
    {
      int n = getPosIntArg(PC+1);
      TaggedRef newVar = e->currentUVarPrototype;
      for (int i = 0; i < n; i++ ) {
	*sPointer++ = newVar;
      }
      DISPATCH(2);
    }


  CaseOneReg( GETSTRUCTURE,
	       ``{
		 TaggedRef label = getLiteralArg(PC+1);
		 int arity       = getPosIntArg(PC+2);
		 
		 TaggedRef term = Reg1( getRegArg(PC+3) );
		 DEREF(term,termPtr,tag);

		 if (isAnyVar(term)) {
		   STuple *stuple = STuple::newSTuple(label,arity);
		   sPointer = stuple->getRef();
		   SetWriteMode;

		   if (isCVar(term)) {
		     if (tagged2CVar(term)->unifyOutline(termPtr, term, NULL,
							 makeTaggedSTuple(stuple),
							 NOFLATGUARD())) {
		       DISPATCH(4);
		     }
		   } else {

		     e->bindToNonvar(termPtr,term,makeTaggedSTuple(stuple),
				     NOFLATGUARD());

		     DISPATCH(4);
		   }
		 }
		   
		 if (isSTuple(tag) &&
		     tagged2STuple(term)->compareSortAndSize(label,arity)) {
		   sPointer = tagged2STuple(term)->getRef();
		   SetReadMode;
		   DISPATCH(4);
		 }

		 SHALLOWFAIL;
		 HF_UNIFY("%s(...) = %s failed\n", getLiteralArg(PC+1), Reg1(getRegArg(PC+3)), "In instruction GETSTRUCTURE\n" );
	       }''
	       )


  Case(GETRECORDX): ONREG(GetRecord,X);
  Case(GETRECORDY): ONREG(GetRecord,Y);
  Case(GETRECORDG): ONREG(GetRecord,G);
      GetRecord:
         {
	   TaggedRef label = getLiteralArg(PC+1);
	   Arity *ff = (Arity *) getAdressArg(PC+2);
		 
  	   TaggedRef term = RegAccess(HelpReg,getRegArg(PC+3));
	   DEREF(term,termPtr,tag);

	   if (isAnyVar(term)) {
	     SRecord *srecord = SRecord::newSRecord(label,ff);
	     if(isCVar(term) == OK){
	       // fill w/unb. var.
               srecord->initArgs(am.currentUVarPrototype); 
	       TaggedRef srecordRef=makeTaggedSRecord(srecord);
	       if(tagged2CVar(term)->unifyOutline(termPtr, term, 
						  &srecordRef, srecordRef,NOFLATGUARD())) {
		 sPointer = srecord->getRef();
		 SetReadMode;
		 DISPATCH(4);
	       }
	     } else {
	       e->bindToNonvar(termPtr, term,makeTaggedSRecord(srecord),NOFLATGUARD());
		     
	       sPointer = srecord->getRef();
	       SetWriteMode;
	       DISPATCH(4);
	     }
	   }
		 
	   if (isSRecord(tag) &&
	       tagged2SRecord(term)->compareSortAndArity(label,ff)) {
	     sPointer = tagged2SRecord(term)->getRef();
	     SetReadMode;
	     DISPATCH(4);
	   }

	   SHALLOWFAIL;
	   HF_UNIFY("%s(..:.. ...) = %s failed\n", getLiteralArg(PC+1), RegAccess(HelpReg,getRegArg(PC+3)), "In instruction GETRECORD\n" );
	 }


  CaseOneReg(TESTCONST,
    ``{
        TaggedRef term = Reg1(getRegArg(PC+1));
        TaggedRef atm  = getLiteralArg(PC+2);

	DEREF(term,termPtr,tag);

	if (sameLiteral(term,atm)) {
	  JUMP( getLabelArg(PC+3) );
	}

        if (isNotCVar(term) ||
	    isCVar(term) && tagged2CVar(term)->valid(atm)) {
	  Suspension *susp = e->mkSuspension(CBB,CPP,
					     PC,Y,G,X,getPosIntArg(PC+5));
	  addSusp(termPtr,susp);

	  /* Bug fix:
	     declare Y Z
	     {RecLabel Y Z}
	     if Y=b then {Show yes36b} else {Show no36b} fi
	     Z=c
	     we must suspend on the label of OFS too!!
	     */

	  if (isCVar(term) && tagged2CVar(term)->getType() == OFSVariable) {
	    TaggedRef lab = ((GenOFSVariable*)tagged2CVar(term))->getLabel();
	    DEREF(lab,labPtr,labTag);
	    if (isAnyVar(labTag)) {
	      addSusp(labPtr,susp);
	    }
	  }
	  CHECKSEQ;
	}

	JUMP( getLabelArg(PC+4) );
    }''
    )

  CaseOneReg(TESTNUMBER,
    ``{
        TaggedRef term = Reg1(getRegArg(PC+1));
	TaggedRef i = getNumberArg(PC+2);

	DEREF(term,termPtr,tag);

	/* optimized for integer case */
	if (isSmallInt(tag)) {
	  JUMP( getLabelArg(sameSmallInt(term,i) ? PC+3 : PC+4) );
	}

	if ( tag == tagTypeOf(i) && numberEq(i,term)) {
	  JUMP( getLabelArg(PC+3) );
	}

        if (isNotCVar(term) ||
	    isCVar(term) && tagged2CVar(term)->valid(i)) {
	  Suspension *susp=e->mkSuspension(CBB,CPP,
					   PC,Y,G,X,getPosIntArg(PC+5));
	  addSusp(termPtr,susp);
	  CHECKSEQ;
	}

	JUMP( getLabelArg(PC+4) );
    }''
    )

  CaseOneReg( GETCONSTANT,
	       ``{
		 TaggedRef atm = getLiteralArg(PC+1);
		 
		 TaggedRef term = Reg1( getRegArg(PC+2) );
		 DEREF(term,termPtr,tag);

		 if (isNotCVar(tag)) {
		   e->bindToNonvar(termPtr, term, atm, NOFLATGUARD());
		   DISPATCH(3);
		 }
		 
		 if ( isLiteral(tag) && sameLiteral(term,atm) ) {
		   DISPATCH(3);
		 }

		 if (isCVar(term)) {
		   if (tagged2CVar(term)->unifyOutline(termPtr,term,NULL,
						       atm,NOFLATGUARD())) {
		     DISPATCH(3);
		   }
		   term = *termPtr;  // Note: 'term' may be disposed
		 }

		 SHALLOWFAIL;
		 HF_UNIFY("%s = %s failed\n", Reg1(getRegArg(PC+2)), getLiteralArg(PC+1), "In instruction GETCONSTANT\n" );
	       }''
	       )


  CaseOneReg( GETINT,
	       ``{
		 TaggedRef i = getNumberArg(PC+1);
		 TaggedRef term = Reg1(getRegArg(PC+2));
		 DEREF(term,termPtr,tag);

		 if (isNotCVar(tag)) {
		   e->bindToNonvar(termPtr, term, i, NOFLATGUARD());
		   DISPATCH(3);
		 }
		 
		 if ( (tag == tagTypeOf(i)) && numberEq(term,i)) {
		   DISPATCH(3);
		 }

		 if (isCVar(term)) {
		   if (tagged2CVar(term)->unifyOutline(termPtr,term,NULL,
						       i,NOFLATGUARD())) {
		     DISPATCH(3);
		   }
		   term = *termPtr;  // Note: 'term' may be disposed
		 }

		 SHALLOWFAIL;
		 HF_UNIFY("%s = %s failed\n", Reg1(getRegArg(PC+2)), getNumberArg(PC+1), "In instruction GETINT\n" );
	       }''
	       )

/* getListValVar(N,R,M) == getList(X[N]) unifyVal(R), unifyVar(X[M]) */
  CaseOneReg(GETLISTVALVAR,
		``{
		 Reg reg1 = getRegArg(PC+1);
		 Reg reg2 = getRegArg(PC+2);
		 Reg reg3 = getRegArg(PC+3);

	
		 TaggedRef term = Xreg(reg1);
		 DEREF(term,termPtr,tag);

		 if(isAnyVar(term)) {
		   LTuple *ltuple = new LTuple(Reg1(reg2),e->currentUVarPrototype);

		   if (isCVar(term) == OK) {
		     if (tagged2CVar(term)->unifyOutline(termPtr, term, NULL,
							 makeTaggedLTuple(ltuple),
							 NOFLATGUARD())) {
		       Xreg(reg3) = makeTaggedRef(ltuple->getRef()+1);
		       DISPATCH(4);
		     }
		   } else {
		     e->bindToNonvar(termPtr, term, makeTaggedLTuple(ltuple),
				     NOFLATGUARD());
		     Xreg(reg3) = makeTaggedRef(ltuple->getRef()+1);

		     DISPATCH(4);
		   }
		 }
		   
		 if (isLTuple(term)) {
		   TaggedRef *argg = tagged2LTuple(term)->getRef();
		   if (e->fastUnify(Reg1(reg2),makeTaggedRef(argg),
				    NOFLATGUARD())) {
		     Xreg(reg3) = tagged2NonVariable(argg+1);
		     
		     DISPATCH(4);
		   }
		 }

		 SHALLOWFAIL;
		 HF_UNIFY("%s = %s|_ failed\n", Xreg(getRegArg(PC+1)), Reg1(getRegArg(PC+2)), "In instruction GETLISTVALVAR\n" );
	       }''
	       )
  

  CaseOneReg( GETLIST,
	       ``{
		 Reg reg = getRegArg(PC+1);
		 
		 register TaggedRef term = Reg1(reg);
		 DEREF(term,termPtr,tag);

		 if(isAnyVar(term)) {
		   LTuple *ltuple = new LTuple();
		   sPointer = ltuple->getRef();
		   SetWriteMode;
		   if (isCVar(term) == OK) {
		     if(tagged2CVar(term)->unifyOutline(termPtr, term, NULL,
							makeTaggedLTuple(ltuple),
							NOFLATGUARD())) {
		       DISPATCH(2);
		     }
		     term = *termPtr;  // Note: 'term' may be disposed
		   } else {
		     e->bindToNonvar(termPtr, term, makeTaggedLTuple(ltuple),
				     NOFLATGUARD());
		     DISPATCH(2);
		   }
		 }

		 if (isLTuple(term)) {
		   sPointer = tagged2LTuple(term)->getRef();
		   SetReadMode;
		   DISPATCH(2);
		 }
		 

		 SHALLOWFAIL;
		 HF_UNIFY("%s = _|_ failed\n", Reg1(getRegArg(PC+1)), makeTaggedNULL(), "In instruction GETLIST\n" );
	       }''
	       )


  /* a unifyVariable in read mode */
  CaseOneReg( GETVARIABLE,
	       ``{
		 Reg1(getRegArg(PC+1)) = tagged2NonVariable(sPointer);
		 sPointer++;
		 DISPATCH(2);
	       }''
	       )


  CaseTwoRegs( GETVARVAR,
	       ``{
		 Reg1(getRegArg(PC+1)) = tagged2NonVariable(sPointer);
		 Reg2(getRegArg(PC+2)) = tagged2NonVariable(sPointer+1);
		 sPointer += 2;
		 DISPATCH(3);
	       }''
	       )


  /* a unify void in read case mode */
Case(GETVOID):
    {
      sPointer += getPosIntArg(PC+1);
      DISPATCH(2);
    }


  CaseOneReg( UNIFYVARIABLE,
	       ``{
		 if(InWriteMode) {
		   Reg reg = getRegArg(PC+1);
		   TaggedRef *sp = GetSPointerWrite(sPointer);
		   *sp = e->currentUVarPrototype;
		   Reg1(reg) = makeTaggedRef(sp);
		 } else {
		   Reg1(getRegArg(PC+1)) = tagged2NonVariable(sPointer);
		 }
		 sPointer++;
		 DISPATCH(2);
	       }''
	       )


  CaseOneReg( UNIFYVALUE,
	       ``{
		 Reg reg = getRegArg(PC+1);
	
		 if(InWriteMode) {
		   TaggedRef *sp = GetSPointerWrite(sPointer);
		   *sp = Reg1(reg);
		   sPointer++;
		   DISPATCH(2);
		 } else {
		   if (e->fastUnify(Reg1(reg), makeTaggedRef(sPointer++),NOFLATGUARD()) ) {
		     DISPATCH(2);
		   }
		   SHALLOWFAIL;
		   HF_UNIFY("%s = %s failed\n", *(sPointer-1), Reg1(reg), "In instruction UNIFYVALUE\n" );
		 }
	       }''
	       )
  


  Case(UNIFYVALVARXX): ONREG2(UnifyValVar,X,X);
  Case(UNIFYVALVARXY): ONREG2(UnifyValVar,X,Y);
  Case(UNIFYVALVARXG): ONREG2(UnifyValVar,X,G);
  Case(UNIFYVALVARYX): ONREG2(UnifyValVar,Y,X);
  Case(UNIFYVALVARYY): ONREG2(UnifyValVar,Y,Y);
  Case(UNIFYVALVARYG): ONREG2(UnifyValVar,Y,G);
  Case(UNIFYVALVARGX): ONREG2(UnifyValVar,G,X);
  Case(UNIFYVALVARGY): ONREG2(UnifyValVar,G,Y);
  Case(UNIFYVALVARGG): ONREG2(UnifyValVar,G,G);
   UnifyValVar:
     {
       Reg reg = getRegArg(PC+1);
	
       if (InWriteMode) {
	 TaggedRef *sp = GetSPointerWrite(sPointer);
	 *sp = RegAccess(HelpReg,reg);

	 *(sp+1) = e->currentUVarPrototype;
	 RegAccess(HelpReg2,getRegArg(PC+2)) = makeTaggedRef(sp+1);

	 sPointer += 2;
	 DISPATCH(3);
       }
       if ( !e->fastUnify(RegAccess(HelpReg,reg), makeTaggedRef(sPointer),
			  NOFLATGUARD()) ) {
	 SHALLOWFAIL;
	 HF_UNIFY("%s = %s failed\n", *sPointer, RegAccess(HelpReg,reg), "In instruction UNIFYVALVAR\n");
       }

       RegAccess(HelpReg2,getRegArg(PC+2)) = tagged2NonVariable(sPointer+1);

       sPointer += 2;
       DISPATCH(3);
     }
  

Case(UNIFYCONSTANT):
     {
       if (InWriteMode) {
	 TaggedRef *sp = GetSPointerWrite(sPointer);
	 *sp = getTaggedArg(PC+1);
	 sPointer++;
	 DISPATCH(2);
       }

       TaggedRef atm = getLiteralArg(PC+1);
	 
       /* code adapted from GETCONSTANT */
       TaggedRef *termPtr = sPointer;
       sPointer++;
       DEREFPTR(term,termPtr,tag);

       if (isNotCVar(tag)) {
         e->bindToNonvar(termPtr, term, atm, NOFLATGUARD());
         DISPATCH(2);
       }
		 
       if ( isLiteral(tag) && sameLiteral(term,atm) ) {
         DISPATCH(2);
       }

       if (isCVar(term)) {
         if (tagged2CVar(term)->unifyOutline(termPtr,term,NULL,
      				             atm,NOFLATGUARD())) {
	   DISPATCH(2);
	 }
         term = *termPtr;  // Note: 'term' may be disposed
       }

       SHALLOWFAIL;
       HF_UNIFY("%s = %s failed\n", getTaggedArg(PC+1), *(sPointer-1), "In instruction UNIFYCONSTANT\n" );
     }

  Case(UNIFYINT):
    {
      if (InWriteMode) {
	TaggedRef *sp = GetSPointerWrite(sPointer);
	*sp = getTaggedArg(PC+1);
	sPointer++;
	DISPATCH(2);
      } 

      TaggedRef i = getNumberArg(PC+1);
      /* code adapted from GETCONSTANT */
      TaggedRef *termPtr = sPointer;
      sPointer++;
      DEREFPTR(term,termPtr,tag);

      if (isNotCVar(tag)) {
        e->bindToNonvar(termPtr, term, i, NOFLATGUARD());
        DISPATCH(2);
      }
		 
      if ( (tag == tagTypeOf(i)) && numberEq(term,i)) {
	DISPATCH(2);
      }

      if (isCVar(term)) {
	if (tagged2CVar(term)->unifyOutline(termPtr,term,NULL,
					    i,NOFLATGUARD())) {
	  DISPATCH(2);
	}
	term = *termPtr;  // Note: 'term' may be disposed
      }

      SHALLOWFAIL;
      HF_UNIFY("%s = %s failed\n", getTaggedArg(PC+1), *(sPointer-1), "In instruction UNIFYINT\n" );
    }


  Case(UNIFYVOID):
    {
      int n = getPosIntArg(PC+1);
      if (InWriteMode) {
	TaggedRef newVar = e->currentUVarPrototype;
	TaggedRef *sp = GetSPointerWrite(sPointer);
	for (int i = n-1; i >=0; i-- ) {
	  *sp++ = newVar;
	}
      }
      sPointer += n;
      DISPATCH(2);
    }

  CaseOneReg(SWITCHONTERM,
    {
      TaggedRef val     = Reg1(getRegArg(PC+1));
      IHashTable *table = (IHashTable *) getAdressArg(PC+2);

      DoSwitchOnTerm(val,table);
    })

  CaseOneReg( BRANCHONVAR,
	       ``
	       TaggedRef term = Reg1(getRegArg(PC+1));
	       DEREF(term,_1,_2);
	       if (isAnyVar(term)) {
		 JUMP( getLabelArg(PC+2) );
	       }
	       DISPATCH(3);
	       ''
	       )

  CaseOneReg( BRANCHONNONVAR,
	       ``
	       TaggedRef term = Reg1(getRegArg(PC+1));
	       DEREF(term,_1,_2);
	       if (!isAnyVar(term)) {
		 JUMP( getLabelArg(PC+2) );
	       }
	       DISPATCH(3);
	       ''
	       )


