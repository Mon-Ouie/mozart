/*
 *  Authors:
 *    Kostja Popow (popow@ps.uni-sb.de)
 *    Christian Schulte <schulte@ps.uni-sb.de>
 * 
 *  Contributors:
 *    Michael Mehl (mehl@dfki.de)
 *
 *  Copyright:
 *    Organization or Person (Year(s))
 * 
 *  Last change:
 *    $Date$ by $Author$
 *    $Revision$
 * 
 *  This file is part of Mozart, an implementation 
 *  of Oz 3:
 *     http://www.mozart-oz.org
 * 
 *  See the file "LICENSE" or
 *     http://www.mozart-oz.org/LICENSE.html
 *  for information on usage and redistribution 
 *  of this file, and for a DISCLAIMER OF ALL 
 *  WARRANTIES.
 *
 */

// Solver

#ifndef __BOARD_ICC_
#define __BOARD_ICC_

#if !defined(OUTLINE) && defined(INTERFACE)
#pragma interface
#endif

#include "susplist.hh"
#include "value.hh"
#include "am.hh"

#ifdef OUTLINE
#define inline
#endif

inline
void Board::addSuspension(Suspension susp) {
  suspList = new SuspList(susp, suspList);
}

inline
void Board::addToNonMono(Propagator * prop) {
  setNonMono(getNonMono()->insert(prop));
}

inline
void Board::addToDistBag(Distributor * d) {
  setDistBag(getDistBag()->add(d));
}


/*
 * increment/decrement the thread counter
 * in every solve board above
 * if "stable" generate a new thread "solve waker"
 * NOTE:
 *   there may be failed board in between which must be simply ignored
 *
 */

inline
Bool Board::isStable(void) {
  if (getThreads() != 0) 
    return NO;
  
  if (oz_isCurrentBoard(this) && !am.trail.isEmptyChunk())
    return NO;
  
  if (isEmptySuspList())
    return OK;

  clearSuspList((Thread *) NULL);

  return isEmptySuspList();
}

inline
void Board::incSolveThreads(void) {
  Assert(!isCommitted() && !isRoot());
  
  Board * bb = this;
  
  do {
    bb->incThreads(); bb = bb->getParent();
  } while (!bb->isRoot());
  
}

// from thr_int.hh

Thread * oz_newThreadInject(Board * bb);

inline
void Board::decSolveThreads(void) {
  Assert(!isCommitted());

  Board * bb = this;
  
  while (!bb->isRoot()) {
    // ... first - notification board below the failed solve board; 

    if (bb->decThreads()==0 && bb->isStable())
      oz_newThreadInject(bb);
      
    bb = bb->getParent();
  }
  
}

inline
void Board::checkSolveThreads(void) {
  Assert(!isCommitted() && !isRoot());

  Board * bb = this;
  
  do {
    
    if (bb->isStable())
      oz_newThreadInject(bb);
    
    bb = bb->getParent();
  } while (!bb->isRoot());
  
}

inline
TaggedRef Board::genFailed() {
  ozstat.incSolveFailed();
  return AtomFailed;
}


#ifdef OUTLINE
#undef inline
#endif

#endif
