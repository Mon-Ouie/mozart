/* -*- C++ -*-
 *  Authors:
 *    Ralf Scheidhauer <Ralf.Scheidhauer@ps.uni-sb.de>
 *    Konstantin Popov <kost@sics.se>
 * 
 *  Contributors:
 *    Per Brand (perbrand@sics.se)
 *    Michael Mehl (mehl@dfki.de)
 *    Denys Duchier (duchier@ps.uni-sb.de)
 * 
 *  Copyright:
 *    Organization or Person (Year(s))
 * 
 *  Last change:
 *    $Date$ by $Author$
 *    $Revision$
 * 
 *  This file is part of Mozart, an implementation 
 *  of Oz 3:
 *     http://mozart.ps.uni-sb.de
 * 
 *  See the file "LICENSE" or
 *     http://mozart.ps.uni-sb.de/LICENSE.html
 *  for information on usage and redistribution 
 *  of this file, and for a DISCLAIMER OF ALL 
 *  WARRANTIES.
 *
 */

changequote([[,]])

define(readArg,$1)
define(writeArg,$1)
define(instruction,
	case TOUPPER($1):
	   opAction($2)
	   opAction($3)
	   opAction($4)
	   opAction($5)
	   opAction($6)
	   opAction($7)
	   opAction($8)
	   opAction($9)
	  break;)

define(opAction,
[[ifelse($1,Number,gt->marshalOzValue(getTaggedArg(PC++));ozValuesCnt--;,
        $1,Literal,gt->marshalOzValue(getTaggedArg(PC++));ozValuesCnt--;,
        $1,Feature,gt->marshalOzValue(getTaggedArg(PC++));ozValuesCnt--;,
        $1,Constant,gt->marshalOzValue(getTaggedArg(PC++));ozValuesCnt--;,
        $1,Builtinname,_m_bi = (Builtin*)getAdressArg(PC++); marshalBuiltin(gt,_m_bi);ozValuesCnt--;,
        $1,XRegisterIndex,marshalNumber(bs,XRegToInt(getXRegArg(PC++)));,
        $1,YRegisterIndex,marshalNumber(bs,YRegToInt(getYRegArg(PC++)));,
        $1,GRegisterIndex,marshalNumber(bs,GRegToInt(getGRegArg(PC++)));,
        $1,Arity,marshalNumber(bs,(unsigned int)getPosIntArg(PC++));,
        $1,Label,marshalLabel(bs,instrstart-start,getLabelArg(PC++));,
        $1,Count,marshalNumber(bs,(unsigned int)getPosIntArg(PC++));,
        $1,ArityAndIsTail,marshalNumber(bs,(unsigned int)getPosIntArg(PC++));,
        $1,Dummy,marshalNumber(bs,(unsigned int)getPosIntArg(PC++));,
        $1,ProcedureRef,marshalProcedureRef(gt,(AbstractionEntry*)getAdressArg(PC++),bs);,
        $1,PredId,marshalPredId(gt,(PrTabEntry*)getAdressArg(PC++),bs);ozValuesCnt--;,
        $1,HashTableRef,marshalHashTableRef(gt,instrstart-start,(IHashTable *)getAdressArg(PC++),bs);ozValuesCnt--;,
        $1,RecordArity,marshalRecordArity(gt,(SRecordArity) getAdressArg(PC++),bs);ozValuesCnt--;,
        $1,CallMethodInfo,marshalCallMethodInfo(gt,(CallMethodInfo*)getAdressArg(PC++),bs);ozValuesCnt--;,
        $1,GRegRef,marshalGRegRef((AssRegArray*)getAdressArg(PC++),bs);,
        $1,Location,marshalLocation(_m_bi,(OZ_Location*)getAdressArg(PC++),bs);,
        $1,Cache,PC += CacheSize;)]])


//
// Returns OK if the instructioN 'op' at 'PC' won't fit in
// 'avaliSpace'. Defined ahead, since it redefines m4 macros;
static Bool needNewBuffer(Opcode op, ProgramCounter PC, int availSpace);

//
//
Bool dpMarshalCode(GenTraverser *gt, void *arg)
{
  MarshalerCodeAreaDescriptor *desc = (MarshalerCodeAreaDescriptor *) arg;
  // ('bs' could be also saved in the argument;)
  ByteBuffer *bs = (ByteBuffer *) gt->getOpaque();
  ProgramCounter start = desc->getStart(), end = desc->getEnd();
  ProgramCounter PC = desc->getCurrent();
  // when 'ozValuesCnt' hits zero, then the code area must be broken
  // in two pieces (before a next instructioN):
  int ozValuesCnt = ozValuesBADP;
  Builtin * _m_bi; // Needed for passing information from marshalling
                   // builtins to locations

  //
  if (PC == start) marshalCodeStart(bs);
  marshalDIF(bs, DIF_CODEAREA);

  //
  while (ozValuesCnt > 0 && PC < end) {
    ProgramCounter instrstart = PC;
    Opcode op = CodeArea::getOpcode(PC);

    //
    // Now, the additional check: will it fit in the remaining part of
    // the buffer?
    if (needNewBuffer(op, PC, bs->availableSpace())) {
      // 'ENDOFCHUNK' is not necessary normally (since the receiver
      // counts Oz values and PC as well), but here we need it 'cause
      // the receiver does not know that we had to suspend here:
      marshalOpCode(bs, instrstart-start, ENDOFCHUNK);
      marshalDIF(bs, DIF_SUSPEND);
      gt->suspendBA();
      break;
    }
    PC++;

    //
    if (op == CALLPROCEDUREREF)
      op = (getNumberArg(PC+1) & 1)==0 ? FASTCALL : FASTTAILCALL;

    //
    // (RS?) fastcalls need special handling
    // kost@ : ... that is, one cannot put internal pointers into the
    // stream; thus, these instructioNs get replaced by some other
    // instructioNs.
    if (op == FASTCALL || op == FASTTAILCALL) {
      AbstractionEntry *entry = (AbstractionEntry *) getAdressArg(PC);
      if (!entry->isCopyable()) {
	marshalOpCode(bs, instrstart-start, CALLCONSTANT);
	Abstraction *abstr = entry->getAbstr();

	//
	gt->marshalOzValue(makeTaggedConst(abstr));
	ozValuesCnt--;

	// 
	Bool istailcall = (op==FASTTAILCALL);
	marshalNumber(bs, (abstr->getArity()<<1)|istailcall);
	PC++; // skip (AbstractionEntry *)
	PC++; // skip unused second arg
	continue;
      }
    }

    //
    marshalOpCode(bs, instrstart-start, op);
    switch(op) {

      changequote(`,') dnl '
      include(EMUDIR/../instrDefs.m4)
      changequote([[,]])

    // don't indent the next line:
    default: Assert(0); break;
    }
  }

  // (don't indent the next line:)
  if (PC >= end) {
    marshalOpCode(bs, PC-start, ENDOFFILE);
    marshalCodeEnd(bs);
    //
    delete desc;
    return (TRUE);
  } else {
    desc->setCurrent(PC);
    return (FALSE);
  }
}

//
// The following m4 definitions are based on the following object sizes:
//
// Number [ov]
// Literal [ov]
// Feature [ov]
// Constant [ov]
// Builtinname [ov]
// XRegisterIndex int
// YRegisterIndex int
// GRegisterIndex int
// Arity int
// Label int
// Count int
// ArityAndIsTail int
// Dummy int
// ProcedureRef int,dif,int
// PredId [ov],int,int|[ov],[ov],int,int,[ov],int
// HashTableRef int,int,int,N=int,(int,int,[ov])|(int,int,[ov],int,(int|[oz]))*N
// RecordArity int,int|[oz]
// CallMethodInfo int,[oz],int,int|[oz]
// GRegRef N=int,int*N
// Location N1=int,N2=int,int*(N1+N2)
// Cache 
//

//
undefine([[opAction]])
define(opAction,
[[ifelse($1,Number,PC++;,
         $1,Literal,PC++;,
         $1,Feature,PC++;,
         $1,Constant,PC++;,
         $1,Builtinname,_m_bi = (Builtin*)getAdressArg(PC++);,
         $1,XRegisterIndex,size+=MNumberMaxSize;PC++;,
         $1,YRegisterIndex,size+=MNumberMaxSize;PC++;,
         $1,GRegisterIndex,size+=MNumberMaxSize;PC++;,
         $1,Arity,size+=MNumberMaxSize;PC++;,
         $1,Label,size+=MNumberMaxSize;PC++;,
         $1,Count,size+=MNumberMaxSize;PC++;,
         $1,ArityAndIsTail,size+=MNumberMaxSize;PC++;,
         $1,Dummy,size+=MNumberMaxSize;PC++;,
         $1,ProcedureRef,size+=(2*MNumberMaxSize + DIFMaxSize);PC++;,
         $1,PredId,size+=5*MNumberMaxSize;PC++;,
         $1,HashTableRef,size+=(((IHashTable *)getAdressArg(PC++))->getEntries()*4*5*MNumberMaxSize + 3*MNumberMaxSize);,
         $1,RecordArity,size+=2*MNumberMaxSize;PC++;,
         $1,CallMethodInfo,size+=3*MNumberMaxSize;PC++;,
         $1,GRegRef,size+=((((AssRegArray *)getAdressArg(PC++))->getSize() + 1)*MNumberMaxSize);,
         $1,Location,size+=((_m_bi->getInArity() + _m_bi->getOutArity())*MNumberMaxSize + 2*MNumberMaxSize);,
         $1,Cache,PC += CacheSize;)]])

//
static Bool needNewBuffer(Opcode op, ProgramCounter PC, int availSpace)
{
  // If the current instructioN is the last one, the following
  // 'ENDOFCHUNK' pseudo-instructioN and 'DIF_SUSPEND' must fit too:
  int size = DIFMaxSize + 2*OpcodeMaxSize;
  Builtin *_m_bi;

  PC++;				// skip opcode;
  switch(op) {

    changequote(`,') dnl '
    include(EMUDIR/../instrDefs.m4)
    changequote([[,]])

  // don't indent the next line:
  default: Assert(0); break;
  }

  return ((size <= availSpace) ? NO : OK);
}


#ifdef USE_FAST_UNMARSHALER   
//
undefine([[opAction]])

define(opAction,
[[ifelse($1,Number,PC=unmarshalOzValue(b,PC,code);ozValuesCnt--;,
        $1,Literal,PC=unmarshalOzValue(b,PC,code);ozValuesCnt--;,
        $1,Feature,PC=unmarshalOzValue(b,PC,code);ozValuesCnt--;,
        $1,Constant,PC=unmarshalOzValue(b,PC,code);ozValuesCnt--;,
        $1,Builtinname,PC=unmarshalBuiltin(b,PC);ozValuesCnt--;,
        $1,XRegisterIndex,PC=unmarshalXReg(PC,bs);,
        $1,YRegisterIndex,PC=unmarshalYReg(PC,bs);,
        $1,GRegisterIndex,PC=unmarshalGReg(PC,bs);,
        $1,Arity,PC=unmarshalNum(PC,bs);,
        $1,Label,PC=unmarshalLabel(PC,bs);,
        $1,Count,PC=unmarshalNum(PC,bs);,
        $1,ArityAndIsTail,PC=unmarshalNum(PC,bs);,
        $1,Dummy,PC=unmarshalNum(PC,bs);,
        $1,ProcedureRef,PC=unmarshalProcedureRef(b,PC,bs,code);,
        $1,PredId,PC=unmarshalPredId(b,PC,lastPC,bs);ozValuesCnt--;,
        $1,HashTableRef,PC=unmarshalHashTableRef(b,PC,bs);ozValuesCnt--;,
        $1,RecordArity,PC=unmarshalRecordArity(b,PC,bs);ozValuesCnt--;,
        $1,CallMethodInfo,PC=unmarshalCallMethodInfo(b,PC,bs);ozValuesCnt--;,
        $1,GRegRef,PC=unmarshalGRegRef(PC,bs);,
        $1,Location,PC=unmarshalLocation(PC,bs);,
        $1,Cache,PC=unmarshalCache(PC,code);)]])

//
// Returning 'OK' means we are done (with the code area); 
// 'pc' can be zero meaning "discard the code". If it is non-zero,
// then it is supposed to be large enough to hold the whole code;
Bool dpUnmarshalCode(ByteBuffer *bs, Builder *b, 
		     BuilderCodeAreaDescriptor *desc)
{
  int ozValuesCnt = ozValuesBADP;
  ProgramCounter PC = desc->getCurrent();
  ProgramCounter lastPC;
  // 'CodeArea*' is passed in it itself:
  CodeArea *code = desc->getCodeArea();
  Bool done = NO;

  //
  while (ozValuesCnt > 0) {
    lastPC = PC;
    Opcode op = (Opcode) bs->get();
    if (op == ENDOFFILE) {
      done = OK;
      break;
    }
    if (op == ENDOFCHUNK) {
      break;
    }

    //
    if (op == DEBUGENTRY && PC)
      b->schedGenAction(handleDEBUGENTRY, PC);

    //
    Assert(op != CALLPROCEDUREREF);
    if (PC)
      PC = CodeArea::writeOpcode(op,PC);

    //
    switch(op) {

      changequote(`,') dnl '
      include(EMUDIR/../instrDefs.m4)
      changequote([[,]])

    default: Assert(0); break;
    }
  }

  //
  if (done)
    delete desc;
  else
    desc->setCurrent(PC);
  return (done);
}

#else

// Robust unmarshaling
undefine([[opAction]])

define(opAction,
[[ifelse($1,Number,PC=unmarshalOzValue(b,PC,code);ozValuesCnt--;,
        $1,Literal,PC=unmarshalOzValue(b,PC,code);ozValuesCnt--;,
        $1,Feature,PC=unmarshalOzValue(b,PC,code);ozValuesCnt--;,
        $1,Constant,PC=unmarshalOzValue(b,PC,code);ozValuesCnt--;,
        $1,Builtinname,PC=unmarshalBuiltin(b,PC);ozValuesCnt--;,
        $1,XRegisterIndex,PC=unmarshalXRegRobust(PC,bs,&e);if(e) return ERR;,
        $1,YRegisterIndex,PC=unmarshalYRegRobust(PC,bs,&e);if(e) return ERR;,
        $1,GRegisterIndex,PC=unmarshalGRegRobust(PC,bs,&e);if(e) return ERR;,
        $1,Arity,PC=unmarshalNumRobust(PC,bs,&e);if(e) return ERR;,
        $1,Label,PC=unmarshalLabelRobust(PC,bs,&e);if(e) return ERR;,
        $1,Count,PC=unmarshalNumRobust(PC,bs,&e);if(e) return ERR;,
        $1,ArityAndIsTail,PC=unmarshalNumRobust(PC,bs,&e);if(e) return ERR;,
        $1,Dummy,PC=unmarshalNumRobust(PC,bs,&e);if(e) return ERR;,
        $1,ProcedureRef,PC=unmarshalProcedureRefRobust(b,PC,bs,code,&e);if(e) return ERR;,
        $1,PredId,PC=unmarshalPredIdRobust(b,PC,lastPC,bs,&e);ozValuesCnt--;if(e) return ERR;,
        $1,HashTableRef,PC=unmarshalHashTableRefRobust(b,PC,bs,&e);ozValuesCnt--;if(e) return ERR;,
        $1,RecordArity,PC=unmarshalRecordArityRobust(b,PC,bs,&e);ozValuesCnt--;if(e) return ERR;,
        $1,CallMethodInfo,PC=unmarshalCallMethodInfoRobust(b,PC,bs,&e);ozValuesCnt--;if(e) return ERR;,
        $1,GRegRef,PC=unmarshalGRegRefRobust(PC,bs,&e);if(e) return ERR;,
        $1,Location,PC=unmarshalLocationRobust(PC,bs,&e);if(e) return ERR;,
        $1,Cache,PC=unmarshalCache(PC,code);)]])


//
// Returning 'OK' means we are done (with the code area); 
// 'pc' can be zero meaning "discard the code". If it is non-zero,
// then it is supposed to be large enough to hold the whole code;
// Returning 'ERR' means that the buffer can not be marshalled.
Bool dpUnmarshalCodeRobust(ByteBuffer *bs, Builder *b, 
			   BuilderCodeAreaDescriptor *desc)
{
  int e; 
  int ozValuesCnt = ozValuesBADP;
  ProgramCounter PC = desc->getCurrent();
  ProgramCounter lastPC;
  // 'CodeArea*' is passed in it itself:
  CodeArea *code = desc->getCodeArea();
  Bool done = NO;

  //
  while (ozValuesCnt > 0) {
    lastPC = PC;
    Opcode op = (Opcode) bs->get();
    if (op == ENDOFFILE) {
      done = OK;
      break;
    }
    if (op == ENDOFCHUNK) {
      break;
    }

    //
    if (op == DEBUGENTRY && PC)
      b->schedGenAction(handleDEBUGENTRY, PC);

    //
    Assert(op != CALLPROCEDUREREF);
    if (PC)
      PC = CodeArea::writeOpcode(op,PC);

    //
    switch(op) {

      changequote(`,') dnl '
      include(EMUDIR/../instrDefs.m4)
      changequote([[,]])

    default: return ERR;
    }
  }

  //
  if (done)
    delete desc;
  else
    desc->setCurrent(PC);
  return (done);
}

#endif
