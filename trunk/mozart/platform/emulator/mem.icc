/*
 *  Authors:
 *    Ralf Scheidhauer (Ralf.Scheidhauer@ps.uni-sb.de)
 * 
 *  Contributors:
 *    optional, Contributor's name (Contributor's email address)
 * 
 *  Copyright:
 *    Organization or Person (Year(s))
 * 
 *  Last change:
 *    $Date$ by $Author$
 *    $Revision$
 * 
 *  This file is part of Mozart, an implementation 
 *  of Oz 3:
 *     $MOZARTURL$
 * 
 *  See the file "LICENSE" or
 *     $LICENSEURL$
 *  for information on usage and redistribution 
 *  of this file, and for a DISCLAIMER OF ALL 
 *  WARRANTIES.
 *
 */

#ifndef __mem_icc__
#define __mem_icc__

#if defined(INTERFACE) && !defined(OUTLINE)
#pragma interface
#endif


inline
void * freeListMalloc(size_t size) {
  Assert(((size & 3) == 0) && (size > 0));

  if (size < freeListMaxSize) {

    register void ** fl = &(FreeList[size]);
    register void * aux = *fl;

    if (aux) {
      *fl = *((void **) aux);
      DebugMem(memset((char *)aux,0x5A,size));
      return aux;
    }

  } 

  register void * aux = heapMalloc(size);
  
  DebugMem(memset((char *)aux,0x5A,size));

  return aux;
}
    

static void freeListChop(void * addr, size_t size);

inline
void freeListDisposeNoClean(void * addr, size_t size) {
  Assert((size & 3) == 0);
  Assert(size > 0);

  register void ** fl;

  if (size < freeListMaxSize) {
    fl = &(FreeList[size]);
#ifdef DEBUG_MEM
    void * aux = *fl;
    while (aux) {
      Assert(aux != addr); 
      aux = * (void **) aux;
    }
#endif
    *((void **) addr) = *fl;
    *fl = addr;
  } else { 
    freeListChop(addr, size);
  }

}

inline
void freeListDispose(void * addr, size_t chunk_size) {

  DebugCode(memset((char *)addr,0x5A,chunk_size));

  freeListDisposeNoClean(addr, chunk_size);

}


static void freeListChop(void * addr, size_t size) {
  // Chop the chunk into pieces of the likely sizes
  // Likely sizes are between 8 and 32.

  register size_t cs = nextChopSize;

  if (nextChopSize > 32) 
    nextChopSize = 8;
  else
    nextChopSize += 4;

  register size_t s     = size;
  register void ** fl   = &(FreeList[cs]);
  register void * prev  = *fl;
  register void * small = addr;

  do {
    *((void **) small) = prev;
    prev = small;
    small = (void *) ((char *) small + cs);
    s     -= cs; 
  } while (s > cs);
  
  *fl = prev;

}

// return used kilo bytes on the heap
inline 
unsigned int getUsedMemory(void)
{
  return heapTotalSize - (heapTop - heapEnd)/KB;
}

inline 
unsigned int getUsedMemoryBytes(void)
{
  return heapTotalSizeBytes - (heapTop - heapEnd);
}

#endif //__mem_icc__









