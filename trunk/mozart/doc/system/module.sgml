<!--
  - Authors:
  -   Christian Schulte <schulte@dfki.de>
  -
  - Copyright:
  -   Christian Schulte, 1998
  -
  - Last change:
  -   $Date$ by $Author$
  -   $Revision$
  -
  - This file is part of Mozart, an implementation
  - of Oz 3
  -    http://mozart.ps.uni-sb.de
  -
  - See the file "LICENSE" or
  -    http://mozart.ps.uni-sb.de/LICENSE.html
  - for information on usage and redistribution
  - of this file, and for a DISCLAIMER OF ALL
  - WARRANTIES.
  -
  -->


  <Chapter id="Chapter.Module">
    <Title/Module Managers: <<Module>>/

    <P>
      Module managers load pickled functors, link the obtained
      functors, and execute them and return modules obtained by
      functor execution. The Mozart virtual machine starts with a
      single module manager that executes the functor to which the
      virtual machine is applied. The module <<Module>> provides a
      class from which new module managers can be created.
    </P>

    <Section id="Section.Module.Basic">
      <Title/Module Tables/

      <P>
        A module manager maintains a module table, that maps URLs to
        modules or futures. The URL identifies the functor that has
        been used (or that will be used, in case of a future) to
        compute the module.
      </P>
 
      <P>
        Linking a functor takes a URL ?_{U} as input and returns a
        module ?_{M} (or a future to the module) as output. If the
        module manager already has an entry for 
        ?_{U} in its module table, it just returns this
        entry. Otherwise, it creates a future ?_{MF}, stores this
        future in the module table, and returns that future.
      </P>

      <P>
        As soon as the future's value gets requested, the module
        identified by ?_{U} is <Em/installed/ as follows. The pickled
        functor stored at URL ?_{U} gets loaded and applied to its
        argument modules. The future then is bound to the computed
        modules. 
      </P> 
       
      <P> 
        A module manager is implemented as an instance of the class
        <<Module.manager>>. The class provides methods to link and
        apply functors and to enter first class modules into the
        module manager's module table.
      </P>

      <P>
        The behaviour of a module manager as it comes to loading
        pickled functors can be refined and customized by creating
        classes by inheritance that refine particular methods.
      </P>

    </Section>

    <Section id="Section.Modules.Names">
      <Title/Module Names and URLs/

      <P>
        As has been explained above, each module is refered to by a
        URL, some of which are Oz specific in that they refer to
        system modules. We just say that the module <Em/has the URL/. 
      </P>

      <P>
        A <Em/module name/ is a shortcut
        for a module URL. System module or extension appended.
      </P>

    </Section>

    <Section id="Section.Modules.Link">
      <Title/The Class <<Module.manager>>/

      <P>
        Module managers are created as instances of the class
        <<Module.manager>>. For predefined abstractions that are build
        on top of module managers see <Ptr
        to="section.modules.abstractions">.
      </P>

      <P>
        <List>
          <Entry><Span class=index/<<init>>/
	    <Index/<<Module>><And><<manager>><And><<init>>/
          <Synopsis>
	    <<<init()>>>
          <Item>
            Initializes the module manager.

          <Entry><Span class=index/<<link>>/
	    <Index/<<Module>><And><<manager>><And><<link>>/
          <Synopsis>
	    <<<link(url:?+{UrlV} ?_{ModuleR} <= _)>>>
	    <<<link(name:?+{NameV} ?_{ModuleR} <= _)>>>
          <Item>
            Links the module identified either by a url ?_{UrlV} (a
            virtual string) or a module name ?_{NameV} (a virtual
            string). Returns the module ?_{ModuleR}, if it has been
            already linked or a future to it.
          <P>
            The argument for the module is optional, if it is omitted
            the module is requested immediately.

          <Entry><Span class=index/<<apply>>/
	    <Index/<<Module>><And><<manager>><And><<apply>>/
          <Synopsis>
	    <<<apply(?+{Functor} ?_{ModuleR} <= _)>>>
	    <<<apply(url:?+{UrlV} ?+{Functor} ?_{ModuleR} <= _)>>>
	    <<<apply(name:?+{NameV} ?+{Functor} ?_{ModuleR} <= _)>>>
          <Item>
            Applies the functor ?_{Functor}, where the url ?_{UrlV} (a
            virtual string) or the module name ?_{NameV} (a virtual
            string) serve as base URL for linking the functor's
            import. If neither a module name nor a URL is given, the 
            current working directory is taken as base URL.
          <P>
            The argument for the module is optional.
          <P>
            Please note that the resulting module is <Em/not/ added to
            the module table, the URL argument only serves as base URL
            for the functor's import.

          <Entry><Span class=index/<<enter>>/
	    <Index/<<Module>><And><<manager>><And><<enter>>/
          <Synopsis>
	    <<<enter(url:?+{UrlV} ?_{ModuleR})>>>
	    <<<enter(name:?+{NameV} ?_{ModuleR})>>>
          <Item>
            Installs the module ?_{ModuleR} under the url ?_{UrlV} (a
            virtual string) or the module name ?_{NameV} (a virtual
            string).
          <P>
            Raises an exception if the module manager already has a
            module under that particular URL installed.
        </List>
       </P>         
    </Section>

    <Section id="Section.Modules.Abstractions">
      <Title/Predefined Abstractions/

      <P>
        <List>
          <Entry><Span class=index/<<link>>/
	    <Index/<<Module>><And><<link>>/
          <Synopsis>
	    <<<{Module.link ?+{UrlVs} ?_{Rs}}>>>
          <Item>
             Takes a list ?_{UrlVs} of urls (as virtual strings) at
             which pickled functors must reside.
          <P>
            Returns a list of modules computed by linking the
            functors.
          <P>
            All functors are linked by the same module manager,
            however each application of Module.link employs a new and
            private module manager. This has the following
            consequences:
            <List>
              <Item> 
                Modules imported by several functors are shared.
              <Item>
                Each application of <<Module.link>> links required
                functors anew. That is, after replacing a functor on
                the file system, an application of <<Module.link>>
                considers the new functor.
            </List>
          <P>
            <<Module.link>> is defined as follows:
<<<fun {Module.link UrlVs}
   ModMan = {New Module.manager init}
in
   {Map UrlVs fun {$ Url}
	         {ModMan link(url:Url $)}
	      end}
end>>>

          <Entry><Span class=index/<<apply>>/
	    <Index/<<Module>><And><<apply>>/
          <Synopsis>
            <<<{Module.apply ?+{Xs} ?_{Rs}}>>>
          <Item>
            Takes a list of functors or pairs of urls (as virtual
            strings) as input. The url in a pair of url and functor
            describes the base url with which the import urls of the
            functor gets resolved. If it is missing the base url './'
            is used for url resolution. 
          <P>
            Returns a list of modules computed by functor application.
          <P>
            <<Module.apply>> is defined as follows:
<<<fun {Module.apply UrlVs}
   ModMan = {New Module.manager init}
in
   {Map UFs fun {$ UF}
	       case UF of U#F then
		  {ModMan apply(url:U F $)}
	       else
		  {ModMan apply(UF $)}
	       end
	    end}
end>>>
        </List>
       </P>         
      
    </Section>

<!--

    <Section id="Section.Modules.Example">
      <Title/An Example/
    </Section>

    <Section id="Section.Modules.Inherit">
      <Title/Customizing Module Managers/

      <P>
        This still stinks completely.
      </P>

    </Section>

-->

  </Chapter>

