<!--
  - Authors:
  -   Denys Duchier     <duchier@ps.uni-sb.de>
  -   Leif Kornstaedt <kornstae@ps.uni-sb.de>
  -   Christian Schulte <schulte@ps.uni-sb.de>
  -
  - Copyright:
  -   Denys Duchier, 1998
  -   Leif Kornstaedt, 1998
  -   Christian Schulte, 1998
  -
  - Last change:
  -   $Date$ by $Author$
  -   $Revision$
  -
  - This file is part of Mozart, an implementation
  - of Oz 3
  -    http://mozart.ps.uni-sb.de
  -
  - See the file "LICENSE" or
  -    http://mozart.ps.uni-sb.de/LICENSE.html
  - for information on usage and redistribution
  - of this file, and for a DISCLAIMER OF ALL
  - WARRANTIES.
  -
  -->

  <Chapter id="Chapter.Remote">
    <Title/Spawning Computations Remotely: <<Remote>>/

    <P>
      The module <<Remote>> provides the class <<Remote.manager>> by
      which new Oz processes can be created. Creating an instance of
      that class does the following two things:
      <List>
        <Item> A new Oz process with a module manager ?_{M} is
               created. 
        <Item> The newly created object ?_{O} serves as a proxy to
               ?_{M}, where ?_{O} can be seen as a remote module
               manager. This allows to start applications remotely
               that access remote resources by local system modules.
      </List>
    </P>
 
    <P>
      The methods of the class <<Remote.manager>> are as follows.
    </P>

    <P>
      <List>
        <Entry><Span class=index/<<init>>/
	  <Index/<<Remote>><And><<manager>><And><<init>>/
        <Synopsis>
<code display/init(host:   ?+{HostV}   <= localhost
     fork:   ?+{ForkA}   <= automatic
     detach: ?+{DetachB} <= false)/
        <Item>
          Creates a new Oz process at ?_{HostV} (specified by a virtual
          string), where <<localhost>> is the computer running the
          current Oz process.

        <P>
          ?_{ForkA} (an atom) determines the operating system method
          to fork the remote Oz process. Currently, <<'automatic'>>,
          <<'sh'>>, and <<'rsh'>> are supported.  

        <p>
          <<'rsh'>> creates
          a shell remotely by using the Unix <code
          proglang=sh>rsh</code> command, which in turn creates the
          new Oz engine.  

        <para class=apropos proglang=sh><title/<<rsh>> configuration/
          Remote managers with method <<rsh>> only work properly, if
          the <<rsh>> command is set up properly. You can test it for
          the host ?{Host} by executing the following command in the
          operating system shell: 
          <<<rsh ?{Host} ozengine x-oz://system/RemoteServer.ozf --test>>> 
          If the message
          <code display proglang=fundamental>Remote: Test succeeded...</code>   
          is printed, your configuration is okay. This requires
          two things:
          <list enum>
            <item>
               Execution of <<rsh ?{Host}>> must not prompt for a
               password. This is usually achieved by having a special
               file <file/.rhosts/ in your home directory. Each entry
               in that file must be a host name. For those hosts
               having an entry in that file, <<rsh>> does not prompt for a
               password. 

              <p>
               Take the following sample <file/.rhosts/ file:
<code display proglang=none>
godzilla.ps.uni-sb.de
bamse.sics.se
</code>
               If the <<rsh>> command is now executed on
               <<bamse.sics.se>> or <<godzilla.ps.uni-sb.de>>, then
               <<rsh>> does not prompt for a pass word.

              <p>
               With other words, all host names that you ever want to
               use with <<Remote.manager>> should be in <file/.rhosts/.
               
            <item>
               After the login performed by <<rsh>> the
               command <<ozengine>> must be 
               executable. This should be always the case, if Mozart
               has been installed properly on your computer. This in
               particular requires that <<$OZHOME/bin>> is in your path of
               executables (<<$OZHOME>> refers to the directory where
               Mozart has been installed). 
          </list>
          
        <para class=apropos><title/<<sh>> configuration/
          <<'sh'>> can only be used, if ?_{HostV} is <<localhost>> and
          just creates a new Oz engine by using the Unix <code
          proglang=sh>sh</code> command. You can test whether this
          method works on your computer by:
          <<<sh -c 'ozengine x-oz://system/RemoteServer.ozf --test'>>>
          This should be always the case, if Mozart
          has been installed properly on your computer. This in
          particular requires that <<$OZHOME/bin>> is in your path of
          executables (<<$OZHOME>> refers to the directory where
          Mozart has been installed).

        <P>
          If ?_{HostV} is <<'localhost'>> and ?_{ForkA} is
          <<'automatic'>> a possibly more efficient way of
          communication between forked and forking process is used. It
          takes advantage of shared memory rather than network
          communication. 
          If your current Oz engine does not support this more
          efficient alternative, the <<'sh'>>
          method is used as fall-back. 

        <P>
          If ?_{DetachB} is <<false>>, a non-detached process is
          created. A non-detached process terminates as soon as 
          the creating process does (think of crashes, there will be
          no orphaned processes). A lifetime of a detached process
          (that is, ?_{DetachB} is <<true>>) is independent of the
          creating process.

        <Entry><Span class=index/<<link>>/
	  <Index/<<Remote>><And><<manager>><And><<link>>/
        <Synopsis>
	    <code display/link(url:?+{UrlV} ?_{ModuleR} <= _)/
	    <code display/link(name:?+{NameV} ?_{ModuleR} <= _)/
        <Item>
            Links the module identified either by a url ?_{UrlV} (a
            virtual string) or a module name ?_{NameV} (a virtual
            string). Returns the module ?_{ModuleR}, if it has been
            already linked or a future to it.
          <P>
            The argument for the module is optional, if it is omitted
            the module is requested immediately.

          <Entry><Span class=index/<<apply>>/
	    <Index/<<Remote>><And><<manager>><And><<apply>>/
          <Synopsis>
	    <code display/apply(?+{Functor} ?_{ModuleR} <= _)/
	    <code display/apply(url:?+{UrlV} ?+{Functor} ?_{ModuleR} <= _)/
	    <code display/apply(name:?+{NameV} ?+{Functor} ?_{ModuleR} <= _)/
          <Item>
            Applies the functor ?_{Functor}, where the url ?_{UrlV} (a
            virtual string) or the module name ?_{NameV} (a virtual
            string) serve as base url for resolving the functor's
            import.
          <P>
            The argument for the module is optional.
          <P>
            Please note that the resulting module is <Em/not/ added to
            the module table, the URL argument only serves as base URL
            for the functor's import.

          <Entry><Span class=index/<<enter>>/
	    <Index/<<Remote>><And><<manager>><And><<enter>>/
          <Synopsis>
	    <code display/enter(url:?+{UrlV} ?_{ModuleR})/
	    <code display/enter(name:?+{NameV} ?_{ModuleR})/
          <Item>
            Installs the module ?_{ModuleR} under the url ?_{UrlV} (a
            virtual string) or the module name ?_{NameV} (a virtual
            string).
          <P>
            Raises an exception if the module manager already has a
            module under that particular url installed.

          <Entry><Span class=index/<<ping>>/
	    <Index/<<Remote>><And><<manager>><And><<ping>>/
          <Synopsis>
	    <code display/ping()/
          <Item>
           Raises exception if remote process is dead. Blocks until
           executed by remote process.

          <Entry><Span class=index/<<close>>/
	    <Index/<<Remote>><And><<manager>><And><<close>>/
          <Synopsis>
	    <code display/close()/
          <Item>
            Kills the remote process.

        </List>
       </P>         

     
  </Chapter>

<!--
Local Variables:
mode: sgml
mode: auto-fill
sgml-default-dtd-file: "part.ced"
sgml-auto-activate-dtd: t
adaptive-fill-mode: nil
End:
-->
