<!--
  - Authors:
  -   Denys Duchier     <duchier@ps.uni-sb.de>
  -   Leif Kornstaedt <kornstae@ps.uni-sb.de>
  -   Christian Schulte <schulte@dfki.de>
  -
  - Copyright:
  -   Denys Duchier, 1998
  -   Leif Kornstaedt, 1998
  -   Christian Schulte, 1998
  -
  - Last change:
  -   $Date$ by $Author$
  -   $Revision$
  -
  - This file is part of Mozart, an implementation
  - of Oz 3
  -    http://mozart.ps.uni-sb.de
  -
  - See the file "LICENSE" or
  -    http://mozart.ps.uni-sb.de/LICENSE.html
  - for information on usage and redistribution
  - of this file, and for a DISCLAIMER OF ALL
  - WARRANTIES.
  -
  -->

<Part id="Part.Distributed">
  <Title/Distributed Programming/

  <P>
  </P>


  <Chapter id="Chapter.Connection">
    <Title/Connecting Computations: <<Connection>>/

    <P>
      Oz uses a ticket-based mechanism to establish
      connections between independent Oz processes.
      One process (called <Def/server/) creates a ticket
      with which other sites (called <Def/clients/)
      can establish a connection.
    </P>

    <P>
      A <Def/ticket/ is a character string 
      which can be stored and transported through all media that can
      handle text, e.g., phone lines, electronic mail, paper,
      and so forth. Tickets are insecure, in that they can be forged
      (albeit some luck is required, since they offer some security
      against typos). The following is an example ticket encoded as an
      Oz atom: <<<'x-ozticket://134.96.186.115:9000:egbj0:DS/v:s:kn'>>>
    </P>

    <P>
      The ticket identifies both the server and the value to
      which a remote reference will be made. Independent connections
      can be made to different values on the same server. Once an
      initial connection is established by the value exchanged, then
      further connections as desired by applications can be built from
      programming abstractions, like object, classes, ports or
      procedures.
    </P>
    
    <P>
      Two different types of connections and tickets are supported:
      <List>
        <Entry>
          <Def/One-to-one connections/ and <Def/one-shot tickets/.
        <Item>
          Allow to establish a single connection only.

        <Entry>
          <Def/Many-to-one connections/ and <Def/many-shot tickets/.
        <Item>
          Allow multiple connections with the same ticket to the same
          value. Values for many-to-one connections are offered
          through gates.
       </List>
    </P>

    <P>
      The module <Span class=index/<<Connection>>/ provides procedures
      and classes that support both one-to-one and many-to-one
      connections.
    </P>

    <Section id="Section.Connection.One">
      <Title/One-to-one Connections/

      <P>
        <List>
          <Entry><Span class=index/<<offer>>/
	    <Index/<<Connection>><And><<offer>>/
          <Synopsis>
	    <<{Connection.offer ?_{X} ?_{TicketA}}>>
          <Item>
            Returns the single-shot ticket ?_{TicketA} (an atom)
            under which the value ?_{X} is offered.
          <P>
            The value ?_{X} is exported immediately. An exception is
            raised, if exportation of ?_{X} fails, because ?_{X}
            refers to sited entities.

          <Entry><Span class=index/<<take>>/
	    <Index/<<Connection>><And><<take>>/
          <Synopsis>
	    <<{Connection.take ?+{TicketV} ?_{X}}>>
          <Item>
            Returns the value ?_{X} offered under the ticket
            ?_{TicketV} (a virtual string).
          <P>
            Waits until the connection to the offering process is
            established and the ticket has been acknowledged by that
            process.
          <P>
            Raises an exception if the ticket is illegal, or if the
            offering process does not longer exist.
          <P>
            Also works for many-shot tickets, where an exception might
            be raised if the same ticket is used more than once.
        </List>
      </P>
    </Section>

    <Section id="Section.Connection.Many">
      <Title/Many-to-one Connections/
      
      <P>
        Values for many-to-one connections can be offered through
        <Def/gates/. Values offered through gates can be taken with
        <Span class=index/<<Connection.take>>/ as described for
        one-to-one connections.
      </P>

      <P>
        Gates are provided as instances of the class
        <Span class=index/<<Connection.gate>>/. The methods of
        <<Connection.gate>> are as follows.
      </P>

      <P>
        <List>
          <Entry><Span class=index/<<init>>/
	    <Index/<<Connection>><And><<gate>><And><<init>>/
          <Synopsis>
	    <<init(?_{X} ?_{TicketA} <= _)>>
          <Item>
            Optionally returns the many-shot ticket ?_{TicketA} (an atom)
            under which the value ?_{X} is offered.
          <P>
            The value ?_{X} is exported immediately. An exception is
            raised, if exportation of ?_{X} fails, because ?_{X} might
            refer to sited entities.

          <Entry><Span class=index/<<getTicket>>/
	    <Index/<<Connection>><And><<gate>><And><<getTicket>>/
          <Synopsis>
	    <<getTicket(?_{TicketA})>>
          <Item>
            Returns the many-shot ticket ?_{TicketA} (an atom) of the
            gate. 

          <Entry><Span class=index/<<close>>/
	    <Index/<<Connection>><And><<gate>><And><<close>>/
          <Synopsis>
	    <<close()>>
          <Item>
            Closes the gate, which makes further use of the associated
            ticket illegal.

        </List>
      </P>
      
    </Section>

  </Chapter>


  <Chapter id="Chapter.Remote">
    <Title/Spawning Computations Remotely: <<Remote>>/

    <P>
      The module <<Remote>> provides the class <<Remote.manager>> by
      which new Oz processes can be created. Creating an instance of
      that class does the following two things:
      <List>
        <Item> A new Oz process with a module manager ?_{M} is
               created. 
        <Item> The newly created object ?_{O} serves as a proxy to
               ?_{M}, where ?_{O} can be seen as a remote module
               manager. This allows to start applications remotely
               that access remote resources by local system modules.
      </List>
    </P>
 
    <P>
      The methods of the class <<Remote.manager>> are as follows.
    </P>

    <P>
     The methods of Remote.manager are as follows:
    </P>

    <P>
      <List>
        <Entry><Span class=index/<<init>>/
	  <Index/<<Remote>><And><<manager>><And><<init>>/
        <Synopsis>
<<<init(host:   ?+{HostV}   <= localhost
     fork:   ?+{ForkA}   <= automatic
     detach: ?+{DetachB} <= false)>>>
        <Item>
          Creates a new Oz process at ?_{HostV} (specified by a virtual
          string), where <<localhost>> is the computer running the
          current Oz process.
        <P>
          ?_{ForkA} (an atom) determines the operating system method
          to fork the remote Oz process. Currently, <<'automatic'>> and
          <<'rsh'>> are supported.  <<'rsh'>> creates
          a shell remotely by using the Unix <<rsh>> command, which in
          turn creates the new Oz engine. 
        <P>
          If ?_{HostV} is <<'localhost'>> and ?_{ForkA}? is
          <<'automatic'>> a possibly more efficient way of creating
          new Oz processes is used. As a fallback, the <<'rsh'>>
          method is used.
        <P>
          If ?_{DetachB} is <<false>>, a non-detached process is
          created. A non-detached process terminates as soon as 
          the creating process does (think of crashes, there will be
          no orphaned processes). A lifetime of a detached process
          (that is, ?_{DetchB} is <<true>>) is independent of the
          creating process. (I've taken the notion detach from
          standard operating system terminology).

        <Entry><Span class=index/<<link>>/
	  <Index/<<Remote>><And><<manager>><And><<link>>/
        <Synopsis>
	    <<<link(url:?+{UrlV} ?_{ModuleR} <= _)>>>
	    <<<link(name:?+{NameV} ?_{ModuleR} <= _)>>>
        <Item>
            Links the module identified either by a url ?_{UrlV} (a
            virtual string) or a module name ?_{NameV} (a virtual
            string). Returns the module ?_{ModuleR}, if it has been
            already linked or a future to it.
          <P>
            The argument for the module is optional, if it is omitted
            the module is requested immediately.

          <Entry><Span class=index/<<apply>>/
	    <Index/<<Remote>><And><<manager>><And><<apply>>/
          <Synopsis>
	    <<<apply(url:?+{UrlV} ?+{Functor} ?_{ModuleR} <= _)>>>
	    <<<apply(name:?+{NameV} ?+{Functor} ?_{ModuleR} <= _)>>>
          <Item>
            Applies the functor ?_{Functor}, where the url ?_{UrlV} (a
            virtual string) or the module name ?_{NameV} (a virtual
            string) serve as base URL for linking the functor's
            import.
          <P>
            The argument for the module is optional.
          <P>
            Please note that the resulting module is <Em/not/ added to
            the module table, the URL argument only serves as base URL
            for the functor's import.

          <Entry><Span class=index/<<enter>>/
	    <Index/<<Remote>><And><<manager>><And><<enter>>/
          <Synopsis>
	    <<<enter(url:?+{UrlV} ?_{ModuleR})>>>
	    <<<enter(name:?+{NameV} ?_{ModuleR})>>>
          <Item>
            Installs the module ?_{ModuleR} under the url ?_{UrlV} (a
            virtual string) or the module name ?_{NameV} (a virtual
            string).
          <P>
            Raises an exception if the module manager already has a
            module under that particular URL installed.

          <Entry><Span class=index/<<ping>>/
	    <Index/<<Remote>><And><<manager>><And><<ping>>/
          <Synopsis>
	    <<<ping()>>>
          <Item>
           Raises exception if remote process is dead. Blocks until
           executed by remote process.

          <Entry><Span class=index/<<close>>/
	    <Index/<<Remote>><And><<manager>><And><<close>>/
          <Synopsis>
	    <<<close()>>>
          <Item>
            Kills the remote process.

        </List>
       </P>         

     
  </Chapter>


  <Chapter id="Chapter.Fault">
    <Title/Detecting and Handling Failure: <<Fault>>/
  </Chapter>


  <Chapter id="Chapter.URL">
    <Title/Refering Distributed Entities: <<URL>>/
  </Chapter>


  <Chapter id="Chapter.Resolve">
    <Title/Resolving URLs: <<Resolve>>/
  </Chapter>


</Part>

