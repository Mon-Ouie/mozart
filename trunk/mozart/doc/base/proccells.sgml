<!--
  Translated to SGML by:
     Daniel Simon, dansim@ps.uni-sb.de
     Leif Kornstaedt, kornstae@ps.uni-sb.de
-->

<Chapter id="chapter.proccells">
  <Title/Procedures, Cells, and Spaces/
  <Section>
    <Title/Procedures/
    <P>
      The module <Span class=index/<<Procedure>>/ specifies operations on
      procedures.
      <List>
	<Entry><Span class=index/<<IsProcedure>>/
	  <Index class=tails/<<Procedure>><And><<is>>/
	<Synopsis>
	  <<{Procedure.is ?+{X} ??{B}}>>
	<Item>
	  tests whether ?_{X} is a procedure.

	<Entry><Span class=index/<<ProcedureArity>>/
	  <Index class=tails/<<Procedure>><And><<arity>>/
	<Synopsis>
	  <<{Procedure.arity ?+{P} ??{I}}>>
	<Item>
	  returns the procedure arity of&nbsp;?_{P}, &ie;, the number of
	  arguments which ?_{P} takes.

	<Entry><<apply>>
	  <Index class=tails/<<Procedure>><And><<apply>>/
	<Synopsis>
	  <<{Procedure.apply ?+{P} ?+{Xs}}>>
	<Item>
	  applies the procedure&nbsp;?_{P} to the arguments given
	  by the elements of the list&nbsp;?_{Xs}, provided that
	  <<<{Procedure.arity ?_{P}} == {Length ?_{Xs}}>>>
      </List>

  <Section>
    <Title/Cells/
    <P>
      The module <Span class=index/<<Cell>>/ contains procedures operating
      on cells.
      <List>
	<Entry><Span class=index/<<IsCell>>/
	  <Index class=tails/<<Cell>><And><<is>>/
	<Synopsis>
	  <<{Cell.is ?+{X} ??{B}}>>
	<Item>
	  tests whether ?_{X} is a cell.

	<Entry><Span class=index/<<NewCell>>/
	  <Index class=tails/<<Cell>><And><<new>>/
	<Synopsis>
	  <<{Cell.new ?_{X} ??{Cell}}>>
	<Item>
	  returns a new cell with initial content&nbsp;?_{X}.

	<Entry><Span class=index/<<Exchange>>/
	  <Index/<<Cell>><And><<exchange>>/
	<Synopsis>
	  <<{Cell.exchange ?+{Cell} ?_{X} ?_{Y}}>>
	<Item>
	  returns the current content of ?_{Cell} in&nbsp;?_{X}, and sets the
	  content of ?_{Cell} to&nbsp;?_{Y}.

	<Entry><Span class=index/<<Access>>/
	  <Index/<<Cell>><And><<access>>/
	<Synopsis>
	  <<{Cell.access ?+{Cell} ?_{X}}>>
	<Item>
	  returns the current content of ?_{Cell} in&nbsp;?_{X}.

	<Entry><Span class=index/<<Assign>>/
	<Synopsis>
	  <<{Cell.assign ?+{Cell} ?_{X}}>>
	<Item>
	  sets the content of ?_{Cell} to&nbsp;?_{X}.
      </List>


      <section >
        <title/Spaces/

<p>
First-class computation spaces can be used to program inference
engines for problem solving.

<list>
<entry><<IsSpace>>
<index class=module/IsSpace/
<synopsis>
<<<{IsSpace ?+{X} ??{B}}>>>
<item>
tests whether ?{X} is a space.

<entry><<new>>
<index class=module/Space<and>new/
<synopsis>
<<<{Space.new ?+{P} ??{Space}}>>>
<item>
returns a newly created space, in which a thread containing an
application of the unary procedure ?{P} to the root variable of
?{Space} is created.

<entry><<ask>>
<index class=module/Space<and>ask/
<synopsis>
<<<{Space.ask ?+{Space} ??{T}}>>>
<item>
waits until ?{Space} becomes stable or merged and then returns the
status of ?{Space}. 
<p>
If ?{Space} is merged, the atom <<merged>> is returned.
<p>
If ?{Space} is stable and:
<list>
<entry>failed
<item>the atom <<failed>> is returned.
<entry>succeeded
<item>and there are no threads in ?{Space} synchronizing on
choices,  the atom <<succeeded>> is returned.
<entry>succeeded
<item>and there is at least one thread in ?{Space} which
synchronizes on a choice the tuple <<alternatives(?{I})>> is returned, where ?{I} gives the number of alternatives of the selected choice.
</list>

<entry>askVerbose
<index class=module/Space<and>askVerbose/
<synopsis>
<<<{Space.askVerbose ?+{Space} ??{T}}>>>
<item>
returns the status of ?{Space} in verbose form. Reduces when
?{Space} becomes merged or stable.
<p>
If ?{Space} becomes merged, the atom <<merged>> is returned.
<p>
If ?{Space} becomes blocked but not stable, ?{T} is bound to the tuple
<<blocked(?{T1})>>. ?{T1} is bound to the status of
?{Space} when ?{Space} becomes unblocked again.
<p>
If ?{Space} is stable and:
<list>
<entry>failed
<item>the atom <<failed>> is returned.
<entry>succeeded
<item>and there are no threads in ?{Space} synchronizing on
choices,  the tuple <<succeeded(?{A})>> is returned.
The atom ?{A} is either <<suspended>>, when ?+{Space} still contains threads, or <<entailed>> otherwise. 
<entry>succeeded
<item>and there is at least one thread in ?{Space} which
synchronizes on a choice the tuple <<alternatives(?{I})>> is returned, where ?{I} gives the number of alternatives of the selected choice.
</list>

<entry><<merge>>
<index class=module/Space<and>merge/
<synopsis>
<<<{Space.merge ?+{Space} ?{X}}>>>
<item>
merges ?{Space} with the current space and constrains ?{X} to the
root variable of ?{Space}.

<p>
Raises a runtime error if ?{Space} is already merged, or if the
current space is subordinated to ?{Space}.

<entry><<clone>>
<index class=module/Space<and>clone/
<synopsis>
<<<{Space.clone ?+{Space1} ??{Space2}}>>>
<item>
blocks until ?{Space1} becomes stable and returns a new space which is a copy of ?{Space1}.

<p>
Raises a runtime error if ?{Space1} has been merged already.

<entry><<inject>>
<index class=module/Space<and>inject/
<synopsis>
<<<{Space.inject ?+{Space} ?+{P}}>>>
<item>
creates a thread in the space ?{Space} which contains an application
of the unary procedure ?{P} to the root variable of ?{Space}.

<p>
Raises a runtime error if ?{Space} has been merged already or if the
current space is subordinated to ?{Space}.

<entry><<commit>>
<index class=module/Space<and>commit/
<synopsis>
<<<{Space.commit ?+{Space} ?+{IT}}>>>
<item>
blocks until ?{Space} becomes stable and then commits to alternatives
of the selected choice of ?{Space}.

<p>
If ?{IT} is a pair of integers <<l#r>> then all but the
l, l+1, &ellipsis;, r alternatives of the selected choice 
of ?+{Space} are discarded. If a single
alternative remains, the topmost choice is replaced by this alternative.
If no alternative remains, the space is failed.

<p>
An integer value for ?{IT} is  an abbrevation for the pair
<<?{IT}#?{IT}>>.

<p>
Raises a runtime error, if ?{Space} has been merged already, if there
exists no selected choice in ?{Space}, or if the
current space is subordinated to ?{Space}.
</list>



</Chapter>
