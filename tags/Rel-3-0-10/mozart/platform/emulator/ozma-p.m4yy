dnl
dnl Author:
dnl   Leif Kornstaedt <kornstae@ps.uni-sb.de>
dnl
dnl Copyright:
dnl   Leif Kornstaedt, 1997
dnl
dnl Last change:
dnl   $Date$ by $Author$
dnl   $Revision$
dnl
dnl This file is part of Mozart, an implementation of Oz 3:
dnl   http://mozart.ps.uni-sb.de
dnl
dnl See the file "LICENSE" or
dnl   http://mozart.ps.uni-sb.de/LICENSE.html
dnl for information on usage and redistribution
dnl of this file, and for a DISCLAIMER OF ALL
dnl WARRANTIES.
dnl

%{
#include "conf.h"
#include "resources.hh"

#undef OZMA_DEBUG

#include "indexing.hh"
#include "dictionary.hh"
#include "builtins.hh"
#include "codearea.hh"
#include "am.hh"

#define YYERROR_VERBOSE

void ozmaerror(const char *message);
int ozmalex(void);
void ozmarestart(FILE *);

static CodeArea *codeArea = NULL;
#ifdef OZMA_DEBUG
static int ninstrs = 0;
#endif

static OzDictionary *labelDict = NULL;
static OzDictionary *abstrEntryDict = NULL;
static OzDictionary *nameDict1 = NULL;
static OzDictionary *nameDict2 = NULL;
static OzDictionary *runTimeDict = NULL;

static IHashTable *ht = NULL;

static ProgramCounter opcodePC = 0;
static Opcode *opcodeTable = NULL;
static int opcodeIndex = 0, opcodeIndexFactor = 0;

static SRecordArity getArity(TaggedRef arity) {
  arity = oz_deref(arity);
  if (oz_isSmallInt(arity)) {
    return mkTupleWidth(smallIntValue(arity));
  }

  int len = oz_fastlength(arity);
  arity = sortlist(arity,len);
  Arity *ari = aritytable.find(arity);
  return (ari->isTuple())? mkTupleWidth(ari->getWidth()): mkRecordArity(ari);
}

inline Bool getBool(TaggedRef t) {
  return literalEq(oz_deref(t),NameTrue);
}

static void lookupLabel(TaggedRef key, int *location) {
  TaggedRef backpatchListOrLabel;
  if (labelDict->getArg(key,backpatchListOrLabel) == PROCEED)
    if (OZ_isInt(backpatchListOrLabel))
      *location = (ProgramCounter) OZ_intToC(backpatchListOrLabel) - opcodePC;
    else
      labelDict->setArg(key,OZ_cons(OZ_cons(OZ_int((int) opcodePC),
					    OZ_int((int) location)),
				    backpatchListOrLabel));
  else
    labelDict->setArg(key,OZ_cons(OZ_cons(OZ_int((int) opcodePC),
					  OZ_int((int) location)),
				  OZ_nil()));
}

%}

%union {
  TaggedRef tagged;
  int index;
}

%token <tagged> INTEGER FLOAT NIL ATOM
%token <tagged> TRUE FALSE UNIT NAMEDNAME COPYABLENAME UNIQUENAME
%token <tagged> PREDICATEREF COPYABLEPREDICATEREF RUNTIMEPROC
%token <index> XREGISTER YREGISTER GREGISTER
%token POS LBL PID HT ONSCALAR ONRECORD GCI AMI

define(readArg,$1)
define(writeArg,$1)
define(instruction,%token `T_$1')
define(instructionsUnneededForNewCompiler,`divert(-1)')
include(EMUDIR/instrDefs.m4)
undefine(`instruction')

%type <tagged> DefLabel
%type <tagged> ANumber
%type <tagged> ALiteral
%type <tagged> Atom
%type <tagged> Bool
%type <tagged> Name
%type <tagged> Pos
%type <tagged> Flags
%type <tagged> FlagsList
%type <tagged> HashTableEntries
%type <tagged> HashTableEntry
%type <tagged> NumOrLit
%type <tagged> ARecordArity
%type <tagged> ArityFeatures
%type <tagged> ArityFeature
%type <tagged> Registers
%type <tagged> ARegister
%type <tagged> LocIndices
%type <tagged> LocIndex

%%

File		: CodeSize Instructions
		  {
		    ; //--** warn about undeclared labels
#ifdef OZMA_DEBUG
		    printf("\nCode:\n");
		    displayCode(codeArea->getStart(),ninstrs);
#endif
		  }
		;

CodeSize	: INTEGER
		  {
		    int size = OZ_intToC($1);
#ifdef OZMA_DEBUG
		    ninstrs = 0;
#endif
		    codeArea = new CodeArea(size);
		    labelDict = new OzDictionary(oz_currentBoard());
		    abstrEntryDict = new OzDictionary(oz_currentBoard());
		    nameDict1 = new OzDictionary(oz_currentBoard());
		    nameDict2 = new OzDictionary(oz_currentBoard());
		    runTimeDict = new OzDictionary(oz_currentBoard());
		  }
		;

Instructions	: Instruction
		| Instructions Instruction
		;

changequote(@,~)
define(noReg,{ opcodePC = codeArea->getWritePtr();
#ifdef OZMA_DEBUG
  ninstrs++;
#endif
  codeArea->writeOpcode((Opcode) $1);
})
define(oneReg,{ opcodePC = codeArea->getWritePtr();
#ifdef OZMA_DEBUG
  ninstrs++;
#endif
  codeArea->writeOpcode((Opcode) OZERROR);
  static Opcode ops[3] = {@`$1X,$1Y,$1G'~};
  opcodeTable = ops;
  opcodeIndex = 0;
  opcodeIndexFactor = 1;
})
define(twoRegs,{ opcodePC = codeArea->getWritePtr();
#ifdef OZMA_DEBUG
  ninstrs++;
#endif
  codeArea->writeOpcode((Opcode) OZERROR);
  static Opcode ops[9] = {@`$1XX,$1XY,$1XG,'~
			  @`$1YX,$1YY,$1YG,'~
			  @`$1GX,$1GY,$1GG'~};
  opcodeTable = ops;
  opcodeIndex = 0;
  opcodeIndexFactor = 3;
})
define(instruction,| @T_$1~
@ifelse(numOfRegs($2,$3,$4),1,oneReg(TOUPPER($1)),
	numOfRegs($2,$3,$4),2,twoRegs(TOUPPER($1)),
	noReg(TOUPPER($1)))~
@ifelse(`$#',1,,'`('' )~dnl
$2 $3 $4 $5 $6 $7 dnl
@ifelse(`$#',1,,'`)'' )~
@ifelse(numOfRegs($2,$3,$4),0,,
{ codeArea->writeOpcode(opcodeTable[opcodeIndex],opcodePC); }
)~
)
changequote(`,')

DefLabel	: Atom
		  { $$ = $1; }
		| INTEGER
		  { $$ = $1; }
		;

Instruction	: LBL '(' DefLabel ')'
		  {
		    TaggedRef backpatchList;
		    ProgramCounter PC = codeArea->getWritePtr();
		    if (labelDict->getArg($3,backpatchList) == PROCEED) {
		      if (OZ_isInt(backpatchList))
			ozmaerror("label multiply defined");
		      else
			while (!literalEq(backpatchList,AtomNil)) {
			  TaggedRef pair = oz_head(backpatchList);
			  ProgramCounter opcodePC =
			      (ProgramCounter) OZ_intToC(oz_head(pair));
			  int *location = (int *) OZ_intToC(oz_tail(pair));
			  *location = PC - opcodePC;
			  backpatchList = oz_tail(backpatchList);
			}
		    }
		    labelDict->setArg($3,OZ_int((int) PC));
		  }
include(EMUDIR/instrDefs.m4)
undefine(`instruction')
		;

ANumber		: INTEGER
		  { $$ = $1; }
		| FLOAT
		  { $$ = $1; }
		;

Number		: ANumber
		  { codeArea->writeTagged($1); }
		;

ALiteral	: Atom
		  { $$ = $1; }
		| Name
		  { $$ = $1; }
		;

Literal		: ALiteral
		  { codeArea->writeTagged($1); }
		;

Atom		: NIL
		  { $$ = OZ_nil(); }
		| ATOM
		  { $$ = $1; }
		;

Bool		: TRUE
		  { $$ = OZ_true(); }
		| FALSE
		  { $$ = OZ_false(); }
		;

Name		: Bool
		  { $$ = $1; }
		| UNIT
		  { $$ = OZ_unit(); }
		| NAMEDNAME
		  {
		    TaggedRef key = $1;
		    TaggedRef theName;
		    if (nameDict1->getArg(key,theName) != PROCEED) {
		      const char *s = tagged2Literal(key)->getPrintName();
		      NamedName *lit = NamedName::newNamedName(s);
		      theName = makeTaggedLiteral(lit);
		      nameDict1->setArg(key,theName);
		    }
		    $$ = theName;
		  }
		| COPYABLENAME
		  {
		    TaggedRef key = $1;
		    TaggedRef theName;
		    if (nameDict2->getArg(key,theName) != PROCEED) {
		      const char *s = tagged2Literal(key)->getPrintName();
		      NamedName *lit = NamedName::newNamedName(s);
		      lit->setFlag(Lit_isCopyableName);
		      theName = makeTaggedLiteral(lit);
		      nameDict2->setArg(key,theName);
		    }
		    $$ = theName;
		  }
		| UNIQUENAME
		  { $$ = $1; }
		;

Feature		: INTEGER
		  { codeArea->writeTagged($1); }
		| Literal
		;

Constant	: Number
		| Literal
		| RUNTIMEPROC
		  {
		    TaggedRef proc;
		    if (runTimeDict->getArg($1,proc) != PROCEED) {
		      proc = OZ_newVariable();
		      runTimeDict->setArg($1,proc);
		    }
		    codeArea->writeTagged(proc);
		  }
		;

Builtinname	: Atom
		  {
		    Builtin * found = atom2Builtin($1);
		    if (!found) {
		      ozmaerror("undefined builtin");
		      YYERROR;
		    }
		    codeArea->writeBuiltin(found);
		  }
		;

Register	: XREGISTER
		  {
		    codeArea->writeReg($1);
		    opcodeIndexFactor /= 3;
		   }
		| YREGISTER
		  {
		    codeArea->writeReg($1);
		    opcodeIndex += opcodeIndexFactor;
		    opcodeIndexFactor /= 3;
		   }
		| GREGISTER
		  {
		    codeArea->writeReg($1);
		    opcodeIndex += 2 * opcodeIndexFactor;
		    opcodeIndexFactor /= 3;
		   }
		;

XRegisterIndex	: XREGISTER
		  { codeArea->writeReg($1); }
		;

YRegisterIndex	: YREGISTER
		  { codeArea->writeReg($1); }
		;

Label		: DefLabel
		  {
		    int *location = (int *) codeArea->getWritePtr();
		    codeArea->writeLabel(0);   // write a dummy for now
		    lookupLabel($1,location);
		  }
		;

Integer		: INTEGER
		  { codeArea->writeInt(OZ_intToC($1)); }
		;

Arity		: Integer
		;

Count		: Integer
		;

ArityAndIsTail	: Integer
		;

Dummy		: Integer
		;

PredicateRef	: UNIT
		  { codeArea->writeAddress(NULL); }
		| PREDICATEREF
		  {
		    TaggedRef key = $1;
		    AbstractionEntry *predId;
		    TaggedRef abstrEntry;
		    if (abstrEntryDict->getArg(key,abstrEntry) == PROCEED) {
		      void *p = OZ_getForeignPointer(abstrEntry);
		      predId = (AbstractionEntry *) p;
		    } else {
		      predId = new AbstractionEntry(NO);
		      abstrEntry = OZ_makeForeignPointer(predId);
		      abstrEntryDict->setArg(key,abstrEntry);
		    }
		    codeArea->writeAddress(predId);
		  }
		| COPYABLEPREDICATEREF
		  {
		    TaggedRef key = $1;
		    AbstractionEntry *predId;
		    TaggedRef abstrEntry;
		    if (abstrEntryDict->getArg(key,abstrEntry) == PROCEED) {
		      void *p = OZ_getForeignPointer(abstrEntry);
		      predId = (AbstractionEntry *) p;
		    } else {
		      predId = new AbstractionEntry(OK);
		      abstrEntry = OZ_makeForeignPointer(predId);
		      abstrEntryDict->setArg(key,abstrEntry);
		    }
		    codeArea->writeAddress(predId);
		  }
		;

Pos             : POS '(' Atom INTEGER INTEGER ')'
		  { $$ = OZ_mkTuple(OZ_atom("pos"),3,$3,$4,$5); }
		;

Flags           : NIL
		  { $$ = OZ_nil(); }
		| '[' FlagsList ']'
		  { $$ = $2; }
		;

FlagsList       : Atom
		  { $$ = OZ_cons($1,OZ_nil()); }
		| Atom FlagsList
		  { $$ = OZ_cons($1,$2); }
		;

PredId		: PID '(' Atom ARecordArity Pos Flags INTEGER ')'
		  {
		    const OZ_Term printname = $3;
		    const SRecordArity arity = getArity($4);
		    const OZ_Term pos = $5;
		    const OZ_Term flags = $6;
		    const maxX = OZ_intToC($7);
		    PrTabEntry *pte =
		      new PrTabEntry(printname,arity,pos,flags,maxX);
		    codeArea->writeAddress(pte);
		  }
		;

HashTableRef	: HT '(' DefLabel '[' HashTableEntries ']' ')'
		  {
		    TaggedRef elseLabel = $3;
		    TaggedRef entries = $5;
		    int size = oz_fastlength(entries);
		    ht = new IHashTable(size,0);
		    lookupLabel(elseLabel,&ht->elseLabel);
		    for (int i = 0; i < size; i++) {
		      SRecord *rec = tagged2SRecord(oz_head(entries));
		      entries = oz_tail(entries);
		      const char *label =
			rec->getLabelLiteral()->getPrintName();
		      if (!strcmp(label,"onScalar")) {
			TaggedRef value = rec->getArg(0);
			if (oz_isLiteral(value))
			  lookupLabel(rec->getArg(1),
				      ht->add(tagged2Literal(value),0));
			else
			  lookupLabel(rec->getArg(1),
				      ht->add(value,0));
		      } else {
			TaggedRef reclabel = rec->getArg(0);
			SRecordArity ar = getArity(rec->getArg(1));
			if (literalEq(reclabel,AtomCons)
			    && sraIsTuple(ar) && getTupleWidth(ar)==2) {
			  ht->listLabel = 1;
			  lookupLabel(rec->getArg(2),&ht->listLabel);
			} else
			  lookupLabel(rec->getArg(2),
				      ht->add(tagged2Literal(reclabel),ar,0));
		      }
		    }
		    if (!ht->listLabel)
		      lookupLabel(elseLabel,&ht->listLabel);
		    codeArea->writeAddress(ht);
		  }
		;

HashTableEntries: HashTableEntry
		  { $$ = OZ_cons($1,OZ_nil()); }
		| HashTableEntry HashTableEntries
		  { $$ = OZ_cons($1,$2); }
		;

HashTableEntry	: ONSCALAR '(' NumOrLit DefLabel ')'
		  { $$ = OZ_mkTuple(OZ_atom("onScalar"),2,$3,$4); }
		| ONRECORD '(' ALiteral ARecordArity DefLabel ')'
		  { $$ = OZ_mkTuple(OZ_atom("onRecord"),3,$3,$4,$5); }
		;

NumOrLit	: ANumber
		  { $$ = $1; }
		| ALiteral
		  { $$ = $1; }
		;

RecordArity	: ARecordArity
		  { codeArea->writeSRecordArity(getArity($1)); }
		;

ARecordArity	: INTEGER
		  { $$ = $1; }
		| '[' ArityFeatures ']'
		  { $$ = $2; }
		;

ArityFeatures	: ArityFeature
		  { $$ = OZ_cons($1,OZ_nil()); }
		| ArityFeature ArityFeatures
		  { $$ = OZ_cons($1,$2); }
		;

ArityFeature	: INTEGER
		  { $$ = $1; }
		| Atom
		  { $$ = $1; }
		| Name
		  { $$ = $1; }
		;

GenCallInfo	: GCI '(' GREGISTER Bool ALiteral Bool ARecordArity ')'
		  {
		    SRecordArity ari = getArity($7);
		    GenCallInfoClass *gci =
		      new GenCallInfoClass($3,getBool($4),$5,getBool($6),ari);
		    codeArea->writeAddress(gci);
		  }
		;

ApplMethInfo	: AMI '(' ALiteral ARecordArity ')'
		  {
		    SRecordArity ari = getArity($4);
		    ApplMethInfoClass *ami = new ApplMethInfoClass($3,ari);
		    codeArea->writeAddress(ami);
		  }
		;

GRegRef		: '[' Registers ']'
		  {
		    TaggedRef globals = $2;
		    int numglobals = oz_fastlength(globals);
		    AssRegArray *gregs = new AssRegArray(numglobals);
		    for (int i = 0; i < numglobals; i++) {
		      SRecord *rec = tagged2SRecord(oz_deref(oz_head(globals)));
		      globals = oz_deref(oz_tail(globals));
		      const char *label =
			rec->getLabelLiteral()->getPrintName();
		      KindOfReg regType;
		      if (!strcmp(label,"x")) {
			regType = XReg;
		      } else if (!strcmp(label,"y")) {
			regType = YReg;
		      } else {
			regType = GReg;
		      }
		      (*gregs)[i].kind = regType;
		      (*gregs)[i].number =
			smallIntValue(oz_deref(rec->getArg(0)));
		    }
		    codeArea->writeAddress(gregs);
		  }
		| NIL
		  {
		    AssRegArray *gregs = new AssRegArray(0);
		    codeArea->writeAddress(gregs);
		  }
		;

Registers	: ARegister
		  { $$ = OZ_cons($1,OZ_nil()); }
		| ARegister Registers
		  { $$ = OZ_cons($1,$2); }
		;

ARegister	: XREGISTER
		  { $$ = OZ_mkTuple(OZ_atom("x"),1,OZ_int($1)); }
		| YREGISTER
		  { $$ = OZ_mkTuple(OZ_atom("y"),1,OZ_int($1)); }
		| GREGISTER
		  { $$ = OZ_mkTuple(OZ_atom("g"),1,OZ_int($1)); }
		;

Location	: LocIndices '#' LocIndices
		  {
		    TaggedRef ins = $1;
		    TaggedRef outs = $3;
		    int inArity = oz_fastlength(ins);
		    int outArity = oz_fastlength(outs);
		    OZ_Location *loc =
		      OZ_Location::newLocation(inArity,outArity);
		    for (int i = 0; i < inArity; i++) {
		      loc->in(i) = smallIntValue(oz_head(ins));
		      ins = oz_tail(ins);
		    }
		    for (int i = 0; i < outArity; i++) {
		      loc->out(i) = smallIntValue(oz_head(outs));
		      outs = oz_tail(outs);
		    }
		    codeArea->writeAddress(loc);
		  }
		;

LocIndices	: '[' LocIndex ']'
		  { $$ = $2; }
		| NIL
		  { $$ = oz_nil(); }
		;

LocIndex	: XREGISTER
		  { $$ = OZ_cons(OZ_int($1),OZ_nil()); }
		| XREGISTER LocIndex
		  { $$ = OZ_cons(OZ_int($1),$2); }
		;

Cache		: Atom
		  { codeArea->writeCache(); }
		;

%%

OZ_BI_define(ozma_readProc,1,1)
{
  oz_declareVirtualStringIN(0,filename);

  FILE *file = fopen(filename,"r");
  if (file == NULL) {
    ozmaerror("could not open input file");
    return FAILED;
  }
  ozmarestart(file);
  int res = ozmaparse();
  fclose(file);

  if (res)
    return FAILED;

  const int maxX=-1; // should never suspend
  PrTabEntry *pte
    = new PrTabEntry(OZ_atom("toplevelAbstraction"),
		mkTupleWidth(0),
		OZ_mkTupleC("pos",3,OZ_atom(""),OZ_int(0),OZ_int(0)),
		oz_nil(),maxX);
  pte->PC = codeArea->getStart();
  pte->setGSize(1);
  Abstraction *ab = Abstraction::newAbstraction(pte,oz_currentBoard());
  ab->initG(0,makeTaggedConst(runTimeDict));
  OZ_RETURN(makeTaggedConst(ab));
} OZ_BI_end
