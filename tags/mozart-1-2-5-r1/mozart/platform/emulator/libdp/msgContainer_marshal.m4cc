/* -*- C++ -*-
 *  Authors:
 *    Anna Neiderud (annan@sics.se)
 *    Konstantin Popov <kost@sics.se>
 * 
 *  Contributors:
 * 
 *  Copyright:
 * 
 *  Last change:
 *    $Date$ by $Author$
 *    $Revision$
 * 
 *  This file is part of Mozart, an implementation 
 *  of Oz 3:
 *     http://www.mozart-oz.org
 * 
 *  See the file "LICENSE" or
 *     http://www.mozart-oz.org/LICENSE.html
 *  for information on usage and redistribution 
 *  of this file, and for a DISCLAIMER OF ALL 
 *  WARRANTIES.
 *
 */

#include "base.hh"
#include "dpBase.hh"
#include "dpMarshaler.hh"

#include "byteBuffer.hh"
#include "msgContainer.hh"

void MsgContainer::marshal(ByteBuffer *bb,
			   TransController *transController) {
  if(!checkFlag(MSG_HAS_MARSHALCONT)) {
    mess_counter[mt].send();
  }
  else
    clearFlag(MSG_HAS_MARSHALCONT);

  for(int i=0;i<MAX_NOF_FIELDS;i++) {
    if(checkFlag(MSG_HAS_MARSHALCONT))
      break;
    void *ret=(void *) 0;
    Bool fullTopFlag = NO;

    switch(msgFields[i].ft) {
    case FT_NUMBER:
      if(bb->availableSpace() >= MNumberMaxSize) {
	marshalNumber(bb, (int) msgFields[i].arg);
	msgFields[i].ft=FT_NONE;
      }
      else
	setFlag(MSG_HAS_MARSHALCONT);
      break;

    case FT_CREDIT:
      if(bb->availableSpace() >= MNumberMaxSize) {
	marshalNumber(bb, (int) msgFields[i].arg);
	msgFields[i].ft=FT_NONE;
      }
      else
	setFlag(MSG_HAS_MARSHALCONT);
      break;

    //
    case FT_FULLTOPTERM:
      fullTopFlag = OK;
    case FT_TERM: {
      DPMarshaler *dpm;
      if(cont == (void *) 0) {
	dpm = transController->getMarshaler();
	if (dpm==NULL) {OZ_error("No marshalers");}

	if (fullTopFlag) {
	  dpm->genFullToplevel();
	  fullTopFlag = NO;
	}
	ret = (void *) dpMarshalTerm(bb, dpm,
				     (TaggedRef) msgFields[i].arg, msgTS);
      } else {
	dpm = (DPMarshaler *) cont;
	fullTopFlag = NO;
	ret = (void *) dpMarshalTerm(bb, dpm, msgTS);
      }
      if(ret==(void *) 0) {
	msgFields[i].ft=FT_NONE;
	// ... otherwise lazy protocol didn't play out:
	Assert(dpm->isFullToplevel() == FALSE);
	transController->returnMarshaler(dpm);
	cont=(void *) 0;
      }
      else {
	setFlag(MSG_HAS_MARSHALCONT);
	cont=(void *) dpm;
	this->transController=transController;
      }
      break;
    }

    case FT_STRING:
      if(bb->availableSpace() >= MAX_DP_STRING) {
	marshalString(bb, (char*) msgFields[i].arg);
	msgFields[i].ft=FT_NONE;
      }
      else
	setFlag(MSG_HAS_MARSHALCONT);
      break;

    case FT_SITE:
      if(bb->availableSpace() >= MDSiteMaxSize) {
	marshalDSite(bb, (DSite*) msgFields[i].arg);
	msgFields[i].ft=FT_NONE;
      }	
      else
	setFlag(MSG_HAS_MARSHALCONT);
      break;

    case FT_NONE:
      break;
    }
  }
}

undefine(`message')
undefine(`argEnc')

define(message,`
       void MsgContainer::put_$1(mcarg($3,$4) mcarg($4,$5) mcarg($5,$6) mcarg($6,$7) mcarg($7 $8)) {
         mt=$1;
	 def_priority=$2;
	 argEnc($3,0)
	 argEnc($4,1)
	 argEnc($5,2)
	 argEnc($6,3)
	 argEnc($7,4)
       }')

define(mcarg,`ifelse($1,Index,int i1,
	             $1,Index2,int i2,
	             $1,Index3,int i3,
                     $1,Term,TaggedRef t,
                     $1,FullTopTerm,TaggedRef t,
		     $1,String,char *str,
                     $1,Credit,int c,
                     $1,Site,DSite *s1,
	             $1,Site2,DSite *s2,)'
              `ifelse($2,`',`',`,')')

define(argEnc,`ifelse($1,Index,msgFields[$2].arg=(void *) i1; msgFields[$2].ft=FT_NUMBER;,
	             $1,Index2,msgFields[$2].arg=(void *) i2; msgFields[$2].ft=FT_NUMBER;,
	             $1,Index3,msgFields[$2].arg=(void *) i3; msgFields[$2].ft=FT_NUMBER;,
                     $1,Term,msgFields[$2].arg=(void *) t; msgFields[$2].ft=FT_TERM;,
                     $1,FullTopTerm,msgFields[$2].arg=(void *) t; msgFields[$2].ft=FT_FULLTOPTERM;,
		     $1,String,Assert(MAX_DP_STRING>=strlen(str)); msgFields[$2].arg=(void *) str;msgFields[$2].ft=FT_STRING;,
                     $1,Credit,msgFields[$2].arg=(void *) c; msgFields[$2].ft=FT_CREDIT;,
                     $1,Site,msgFields[$2].arg=(void *) s1; msgFields[$2].ft=FT_SITE;,
	             $1,Site2,msgFields[$2].arg=(void *) s2; msgFields[$2].ft=FT_SITE;,
		     msgFields[$2].ft=FT_NONE;)')

include(EMUDIR/msgFormat.m4)

undefine(`message')
undefine(`mcarg')
undefine(`argEnc')

inline void messageError(MessageType mt, char *origin)
{
  OZ_error("Malicious message received: %s %s",mess_names[mt],origin);
//  OZ_warning("Malicious message received: %s %s",mess_names[mt],origin);
//  printf("Malicious message received: %s %s\n",mess_names[mt],origin);
}

define(message,`
       case $1:
       msgFields[0].ft=argEnc($3);
       msgFields[1].ft=argEnc($4);
       msgFields[2].ft=argEnc($5);
       msgFields[3].ft=argEnc($6);
       msgFields[4].ft=argEnc($7);
       break;')


define(argEnc,`ifelse($1,Index,FT_NUMBER,
		      $1,Index2,FT_NUMBER,
		      $1,Index3,FT_NUMBER,
	              $1,Term,FT_TERM,
	              $1,FullTopTerm,FT_FULLTOPTERM,
	              $1,Credit,FT_CREDIT,
	              $1,String,FT_STRING,
                      $1,Site,FT_SITE,
                      $1,Site2,FT_SITE,
		      FT_NONE)')

Bool MsgContainer::unmarshal(ByteBuffer *bb,
			     TransController *transController)
{
  if(!checkFlag(MSG_HAS_UNMARSHALCONT)) {
    switch(mt) {
      include(EMUDIR/msgFormat.m4)
	default:
	  PD((TCP_INTERFACE,"unmarshal got unknown `message': %d",mt));
    }
  }

  clearFlag(MSG_HAS_UNMARSHALCONT);
  for(int i=0;i<MAX_NOF_FIELDS;i++) {
    if(msgFields[i].ft!=FT_NONE && !bb->canGetInFrame(1)) {
      setFlag(MSG_HAS_UNMARSHALCONT); 
    }
    else {

      switch(msgFields[i].ft) {
      case FT_NUMBER:
#ifdef USE_FAST_UNMARSHALER   
	msgFields[i].arg = (void *) unmarshalNumber(bb);
	msgFields[i].ft = FT_NONE;
#else
	{
	  int error;
	  msgFields[i].arg = (void *) unmarshalNumberRobust(bb, &error);
	  if (error) {
	    messageError(mt, "MsgContainer::unmarshal: bad Number");
	    return (FALSE);
	  } else {
	    msgFields[i].ft = FT_NONE;
	  }
	}
#endif
	break;

      case FT_CREDIT:
#ifdef USE_FAST_UNMARSHALER   
        msgFields[i].arg = (void *) unmarshalNumber(bb);
	msgFields[i].ft = FT_NONE;
#else
	{
	  int error;
	  msgFields[i].arg = (void *) unmarshalNumberRobust(bb, &error);
	  if (error) {
	    messageError(mt, "MsgContainer::unmarshal: bad Credit");
	    return (FALSE);
	  } else {
	    msgFields[i].ft = FT_NONE;
	  }
	}
#endif
	break;

	//
	// There is one single unmarhslaer that understands also full
	// objects (and potentially also other structures with the
	// lazy protocol);
      case FT_FULLTOPTERM:
      case FT_TERM: {
        Builder *dpum;
        if (cont != 0) {
          dpum = (Builder *) cont;
        } else {
          dpum = transController->getUnmarshaler();
	  if (dpum==NULL) {OZ_error("No unmarshalers");}
	  dpUnmarshalerStartBatch(dpum);
	}

	//
	OZ_Term utRet = dpUnmarshalTerm(bb, dpum);

	//
	switch (utRet) {
	case (OZ_Term) 0:
	  dpUnmarshalerFinishBatch(dpum);
	  messageError(mt, "MsgContainer::unmarshal: bad Oz term");
	  return (FALSE);

	case (OZ_Term) -1:
	  this->transController=transController;
          cont=(void *) dpum;
          setFlag(MSG_HAS_UNMARSHALCONT);
	  break;

	default:
	  dpUnmarshalerFinishBatch(dpum);
	  msgFields[i].arg = (void *) utRet;
	  msgFields[i].ft=FT_NONE;
          transController->returnUnmarshaler(dpum);
          cont = (void *) 0;
        }
	break;
      }

      case FT_STRING:
#ifdef USE_FAST_UNMARSHALER   
        msgFields[i].arg = (void *) unmarshalString(bb);
	msgFields[i].ft = FT_NONE;
#else
	{
	  int error;
	  msgFields[i].arg = (void *) unmarshalStringRobust(bb, &error);
	  if (error) {
	    messageError(mt, "MsgContainer::unmarshal: bad string");
	    return (FALSE);
	  } else {
	    msgFields[i].ft = FT_NONE;
	  }
	}
#endif
	break;

      case FT_SITE:
#ifdef USE_FAST_UNMARSHALER   
	msgFields[i].arg = (void *) unmarshalDSite(bb);
	msgFields[i].ft = FT_NONE;
#else
	{
	  int error;
	  msgFields[i].arg = (void *) unmarshalDSiteRobust(bb, &error);
	  if (error) {
	    messageError(mt, "MsgContainer::unmarshal: bad site");
	    return (FALSE);
	  } else {
	    msgFields[i].ft = FT_NONE;
	  }
	}
#endif
	break;

      case FT_NONE:
	break;			// nothing is expected;
      }
    }
  }
  return (TRUE);
}

undefine(`argEnc')
undefine(`message')

define(mcarg,`ifelse($1,Index,int &i1,
	           $1,Index2,int &i2,
	           $1,Index3,int &i3,
                   $1,Term,TaggedRef &t,
                   $1,FullTopTerm,TaggedRef &t,
		   $1,String,char *&str,
                   $1,Credit,int &c,
                   $1,Site,DSite *&s1,
	           $1,Site2,DSite *&s2,)'
            `ifelse($2,`',`',`,')')

define(argEnc,`ifelse($1,Index,i1=(int),
		      $1,Index2,i2=(int),
		      $1,Index3,i3=(int),
	              $1,Term,t=(TaggedRef),
	              $1,FullTopTerm,t=(TaggedRef),
	              $1,Credit,c=(int),
	              $1,String,str=(char*),
                      $1,Site,s1=(DSite*),
                      $1,Site2,s2=(DSite*),
                      //)')

define(message,`
       void MsgContainer::get_$1(mcarg($3,$4) mcarg($4,$5) mcarg($5,$6) mcarg($6,$7) mcarg($7 $8)) {
         argEnc($3) msgFields[0].arg;
         argEnc($4) msgFields[1].arg;
         argEnc($5) msgFields[2].arg;
         argEnc($6) msgFields[3].arg;
         argEnc($7) msgFields[4].arg;
       }')

include(EMUDIR/msgFormat.m4)

undefine(`message')
undefine(`argEnc')

define(message,`
       case $1: {
         argEnc($3,msgFields[0].arg,msgFields[0].ft)
         argEnc($4,msgFields[1].arg,msgFields[1].ft)
         argEnc($5,msgFields[2].arg,msgFields[2].ft)
         argEnc($6,msgFields[3].arg,msgFields[3].ft)
         argEnc($7,msgFields[4].arg,msgFields[4].ft)
         break;
       }')

define(argEnc,`ifelse($1,Index,,
		      $1,Index2,,
		      $1,Index3,,
	              $1,Term,if(!checkFlag(MSG_HAS_UNMARSHALCONT) || $3==FT_NONE)
			         oz_gCollectTerm((TaggedRef &) $2, 
			                         (TaggedRef &) $2);,
	              $1,FullTopTerm,if(!checkFlag(MSG_HAS_UNMARSHALCONT) || $3==FT_NONE)
                                 oz_gCollectTerm((TaggedRef &) $2, (TaggedRef &) $2);,
	              $1,int,,
	              $1,String,,
                      $1,Site,if(!checkFlag(MSG_HAS_UNMARSHALCONT) || $3==FT_NONE)
((DSite*) $2)->makeGCMarkSite();,
                      $1,Site2,if(!checkFlag(MSG_HAS_UNMARSHALCONT) || $3==FT_NONE)
((DSite*) $2)->makeGCMarkSite();,)')

void MsgContainer::gcMsgC() {
//     printf("GC of %x (ucont %d term %x)\n",this,
//             checkFlag(MSG_HAS_UNMARSHALCONT),
//    	 (msgFields[1]).arg);
  if(destination!=NULL) 
    destination->makeGCMarkSite();
  if(checkFlag(MSG_HAS_MARSHALCONT) && cont != 0)
    ((DPMarshaler *) cont)->gCollect();
  else if(checkFlag(MSG_HAS_UNMARSHALCONT) && cont != 0){
//    printf("gcollect builder msgC: %x\n ",this); 
    ((Builder *) cont)->gCollect();}
  if (msgTS)
    gcTermSnapshot(msgTS);

  //
  switch(mt) {
include(EMUDIR/msgFormat.m4)
  default:
    PD((TCP_INTERFACE,"marshal got unknown `message': %d",mt));
  }
}

undefine(`message')
undefine(`argEnc')

define(message,`
       case $1:
       msgFields[0].ft=argEnc($3);
       msgFields[1].ft=argEnc($4);
       msgFields[2].ft=argEnc($5);
       msgFields[3].ft=argEnc($6);
       msgFields[4].ft=argEnc($7);
       break;')


define(argEnc,`ifelse($1,Index,FT_NUMBER,
		      $1,Index2,FT_NUMBER,
		      $1,Index3,FT_NUMBER,
	              $1,Term,FT_TERM,
	              $1,FullTopTerm,FT_FULLTOPTERM,
	              $1,Credit,FT_CREDIT,
	              $1,String,FT_STRING,
                      $1,Site,FT_SITE,
                      $1,Site2,FT_SITE,
		      FT_NONE)')

void MsgContainer::resetMarshaling() {
  if(checkFlag(MSG_HAS_MARSHALCONT)) {
    clearFlag(MSG_HAS_MARSHALCONT);
    if(cont!=0) {
      transController->returnMarshaler((DPMarshaler *) cont);
      cont=0;
    }
  }

  // Reset fields
  switch(mt) {
    include(EMUDIR/msgFormat.m4)
  default:
    ;
  }
}

// m4 -E -B10000 -DEMUDIR=/home/annan/source/mozart/platform/emulator/libdp msgContainer_marshal.m4cc > msgContainer_marshal.cc

